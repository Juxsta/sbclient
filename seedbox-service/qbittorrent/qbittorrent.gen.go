// Package qbittorrent provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package qbittorrent

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	SidScopes = "sid.Scopes"
)

// Defines values for AddTorrentsCommonFirstLastPiecePrio.
const (
	AddTorrentsCommonFirstLastPiecePrioFalse AddTorrentsCommonFirstLastPiecePrio = "false"
	AddTorrentsCommonFirstLastPiecePrioTrue  AddTorrentsCommonFirstLastPiecePrio = "true"
)

// Defines values for AddTorrentsCommonPaused.
const (
	AddTorrentsCommonPausedFalse AddTorrentsCommonPaused = "false"
	AddTorrentsCommonPausedTrue  AddTorrentsCommonPaused = "true"
)

// Defines values for AddTorrentsCommonRootFolder.
const (
	AddTorrentsCommonRootFolderFalse AddTorrentsCommonRootFolder = "false"
	AddTorrentsCommonRootFolderTrue  AddTorrentsCommonRootFolder = "true"
	AddTorrentsCommonRootFolderUnset AddTorrentsCommonRootFolder = "unset"
)

// Defines values for AddTorrentsCommonSequentialDownload.
const (
	AddTorrentsCommonSequentialDownloadFalse AddTorrentsCommonSequentialDownload = "false"
	AddTorrentsCommonSequentialDownloadTrue  AddTorrentsCommonSequentialDownload = "true"
)

// Defines values for AddTorrentsCommonSkipChecking.
const (
	AddTorrentsCommonSkipCheckingFalse AddTorrentsCommonSkipChecking = "false"
	AddTorrentsCommonSkipCheckingTrue  AddTorrentsCommonSkipChecking = "true"
)

// Defines values for AddTorrentsFilesFirstLastPiecePrio.
const (
	AddTorrentsFilesFirstLastPiecePrioFalse AddTorrentsFilesFirstLastPiecePrio = "false"
	AddTorrentsFilesFirstLastPiecePrioTrue  AddTorrentsFilesFirstLastPiecePrio = "true"
)

// Defines values for AddTorrentsFilesPaused.
const (
	AddTorrentsFilesPausedFalse AddTorrentsFilesPaused = "false"
	AddTorrentsFilesPausedTrue  AddTorrentsFilesPaused = "true"
)

// Defines values for AddTorrentsFilesRootFolder.
const (
	AddTorrentsFilesRootFolderFalse AddTorrentsFilesRootFolder = "false"
	AddTorrentsFilesRootFolderTrue  AddTorrentsFilesRootFolder = "true"
	AddTorrentsFilesRootFolderUnset AddTorrentsFilesRootFolder = "unset"
)

// Defines values for AddTorrentsFilesSequentialDownload.
const (
	AddTorrentsFilesSequentialDownloadFalse AddTorrentsFilesSequentialDownload = "false"
	AddTorrentsFilesSequentialDownloadTrue  AddTorrentsFilesSequentialDownload = "true"
)

// Defines values for AddTorrentsFilesSkipChecking.
const (
	AddTorrentsFilesSkipCheckingFalse AddTorrentsFilesSkipChecking = "false"
	AddTorrentsFilesSkipCheckingTrue  AddTorrentsFilesSkipChecking = "true"
)

// Defines values for AddTorrentsURLsFirstLastPiecePrio.
const (
	AddTorrentsURLsFirstLastPiecePrioFalse AddTorrentsURLsFirstLastPiecePrio = "false"
	AddTorrentsURLsFirstLastPiecePrioTrue  AddTorrentsURLsFirstLastPiecePrio = "true"
)

// Defines values for AddTorrentsURLsPaused.
const (
	AddTorrentsURLsPausedFalse AddTorrentsURLsPaused = "false"
	AddTorrentsURLsPausedTrue  AddTorrentsURLsPaused = "true"
)

// Defines values for AddTorrentsURLsRootFolder.
const (
	AddTorrentsURLsRootFolderFalse AddTorrentsURLsRootFolder = "false"
	AddTorrentsURLsRootFolderTrue  AddTorrentsURLsRootFolder = "true"
	AddTorrentsURLsRootFolderUnset AddTorrentsURLsRootFolder = "unset"
)

// Defines values for AddTorrentsURLsSequentialDownload.
const (
	AddTorrentsURLsSequentialDownloadFalse AddTorrentsURLsSequentialDownload = "false"
	AddTorrentsURLsSequentialDownloadTrue  AddTorrentsURLsSequentialDownload = "true"
)

// Defines values for AddTorrentsURLsSkipChecking.
const (
	False AddTorrentsURLsSkipChecking = "false"
	True  AddTorrentsURLsSkipChecking = "true"
)

// Defines values for MainLogType.
const (
	MainLogTypeN1 MainLogType = 1
	MainLogTypeN2 MainLogType = 2
	MainLogTypeN4 MainLogType = 4
	MainLogTypeN8 MainLogType = 8
)

// Defines values for PreferencesBittorrentProtocol.
const (
	PreferencesBittorrentProtocolN0 PreferencesBittorrentProtocol = 0
	PreferencesBittorrentProtocolN1 PreferencesBittorrentProtocol = 1
	PreferencesBittorrentProtocolN2 PreferencesBittorrentProtocol = 2
)

// Defines values for PreferencesDyndnsService.
const (
	PreferencesDyndnsServiceN0 PreferencesDyndnsService = 0
	PreferencesDyndnsServiceN1 PreferencesDyndnsService = 1
)

// Defines values for PreferencesEncryption.
const (
	PreferencesEncryptionN0 PreferencesEncryption = 0
	PreferencesEncryptionN1 PreferencesEncryption = 1
	PreferencesEncryptionN2 PreferencesEncryption = 2
)

// Defines values for PreferencesMaxRatioAct.
const (
	PreferencesMaxRatioActN0 PreferencesMaxRatioAct = 0
	PreferencesMaxRatioActN1 PreferencesMaxRatioAct = 1
)

// Defines values for PreferencesProxyType.
const (
	PreferencesProxyTypeMinus1 PreferencesProxyType = -1
	PreferencesProxyTypeN0     PreferencesProxyType = 0
	PreferencesProxyTypeN1     PreferencesProxyType = 1
	PreferencesProxyTypeN2     PreferencesProxyType = 2
	PreferencesProxyTypeN3     PreferencesProxyType = 3
	PreferencesProxyTypeN4     PreferencesProxyType = 4
	PreferencesProxyTypeN5     PreferencesProxyType = 5
)

// Defines values for PreferencesScanDirs0.
const (
	PreferencesScanDirs0N0 PreferencesScanDirs0 = 0
	PreferencesScanDirs0N1 PreferencesScanDirs0 = 1
)

// Defines values for PreferencesSchedulerDays.
const (
	PreferencesSchedulerDaysN0 PreferencesSchedulerDays = 0
	PreferencesSchedulerDaysN1 PreferencesSchedulerDays = 1
	PreferencesSchedulerDaysN2 PreferencesSchedulerDays = 2
	PreferencesSchedulerDaysN3 PreferencesSchedulerDays = 3
	PreferencesSchedulerDaysN4 PreferencesSchedulerDays = 4
	PreferencesSchedulerDaysN5 PreferencesSchedulerDays = 5
	PreferencesSchedulerDaysN6 PreferencesSchedulerDays = 6
	PreferencesSchedulerDaysN7 PreferencesSchedulerDays = 7
	PreferencesSchedulerDaysN8 PreferencesSchedulerDays = 8
	PreferencesSchedulerDaysN9 PreferencesSchedulerDays = 9
)

// Defines values for PreferencesUploadChokingAlgorithm.
const (
	PreferencesUploadChokingAlgorithmN0 PreferencesUploadChokingAlgorithm = 0
	PreferencesUploadChokingAlgorithmN1 PreferencesUploadChokingAlgorithm = 1
	PreferencesUploadChokingAlgorithmN2 PreferencesUploadChokingAlgorithm = 2
)

// Defines values for PreferencesUploadSlotsBehavior.
const (
	PreferencesUploadSlotsBehaviorN0 PreferencesUploadSlotsBehavior = 0
	PreferencesUploadSlotsBehaviorN1 PreferencesUploadSlotsBehavior = 1
)

// Defines values for PreferencesUtpTcpMixedMode.
const (
	PreferencesUtpTcpMixedModeN0 PreferencesUtpTcpMixedMode = 0
	PreferencesUtpTcpMixedModeN1 PreferencesUtpTcpMixedMode = 1
)

// Defines values for SearchJobStatusStatus.
const (
	SearchJobStatusStatusRunning SearchJobStatusStatus = "Running"
	SearchJobStatusStatusStopped SearchJobStatusStatus = "Stopped"
)

// Defines values for SearchResultsStatus.
const (
	SearchResultsStatusRunning SearchResultsStatus = "Running"
	SearchResultsStatusStopped SearchResultsStatus = "Stopped"
)

// Defines values for SetPreferencesBittorrentProtocol.
const (
	SetPreferencesBittorrentProtocolN0 SetPreferencesBittorrentProtocol = 0
	SetPreferencesBittorrentProtocolN1 SetPreferencesBittorrentProtocol = 1
	SetPreferencesBittorrentProtocolN2 SetPreferencesBittorrentProtocol = 2
)

// Defines values for SetPreferencesDyndnsService.
const (
	SetPreferencesDyndnsServiceN0 SetPreferencesDyndnsService = 0
	SetPreferencesDyndnsServiceN1 SetPreferencesDyndnsService = 1
)

// Defines values for SetPreferencesEncryption.
const (
	SetPreferencesEncryptionN0 SetPreferencesEncryption = 0
	SetPreferencesEncryptionN1 SetPreferencesEncryption = 1
	SetPreferencesEncryptionN2 SetPreferencesEncryption = 2
)

// Defines values for SetPreferencesMaxRatioAct.
const (
	SetPreferencesMaxRatioActN0 SetPreferencesMaxRatioAct = 0
	SetPreferencesMaxRatioActN1 SetPreferencesMaxRatioAct = 1
)

// Defines values for SetPreferencesProxyType.
const (
	SetPreferencesProxyTypeMinus1 SetPreferencesProxyType = -1
	SetPreferencesProxyTypeN0     SetPreferencesProxyType = 0
	SetPreferencesProxyTypeN1     SetPreferencesProxyType = 1
	SetPreferencesProxyTypeN2     SetPreferencesProxyType = 2
	SetPreferencesProxyTypeN3     SetPreferencesProxyType = 3
	SetPreferencesProxyTypeN4     SetPreferencesProxyType = 4
	SetPreferencesProxyTypeN5     SetPreferencesProxyType = 5
)

// Defines values for SetPreferencesScanDirs0.
const (
	SetPreferencesScanDirs0N0 SetPreferencesScanDirs0 = 0
	SetPreferencesScanDirs0N1 SetPreferencesScanDirs0 = 1
)

// Defines values for SetPreferencesSchedulerDays.
const (
	SetPreferencesSchedulerDaysN0 SetPreferencesSchedulerDays = 0
	SetPreferencesSchedulerDaysN1 SetPreferencesSchedulerDays = 1
	SetPreferencesSchedulerDaysN2 SetPreferencesSchedulerDays = 2
	SetPreferencesSchedulerDaysN3 SetPreferencesSchedulerDays = 3
	SetPreferencesSchedulerDaysN4 SetPreferencesSchedulerDays = 4
	SetPreferencesSchedulerDaysN5 SetPreferencesSchedulerDays = 5
	SetPreferencesSchedulerDaysN6 SetPreferencesSchedulerDays = 6
	SetPreferencesSchedulerDaysN7 SetPreferencesSchedulerDays = 7
	SetPreferencesSchedulerDaysN8 SetPreferencesSchedulerDays = 8
	SetPreferencesSchedulerDaysN9 SetPreferencesSchedulerDays = 9
)

// Defines values for SetPreferencesUploadChokingAlgorithm.
const (
	SetPreferencesUploadChokingAlgorithmN0 SetPreferencesUploadChokingAlgorithm = 0
	SetPreferencesUploadChokingAlgorithmN1 SetPreferencesUploadChokingAlgorithm = 1
	SetPreferencesUploadChokingAlgorithmN2 SetPreferencesUploadChokingAlgorithm = 2
)

// Defines values for SetPreferencesUploadSlotsBehavior.
const (
	SetPreferencesUploadSlotsBehaviorN0 SetPreferencesUploadSlotsBehavior = 0
	SetPreferencesUploadSlotsBehaviorN1 SetPreferencesUploadSlotsBehavior = 1
)

// Defines values for SetPreferencesUtpTcpMixedMode.
const (
	SetPreferencesUtpTcpMixedModeN0 SetPreferencesUtpTcpMixedMode = 0
	SetPreferencesUtpTcpMixedModeN1 SetPreferencesUtpTcpMixedMode = 1
)

// Defines values for TorrentInfoState.
const (
	TorrentInfoStateAllocating         TorrentInfoState = "allocating"
	TorrentInfoStateCheckingDL         TorrentInfoState = "checkingDL"
	TorrentInfoStateCheckingResumeData TorrentInfoState = "checkingResumeData"
	TorrentInfoStateCheckingUP         TorrentInfoState = "checkingUP"
	TorrentInfoStateDownloading        TorrentInfoState = "downloading"
	TorrentInfoStateError              TorrentInfoState = "error"
	TorrentInfoStateForcedDL           TorrentInfoState = "forcedDL"
	TorrentInfoStateForcedUP           TorrentInfoState = "forcedUP"
	TorrentInfoStateMetaDL             TorrentInfoState = "metaDL"
	TorrentInfoStateMissingFiles       TorrentInfoState = "missingFiles"
	TorrentInfoStateMoving             TorrentInfoState = "moving"
	TorrentInfoStatePausedDL           TorrentInfoState = "pausedDL"
	TorrentInfoStatePausedUP           TorrentInfoState = "pausedUP"
	TorrentInfoStateQueuedDL           TorrentInfoState = "queuedDL"
	TorrentInfoStateQueuedUP           TorrentInfoState = "queuedUP"
	TorrentInfoStateStalledDL          TorrentInfoState = "stalledDL"
	TorrentInfoStateStalledUP          TorrentInfoState = "stalledUP"
	TorrentInfoStateUnknown            TorrentInfoState = "unknown"
	TorrentInfoStateUploading          TorrentInfoState = "uploading"
)

// Defines values for TorrentsFilesPriority.
const (
	TorrentsFilesPriorityN0 TorrentsFilesPriority = 0
	TorrentsFilesPriorityN1 TorrentsFilesPriority = 1
	TorrentsFilesPriorityN6 TorrentsFilesPriority = 6
	TorrentsFilesPriorityN7 TorrentsFilesPriority = 7
)

// Defines values for TorrentsTrackersStatus.
const (
	TorrentsTrackersStatusN0 TorrentsTrackersStatus = 0
	TorrentsTrackersStatusN1 TorrentsTrackersStatus = 1
	TorrentsTrackersStatusN2 TorrentsTrackersStatus = 2
	TorrentsTrackersStatusN3 TorrentsTrackersStatus = 3
	TorrentsTrackersStatusN4 TorrentsTrackersStatus = 4
)

// Defines values for TorrentsFilePrioPostFormdataBodyPriority.
const (
	TorrentsFilePrioPostFormdataBodyPriorityN0 TorrentsFilePrioPostFormdataBodyPriority = 0
	TorrentsFilePrioPostFormdataBodyPriorityN1 TorrentsFilePrioPostFormdataBodyPriority = 1
	TorrentsFilePrioPostFormdataBodyPriorityN6 TorrentsFilePrioPostFormdataBodyPriority = 6
	TorrentsFilePrioPostFormdataBodyPriorityN7 TorrentsFilePrioPostFormdataBodyPriority = 7
)

// Defines values for TorrentsInfoGetParamsFilter.
const (
	TorrentsInfoGetParamsFilterActive             TorrentsInfoGetParamsFilter = "active"
	TorrentsInfoGetParamsFilterAll                TorrentsInfoGetParamsFilter = "all"
	TorrentsInfoGetParamsFilterCompleted          TorrentsInfoGetParamsFilter = "completed"
	TorrentsInfoGetParamsFilterDownloading        TorrentsInfoGetParamsFilter = "downloading"
	TorrentsInfoGetParamsFilterErrored            TorrentsInfoGetParamsFilter = "errored"
	TorrentsInfoGetParamsFilterInactive           TorrentsInfoGetParamsFilter = "inactive"
	TorrentsInfoGetParamsFilterPaused             TorrentsInfoGetParamsFilter = "paused"
	TorrentsInfoGetParamsFilterResumed            TorrentsInfoGetParamsFilter = "resumed"
	TorrentsInfoGetParamsFilterSeeding            TorrentsInfoGetParamsFilter = "seeding"
	TorrentsInfoGetParamsFilterStalled            TorrentsInfoGetParamsFilter = "stalled"
	TorrentsInfoGetParamsFilterStalledDownloading TorrentsInfoGetParamsFilter = "stalled_downloading"
	TorrentsInfoGetParamsFilterStalledUploading   TorrentsInfoGetParamsFilter = "stalled_uploading"
)

// Defines values for TorrentsInfoPostFormdataBodyFilter.
const (
	Active             TorrentsInfoPostFormdataBodyFilter = "active"
	All                TorrentsInfoPostFormdataBodyFilter = "all"
	Completed          TorrentsInfoPostFormdataBodyFilter = "completed"
	Downloading        TorrentsInfoPostFormdataBodyFilter = "downloading"
	Errored            TorrentsInfoPostFormdataBodyFilter = "errored"
	Inactive           TorrentsInfoPostFormdataBodyFilter = "inactive"
	Paused             TorrentsInfoPostFormdataBodyFilter = "paused"
	Resumed            TorrentsInfoPostFormdataBodyFilter = "resumed"
	Seeding            TorrentsInfoPostFormdataBodyFilter = "seeding"
	Stalled            TorrentsInfoPostFormdataBodyFilter = "stalled"
	StalledDownloading TorrentsInfoPostFormdataBodyFilter = "stalled_downloading"
	StalledUploading   TorrentsInfoPostFormdataBodyFilter = "stalled_uploading"
)

// AddTorrentsCommon defines model for AddTorrentsCommon.
type AddTorrentsCommon struct {
	// AutoTMM Whether Automatic Torrent Management should be used
	AutoTMM *bool `json:"autoTMM,omitempty"`

	// Category Category for the torrent
	Category *string `json:"category,omitempty"`

	// Cookie Cookie sent to download the .torrent file
	Cookie *string `json:"cookie,omitempty"`

	// DlLimit Set torrent download speed limit. Unit in bytes/second
	DlLimit *int64 `json:"dlLimit,omitempty"`

	// FirstLastPiecePrio Prioritize download first last piece. Possible values are `true`, `false` (default)
	FirstLastPiecePrio *AddTorrentsCommonFirstLastPiecePrio `json:"firstLastPiecePrio,omitempty"`

	// Paused Add torrents in the paused state. Possible values are `true`, `false` (default)
	Paused *AddTorrentsCommonPaused `json:"paused,omitempty"`

	// RatioLimit Set torrent share ratio limit
	RatioLimit *float32 `json:"ratioLimit,omitempty"`

	// Rename Rename torrent
	Rename *string `json:"rename,omitempty"`

	// RootFolder Create the root folder. Possible values are `true`, `false`, unset (default)
	RootFolder *AddTorrentsCommonRootFolder `json:"root_folder,omitempty"`

	// Savepath Download folder
	Savepath *string `json:"savepath,omitempty"`

	// SeedingTimeLimit Set torrent seeding time limit. Unit in seconds
	SeedingTimeLimit *int64 `json:"seedingTimeLimit,omitempty"`

	// SequentialDownload Enable sequential download. Possible values are `true`, `false` (default)
	SequentialDownload *AddTorrentsCommonSequentialDownload `json:"sequentialDownload,omitempty"`

	// SkipChecking Skip hash checking. Possible values are `true`, `false` (default)
	SkipChecking *AddTorrentsCommonSkipChecking `json:"skip_checking,omitempty"`

	// Tags Tags for the torrent, split by ','
	Tags *[]string `json:"tags,omitempty"`

	// UpLimit Set torrent upload speed limit. Unit in bytes/second
	UpLimit *int64 `json:"upLimit,omitempty"`
}

// AddTorrentsCommonFirstLastPiecePrio Prioritize download first last piece. Possible values are `true`, `false` (default)
type AddTorrentsCommonFirstLastPiecePrio string

// AddTorrentsCommonPaused Add torrents in the paused state. Possible values are `true`, `false` (default)
type AddTorrentsCommonPaused string

// AddTorrentsCommonRootFolder Create the root folder. Possible values are `true`, `false`, unset (default)
type AddTorrentsCommonRootFolder string

// AddTorrentsCommonSequentialDownload Enable sequential download. Possible values are `true`, `false` (default)
type AddTorrentsCommonSequentialDownload string

// AddTorrentsCommonSkipChecking Skip hash checking. Possible values are `true`, `false` (default)
type AddTorrentsCommonSkipChecking string

// AddTorrentsFiles defines model for AddTorrentsFiles.
type AddTorrentsFiles struct {
	// AutoTMM Whether Automatic Torrent Management should be used
	AutoTMM *bool `json:"autoTMM,omitempty"`

	// Category Category for the torrent
	Category *string `json:"category,omitempty"`

	// Cookie Cookie sent to download the .torrent file
	Cookie *string `json:"cookie,omitempty"`

	// DlLimit Set torrent download speed limit. Unit in bytes/second
	DlLimit *int64 `json:"dlLimit,omitempty"`

	// FirstLastPiecePrio Prioritize download first last piece. Possible values are `true`, `false` (default)
	FirstLastPiecePrio *AddTorrentsFilesFirstLastPiecePrio `json:"firstLastPiecePrio,omitempty"`

	// Paused Add torrents in the paused state. Possible values are `true`, `false` (default)
	Paused *AddTorrentsFilesPaused `json:"paused,omitempty"`

	// RatioLimit Set torrent share ratio limit
	RatioLimit *float32 `json:"ratioLimit,omitempty"`

	// Rename Rename torrent
	Rename *string `json:"rename,omitempty"`

	// RootFolder Create the root folder. Possible values are `true`, `false`, unset (default)
	RootFolder *AddTorrentsFilesRootFolder `json:"root_folder,omitempty"`

	// Savepath Download folder
	Savepath *string `json:"savepath,omitempty"`

	// SeedingTimeLimit Set torrent seeding time limit. Unit in seconds
	SeedingTimeLimit *int64 `json:"seedingTimeLimit,omitempty"`

	// SequentialDownload Enable sequential download. Possible values are `true`, `false` (default)
	SequentialDownload *AddTorrentsFilesSequentialDownload `json:"sequentialDownload,omitempty"`

	// SkipChecking Skip hash checking. Possible values are `true`, `false` (default)
	SkipChecking *AddTorrentsFilesSkipChecking `json:"skip_checking,omitempty"`

	// Tags Tags for the torrent, split by ','
	Tags *[]string `json:"tags,omitempty"`

	// Torrents Raw data of torrent file. `torrents` can be presented multiple times.
	Torrents *[]openapi_types.File `json:"torrents,omitempty"`

	// UpLimit Set torrent upload speed limit. Unit in bytes/second
	UpLimit *int64 `json:"upLimit,omitempty"`
}

// AddTorrentsFilesFirstLastPiecePrio Prioritize download first last piece. Possible values are `true`, `false` (default)
type AddTorrentsFilesFirstLastPiecePrio string

// AddTorrentsFilesPaused Add torrents in the paused state. Possible values are `true`, `false` (default)
type AddTorrentsFilesPaused string

// AddTorrentsFilesRootFolder Create the root folder. Possible values are `true`, `false`, unset (default)
type AddTorrentsFilesRootFolder string

// AddTorrentsFilesSequentialDownload Enable sequential download. Possible values are `true`, `false` (default)
type AddTorrentsFilesSequentialDownload string

// AddTorrentsFilesSkipChecking Skip hash checking. Possible values are `true`, `false` (default)
type AddTorrentsFilesSkipChecking string

// AddTorrentsURLs defines model for AddTorrentsURLs.
type AddTorrentsURLs struct {
	// AutoTMM Whether Automatic Torrent Management should be used
	AutoTMM *bool `json:"autoTMM,omitempty"`

	// Category Category for the torrent
	Category *string `json:"category,omitempty"`

	// Cookie Cookie sent to download the .torrent file
	Cookie *string `json:"cookie,omitempty"`

	// DlLimit Set torrent download speed limit. Unit in bytes/second
	DlLimit *int64 `json:"dlLimit,omitempty"`

	// FirstLastPiecePrio Prioritize download first last piece. Possible values are `true`, `false` (default)
	FirstLastPiecePrio *AddTorrentsURLsFirstLastPiecePrio `json:"firstLastPiecePrio,omitempty"`

	// Paused Add torrents in the paused state. Possible values are `true`, `false` (default)
	Paused *AddTorrentsURLsPaused `json:"paused,omitempty"`

	// RatioLimit Set torrent share ratio limit
	RatioLimit *float32 `json:"ratioLimit,omitempty"`

	// Rename Rename torrent
	Rename *string `json:"rename,omitempty"`

	// RootFolder Create the root folder. Possible values are `true`, `false`, unset (default)
	RootFolder *AddTorrentsURLsRootFolder `json:"root_folder,omitempty"`

	// Savepath Download folder
	Savepath *string `json:"savepath,omitempty"`

	// SeedingTimeLimit Set torrent seeding time limit. Unit in seconds
	SeedingTimeLimit *int64 `json:"seedingTimeLimit,omitempty"`

	// SequentialDownload Enable sequential download. Possible values are `true`, `false` (default)
	SequentialDownload *AddTorrentsURLsSequentialDownload `json:"sequentialDownload,omitempty"`

	// SkipChecking Skip hash checking. Possible values are `true`, `false` (default)
	SkipChecking *AddTorrentsURLsSkipChecking `json:"skip_checking,omitempty"`

	// Tags Tags for the torrent, split by ','
	Tags *[]string `json:"tags,omitempty"`

	// UpLimit Set torrent upload speed limit. Unit in bytes/second
	UpLimit *int64 `json:"upLimit,omitempty"`

	// Urls URLs separated with newlines
	Urls *string `json:"urls,omitempty"`
}

// AddTorrentsURLsFirstLastPiecePrio Prioritize download first last piece. Possible values are `true`, `false` (default)
type AddTorrentsURLsFirstLastPiecePrio string

// AddTorrentsURLsPaused Add torrents in the paused state. Possible values are `true`, `false` (default)
type AddTorrentsURLsPaused string

// AddTorrentsURLsRootFolder Create the root folder. Possible values are `true`, `false`, unset (default)
type AddTorrentsURLsRootFolder string

// AddTorrentsURLsSequentialDownload Enable sequential download. Possible values are `true`, `false` (default)
type AddTorrentsURLsSequentialDownload string

// AddTorrentsURLsSkipChecking Skip hash checking. Possible values are `true`, `false` (default)
type AddTorrentsURLsSkipChecking string

// BuildInfo The response is a JSON object containing the following fields
type BuildInfo struct {
	Bitness    *int32  `json:"bitness,omitempty"`
	Boost      *string `json:"boost,omitempty"`
	Libtorrent *string `json:"libtorrent,omitempty"`
	Openssl    *string `json:"openssl,omitempty"`
	Qt         *string `json:"qt,omitempty"`
}

// Category defines model for Category.
type Category struct {
	Category string `json:"category"`
	SavePath string `json:"savePath"`
}

// Hashes defines model for Hashes.
type Hashes struct {
	Hashes []string `json:"hashes"`
}

// MainData The response is a JSON object with the following possible fields
type MainData struct {
	// Categories Info for categories added since last request
	Categories *map[string]TorrentsCategory `json:"categories,omitempty"`

	// CategoriesRemoved List of categories removed since last request
	CategoriesRemoved *[]string `json:"categories_removed,omitempty"`

	// FullUpdate Whether the response contains all the data or partial data
	FullUpdate *bool `json:"full_update,omitempty"`

	// Rid Response ID
	Rid *int64 `json:"rid,omitempty"`

	// ServerState The response is a JSON object with the following fields
	//
	// In addition to the above in partial data requests (see [Get partial data](https://github.com/qbittorrent/qBittorrent/wiki/WebUI-API-(qBittorrent-4.1)#get-partial-data) for more info):
	ServerState *TransferInfo `json:"server_state,omitempty"`

	// Tags List of tags added since last request
	Tags *[]string `json:"tags,omitempty"`

	// TagsRemoved List of tags removed since last request
	TagsRemoved *[]string `json:"tags_removed,omitempty"`

	// Torrents Property: torrent hash, value: same as [torrent list](https://github.com/qbittorrent/qBittorrent/wiki/WebUI-API-(qBittorrent-4.1)#get-torrent-list)
	Torrents *map[string]TorrentInfo `json:"torrents,omitempty"`

	// TorrentsRemoved List of hashes of torrents removed since last request
	TorrentsRemoved *[]string `json:"torrents_removed,omitempty"`
}

// MainLog defines model for MainLog.
type MainLog struct {
	// Id ID of the message
	Id *int64 `json:"id,omitempty"`

	// Message Text of the message
	Message *string `json:"message,omitempty"`

	// Timestamp Milliseconds since epoch
	Timestamp *int64 `json:"timestamp,omitempty"`

	// Type Type of the message: Log::NORMAL: `1`, Log::INFO: `2`, Log::WARNING: `4`, Log::CRITICAL: `8`
	Type *MainLogType `json:"type,omitempty"`
}

// MainLogType Type of the message: Log::NORMAL: `1`, Log::INFO: `2`, Log::WARNING: `4`, Log::CRITICAL: `8`
type MainLogType int32

// PeersLog defines model for PeersLog.
type PeersLog struct {
	// Blocked Whether or not the peer was blocked
	Blocked *bool `json:"blocked,omitempty"`

	// Id ID of the peer
	Id *int64 `json:"id,omitempty"`

	// Ip IP of the peer
	Ip *string `json:"ip,omitempty"`

	// Reason Reason of the block
	Reason *string `json:"reason,omitempty"`

	// Timestamp Milliseconds since epoch
	Timestamp *int64 `json:"timestamp,omitempty"`
}

// Preferences Possible fields:
type Preferences struct {
	// AddTrackers List of trackers to add to new torrent
	AddTrackers *string `json:"add_trackers,omitempty"`

	// AddTrackersEnabled Enable automatic adding of trackers to new torrents
	AddTrackersEnabled *bool `json:"add_trackers_enabled,omitempty"`

	// AltDlLimit Alternative global download speed limit in KiB/s
	AltDlLimit *int64 `json:"alt_dl_limit,omitempty"`

	// AltUpLimit Alternative global upload speed limit in KiB/s
	AltUpLimit *int64 `json:"alt_up_limit,omitempty"`

	// AlternativeWebuiEnabled True if an alternative WebUI should be used
	AlternativeWebuiEnabled *bool `json:"alternative_webui_enabled,omitempty"`

	// AlternativeWebuiPath File path to the alternative WebUI
	AlternativeWebuiPath *string `json:"alternative_webui_path,omitempty"`

	// AnnounceIp TODO
	AnnounceIp *string `json:"announce_ip,omitempty"`

	// AnnounceToAllTiers True always announce to all tiers
	AnnounceToAllTiers *bool `json:"announce_to_all_tiers,omitempty"`

	// AnnounceToAllTrackers True always announce to all trackers in a tier
	AnnounceToAllTrackers *bool `json:"announce_to_all_trackers,omitempty"`

	// AnonymousMode If true anonymous mode will be enabled; read more [here](https://github.com/qbittorrent/qBittorrent/wiki/Anonymous-Mode); this option is only available in qBittorent built against libtorrent version 0.16.X and higher
	AnonymousMode *bool `json:"anonymous_mode,omitempty"`

	// AsyncIoThreads Number of asynchronous I/O threads
	AsyncIoThreads *int64 `json:"async_io_threads,omitempty"`

	// AutoDeleteMode TODO
	AutoDeleteMode *int `json:"auto_delete_mode,omitempty"`

	// AutoTmmEnabled True if Automatic Torrent Management is enabled by default
	AutoTmmEnabled *bool `json:"auto_tmm_enabled,omitempty"`

	// AutorunEnabled True if external program should be run after torrent has finished downloading
	AutorunEnabled *bool `json:"autorun_enabled,omitempty"`

	// AutorunProgram Program path/name/arguments to run if `autorun_enabled` is enabled; path is separated by slashes; you can use `%f` and `%n` arguments, which will be expanded by qBittorent as path_to_torrent_file and torrent_name (from the GUI; not the .torrent file name) respectively
	AutorunProgram *string `json:"autorun_program,omitempty"`

	// BannedIPs List of banned IPs
	BannedIPs *string `json:"banned_IPs,omitempty"`

	// BittorrentProtocol Bittorrent Protocol to use (see list of possible values below)
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | 0     | TCP and μTP |
	// | 1     | TCP         |
	// | 2     | μTP         |
	BittorrentProtocol *PreferencesBittorrentProtocol `json:"bittorrent_protocol,omitempty"`

	// BypassAuthSubnetWhitelist (White)list of ipv4/ipv6 subnets for which webui authentication should be bypassed; list entries are separated by commas
	BypassAuthSubnetWhitelist *[]string `json:"bypass_auth_subnet_whitelist,omitempty"`

	// BypassAuthSubnetWhitelistEnabled True if webui authentication should be bypassed for clients whose ip resides within (at least) one of the subnets on the whitelist
	BypassAuthSubnetWhitelistEnabled *bool `json:"bypass_auth_subnet_whitelist_enabled,omitempty"`

	// BypassLocalAuth True if authentication challenge for loopback address (127.0.0.1) should be disabled
	BypassLocalAuth *bool `json:"bypass_local_auth,omitempty"`

	// CategoryChangedTmmEnabled True if torrent should be relocated when its Category's save path changes
	CategoryChangedTmmEnabled *bool `json:"category_changed_tmm_enabled,omitempty"`

	// CheckingMemoryUse Outstanding memory when checking torrents in MiB
	CheckingMemoryUse *int64 `json:"checking_memory_use,omitempty"`

	// CreateSubfolderEnabled True if a subfolder should be created when adding a torrent
	CreateSubfolderEnabled *bool `json:"create_subfolder_enabled,omitempty"`

	// CurrentInterfaceAddress IP Address to bind to. Empty String means All addresses
	CurrentInterfaceAddress *string `json:"current_interface_address,omitempty"`

	// CurrentNetworkInterface Network Interface used
	CurrentNetworkInterface *string `json:"current_network_interface,omitempty"`

	// Dht True if DHT is enabled
	Dht *bool `json:"dht,omitempty"`

	// DiskCache Disk cache used in MiB
	DiskCache *int64 `json:"disk_cache,omitempty"`

	// DiskCacheTtl Disk cache expiry interval in seconds
	DiskCacheTtl *int64 `json:"disk_cache_ttl,omitempty"`

	// DlLimit Global download speed limit in KiB/s; `-1` means no limit is applied
	DlLimit *int64 `json:"dl_limit,omitempty"`

	// DontCountSlowTorrents If true torrents w/o any activity (stalled ones) will not be counted towards `max_active_*` limits; see [dont_count_slow_torrents](https://www.libtorrent.org/reference-Settings.html#dont_count_slow_torrents) for more information
	DontCountSlowTorrents *bool `json:"dont_count_slow_torrents,omitempty"`

	// DyndnsDomain Your DDNS domain name
	DyndnsDomain *string `json:"dyndns_domain,omitempty"`

	// DyndnsEnabled True if server DNS should be updated dynamically
	DyndnsEnabled *bool `json:"dyndns_enabled,omitempty"`

	// DyndnsPassword Password for DDNS service
	DyndnsPassword *string `json:"dyndns_password,omitempty"`

	// DyndnsService See list of possible values here below
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | 0     | Use DyDNS   |
	// | 1     | Use NOIP    |
	DyndnsService *PreferencesDyndnsService `json:"dyndns_service,omitempty"`

	// DyndnsUsername Username for DDNS service
	DyndnsUsername *string `json:"dyndns_username,omitempty"`

	// EmbeddedTrackerPort Port used for embedded tracker
	EmbeddedTrackerPort *int32 `json:"embedded_tracker_port,omitempty"`

	// EnableCoalesceReadWrite True enables coalesce reads & writes
	EnableCoalesceReadWrite *bool `json:"enable_coalesce_read_write,omitempty"`

	// EnableEmbeddedTracker True enables embedded tracker
	EnableEmbeddedTracker *bool `json:"enable_embedded_tracker,omitempty"`

	// EnableMultiConnectionsFromSameIp True allows multiple connections from the same IP address
	EnableMultiConnectionsFromSameIp *bool `json:"enable_multi_connections_from_same_ip,omitempty"`

	// EnableOsCache True enables os cache
	EnableOsCache *bool `json:"enable_os_cache,omitempty"`

	// EnablePieceExtentAffinity True if the advanced libtorrent option `piece_extent_affinity` is enabled
	EnablePieceExtentAffinity *bool `json:"enable_piece_extent_affinity,omitempty"`

	// EnableUploadSuggestions True enables sending of upload piece suggestions
	EnableUploadSuggestions *bool `json:"enable_upload_suggestions,omitempty"`

	// Encryption See list of possible values here below
	//
	// | Value | Description          |
	// | ----- | -------------------- |
	// | 0     | Prefer encryption    |
	// | 1     | Force encryption on  |
	// | 2     | Force encryption off |
	Encryption *PreferencesEncryption `json:"encryption,omitempty"`

	// ExportDir Path to directory to copy .torrent files to. Slashes are used as path separators
	ExportDir *string `json:"export_dir,omitempty"`

	// ExportDirFin Path to directory to copy .torrent files of completed downloads to. Slashes are used as path separators
	ExportDirFin *string `json:"export_dir_fin,omitempty"`

	// FilePoolSize File pool size
	FilePoolSize *int64 `json:"file_pool_size,omitempty"`

	// IncompleteFilesExt True if ".!qB" should be appended to incomplete files
	IncompleteFilesExt *bool `json:"incomplete_files_ext,omitempty"`

	// IpFilterEnabled True if external IP filter should be enabled
	IpFilterEnabled *bool `json:"ip_filter_enabled,omitempty"`

	// IpFilterPath Path to IP filter file (.dat, .p2p, .p2b files are supported); path is separated by slashes
	IpFilterPath *string `json:"ip_filter_path,omitempty"`

	// IpFilterTrackers True if IP filters are applied to trackers
	IpFilterTrackers *bool `json:"ip_filter_trackers,omitempty"`

	// LimitLanPeers True if `[du]l_limit` should be applied to peers on the LAN
	LimitLanPeers *bool `json:"limit_lan_peers,omitempty"`

	// LimitTcpOverhead True if `[du]l_limit` should be applied to estimated TCP overhead (service data: e.g. packet headers)
	LimitTcpOverhead *bool `json:"limit_tcp_overhead,omitempty"`

	// LimitUtpRate True if `[du]l_limit` should be applied to uTP connections; this option is only available in qBittorent built against libtorrent version 0.16.X and higher
	LimitUtpRate *bool `json:"limit_utp_rate,omitempty"`

	// ListenPort Port for incoming connections
	ListenPort *int32 `json:"listen_port,omitempty"`

	// Locale Currently selected language (e.g. en_GB for English)
	Locale *string `json:"locale,omitempty"`

	// Lsd True if LSD is enabled
	Lsd *bool `json:"lsd,omitempty"`

	// MailNotificationAuthEnabled True if smtp server requires authentication
	MailNotificationAuthEnabled *bool `json:"mail_notification_auth_enabled,omitempty"`

	// MailNotificationEmail e-mail to send notifications to
	MailNotificationEmail *string `json:"mail_notification_email,omitempty"`

	// MailNotificationEnabled True if e-mail notification should be enabled
	MailNotificationEnabled *bool `json:"mail_notification_enabled,omitempty"`

	// MailNotificationPassword Password for smtp authentication
	MailNotificationPassword *string `json:"mail_notification_password,omitempty"`

	// MailNotificationSender e-mail where notifications should originate from
	MailNotificationSender *string `json:"mail_notification_sender,omitempty"`

	// MailNotificationSmtp smtp server for e-mail notifications
	MailNotificationSmtp *string `json:"mail_notification_smtp,omitempty"`

	// MailNotificationSslEnabled True if smtp server requires SSL connection
	MailNotificationSslEnabled *bool `json:"mail_notification_ssl_enabled,omitempty"`

	// MailNotificationUsername Username for smtp authentication
	MailNotificationUsername *string `json:"mail_notification_username,omitempty"`

	// MaxActiveDownloads Maximum number of active simultaneous downloads
	MaxActiveDownloads *int64 `json:"max_active_downloads,omitempty"`

	// MaxActiveTorrents Maximum number of active simultaneous downloads and uploads
	MaxActiveTorrents *int64 `json:"max_active_torrents,omitempty"`

	// MaxActiveUploads Maximum number of active simultaneous uploads
	MaxActiveUploads *int64 `json:"max_active_uploads,omitempty"`

	// MaxConnec Maximum global number of simultaneous connections
	MaxConnec *int64 `json:"max_connec,omitempty"`

	// MaxConnecPerTorrent Maximum number of simultaneous connections per torrent
	MaxConnecPerTorrent *int64 `json:"max_connec_per_torrent,omitempty"`

	// MaxRatio Get the global share ratio limit
	MaxRatio *float32 `json:"max_ratio,omitempty"`

	// MaxRatioAct Action performed when a torrent reaches the maximum share ratio. See list of possible values here below.
	//
	// | Value | Description    |
	// | ----- | -------------- |
	// | 0     | Pause torrent  |
	// | 1     | Remove torrent |
	MaxRatioAct *PreferencesMaxRatioAct `json:"max_ratio_act,omitempty"`

	// MaxRatioEnabled True if share ratio limit is enabled
	MaxRatioEnabled *bool `json:"max_ratio_enabled,omitempty"`

	// MaxSeedingTime Number of minutes to seed a torrent
	MaxSeedingTime *int64 `json:"max_seeding_time,omitempty"`

	// MaxSeedingTimeEnabled True enables max seeding time
	MaxSeedingTimeEnabled *bool `json:"max_seeding_time_enabled,omitempty"`

	// MaxUploads Maximum number of upload slots
	MaxUploads *int64 `json:"max_uploads,omitempty"`

	// MaxUploadsPerTorrent Maximum number of upload slots per torrent
	MaxUploadsPerTorrent *int64 `json:"max_uploads_per_torrent,omitempty"`

	// OutgoingPortsMax Maximal outgoing port (0: Disabled)
	OutgoingPortsMax *int32 `json:"outgoing_ports_max,omitempty"`

	// OutgoingPortsMin Minimal outgoing port (0: Disabled)
	OutgoingPortsMin *int32 `json:"outgoing_ports_min,omitempty"`

	// Pex True if PeX is enabled
	Pex *bool `json:"pex,omitempty"`

	// PreallocateAll True if disk space should be pre-allocated for all files
	PreallocateAll *bool `json:"preallocate_all,omitempty"`

	// ProxyAuthEnabled True proxy requires authentication; doesn't apply to SOCKS4 proxies
	ProxyAuthEnabled *bool `json:"proxy_auth_enabled,omitempty"`

	// ProxyIp Proxy IP address or domain name
	ProxyIp *string `json:"proxy_ip,omitempty"`

	// ProxyPassword Password for proxy authentication
	ProxyPassword *string `json:"proxy_password,omitempty"`

	// ProxyPeerConnections True if peer and web seed connections should be proxified; this option will have any effect only in qBittorent built against libtorrent version 0.16.X and higher
	ProxyPeerConnections *bool `json:"proxy_peer_connections,omitempty"`

	// ProxyPort Proxy port
	ProxyPort *int32 `json:"proxy_port,omitempty"`

	// ProxyTorrentsOnly True if proxy is only used for torrents
	ProxyTorrentsOnly *bool `json:"proxy_torrents_only,omitempty"`

	// ProxyType See list of possible values here below
	//
	// | Value | Description                         |
	// | ----- | ----------------------------------- |
	// | -1    | Proxy is disabled                   |
	// | 0     | Prefer encryption                   |
	// | 1     | HTTP proxy without authentication   |
	// | 2     | SOCKS5 proxy without authentication |
	// | 3     | HTTP proxy with authentication      |
	// | 4     | SOCKS5 proxy with authentication    |
	// | 5     | SOCKS4 proxy without authentication |
	ProxyType *PreferencesProxyType `json:"proxy_type,omitempty"`

	// ProxyUsername Username for proxy authentication
	ProxyUsername *string `json:"proxy_username,omitempty"`

	// QueueingEnabled True if torrent queuing is enabled
	QueueingEnabled *bool `json:"queueing_enabled,omitempty"`

	// RandomPort True if the port is randomly selected
	RandomPort *bool `json:"random_port,omitempty"`

	// RecheckCompletedTorrents True rechecks torrents on completion
	RecheckCompletedTorrents *bool `json:"recheck_completed_torrents,omitempty"`

	// ResolvePeerCountries True resolves peer countries
	ResolvePeerCountries *bool `json:"resolve_peer_countries,omitempty"`

	// RssAutoDownloadingEnabled Enable auto-downloading of torrents from the RSS feeds
	RssAutoDownloadingEnabled *bool `json:"rss_auto_downloading_enabled,omitempty"`

	// RssDownloadRepackProperEpisodes For API ≥ v2.5.1: Enable downloading of repack/proper Episodes
	RssDownloadRepackProperEpisodes *bool `json:"rss_download_repack_proper_episodes,omitempty"`

	// RssMaxArticlesPerFeed Max stored articles per RSS feed
	RssMaxArticlesPerFeed *int64 `json:"rss_max_articles_per_feed,omitempty"`

	// RssProcessingEnabled Enable processing of RSS feeds
	RssProcessingEnabled *bool `json:"rss_processing_enabled,omitempty"`

	// RssRefreshInterval RSS refresh interval
	RssRefreshInterval *int64 `json:"rss_refresh_interval,omitempty"`

	// RssSmartEpisodeFilters For API ≥ v2.5.1: List of RSS Smart Episode Filters
	RssSmartEpisodeFilters *string `json:"rss_smart_episode_filters,omitempty"`

	// SavePath Default save path for torrents, separated by slashes
	SavePath *string `json:"save_path,omitempty"`

	// SavePathChangedTmmEnabled True if torrent should be relocated when the default save path changes
	SavePathChangedTmmEnabled *bool `json:"save_path_changed_tmm_enabled,omitempty"`

	// SaveResumeDataInterval Save resume data interval in min
	SaveResumeDataInterval *int64 `json:"save_resume_data_interval,omitempty"`

	// ScanDirs Property: directory to watch for torrent files, value: where torrents loaded from this directory should be downloaded to (see list of possible values below). Slashes are used as path separators; multiple key/value pairs can be specified
	//
	// | Value                  | Description                       |
	// | ---------------------- | --------------------------------- |
	// | 0                      | Download to the monitored folder  |
	// | 1                      | Download to the default save path |
	// | "/path/to/download/to" | Download to this path             |
	ScanDirs *map[string]Preferences_ScanDirs_AdditionalProperties `json:"scan_dirs,omitempty"`

	// ScheduleFromHour Scheduler starting hour
	ScheduleFromHour *int32 `json:"schedule_from_hour,omitempty"`

	// ScheduleFromMin Scheduler starting minute
	ScheduleFromMin *int32 `json:"schedule_from_min,omitempty"`

	// ScheduleToHour Scheduler ending hour
	ScheduleToHour *int32 `json:"schedule_to_hour,omitempty"`

	// ScheduleToMin Scheduler ending minute
	ScheduleToMin *int32 `json:"schedule_to_min,omitempty"`

	// SchedulerDays Scheduler days. See possible values here below
	//
	// | Value | Description     |
	// | ----- | --------------- |
	// | 0     | Every day       |
	// | 1     | Every weekday   |
	// | 2     | Every weekend   |
	// | 3     | Every Monday    |
	// | 4     | Every Tuesday   |
	// | 5     | Every Wednesday |
	// | 6     | Every Thursday  |
	// | 7     | Every Friday    |
	// | 8     | Every Saturday  |
	// | 9     | Every Sunday    |
	SchedulerDays *PreferencesSchedulerDays `json:"scheduler_days,omitempty"`

	// SchedulerEnabled True if alternative limits should be applied according to schedule
	SchedulerEnabled *bool `json:"scheduler_enabled,omitempty"`

	// SendBufferLowWatermark Send buffer low watermark in KiB
	SendBufferLowWatermark *int64 `json:"send_buffer_low_watermark,omitempty"`

	// SendBufferWatermark Send buffer watermark in KiB
	SendBufferWatermark *int64 `json:"send_buffer_watermark,omitempty"`

	// SendBufferWatermarkFactor Send buffer watermark factor in percent
	SendBufferWatermarkFactor *int32 `json:"send_buffer_watermark_factor,omitempty"`

	// SlowTorrentDlRateThreshold Download rate in KiB/s for a torrent to be considered "slow"
	SlowTorrentDlRateThreshold *int64 `json:"slow_torrent_dl_rate_threshold,omitempty"`

	// SlowTorrentInactiveTimer Seconds a torrent should be inactive before considered "slow"
	SlowTorrentInactiveTimer *int64 `json:"slow_torrent_inactive_timer,omitempty"`

	// SlowTorrentUlRateThreshold Upload rate in KiB/s for a torrent to be considered "slow"
	SlowTorrentUlRateThreshold *int64 `json:"slow_torrent_ul_rate_threshold,omitempty"`

	// SocketBacklogSize Socket backlog size
	SocketBacklogSize *int64 `json:"socket_backlog_size,omitempty"`

	// SslCert For API < v2.0.1: SSL certificate contents (this is a not a path)
	SslCert *string `json:"ssl_cert,omitempty"`

	// SslKey For API < v2.0.1: SSL keyfile contents (this is a not a path)
	SslKey *string `json:"ssl_key,omitempty"`

	// StartPausedEnabled True if torrents should be added in a Paused state
	StartPausedEnabled *bool `json:"start_paused_enabled,omitempty"`

	// StopTrackerTimeout Timeout in seconds for a `stopped` announce request to trackers
	StopTrackerTimeout *int64 `json:"stop_tracker_timeout,omitempty"`

	// TempPath Path for incomplete torrents, separated by slashes
	TempPath *string `json:"temp_path,omitempty"`

	// TempPathEnabled True if folder for incomplete torrents is enabled
	TempPathEnabled *bool `json:"temp_path_enabled,omitempty"`

	// TorrentChangedTmmEnabled True if torrent should be relocated when its Category changes
	TorrentChangedTmmEnabled *bool `json:"torrent_changed_tmm_enabled,omitempty"`

	// UpLimit Global upload speed limit in KiB/s; `-1` means no limit is applied
	UpLimit *int64 `json:"up_limit,omitempty"`

	// UploadChokingAlgorithm Upload choking algorithm used (see list of possible values below)
	//
	// | Value | Description    |
	// | ----- | -------------- |
	// | 0     | Round-robin    |
	// | 1     | Fastest upload |
	// | 2     | Anti-leech     |
	UploadChokingAlgorithm *PreferencesUploadChokingAlgorithm `json:"upload_choking_algorithm,omitempty"`

	// UploadSlotsBehavior Upload slots behavior used (see list of possible values below)
	//
	// | Value | Description       |
	// | ----- | ----------------- |
	// | 0     | Fixed slots       |
	// | 1     | Upload rate based |
	UploadSlotsBehavior *PreferencesUploadSlotsBehavior `json:"upload_slots_behavior,omitempty"`

	// Upnp True if UPnP/NAT-PMP is enabled
	Upnp *bool `json:"upnp,omitempty"`

	// UpnpLeaseDuration UPnP lease duration (0: Permanent lease)
	UpnpLeaseDuration *int64 `json:"upnp_lease_duration,omitempty"`

	// UseHttps True if WebUI HTTPS access is enabled
	UseHttps *bool `json:"use_https,omitempty"`

	// UtpTcpMixedMode μTP-TCP mixed mode algorithm (see list of possible values below)
	//
	// | Value | Description       |
	// | ----- | ----------------- |
	// | 0     | Prefer TCP        |
	// | 1     | Peer proportional |
	UtpTcpMixedMode *PreferencesUtpTcpMixedMode `json:"utp_tcp_mixed_mode,omitempty"`

	// WebUiAddress IP address to use for the WebUI
	WebUiAddress *string `json:"web_ui_address,omitempty"`

	// WebUiBanDuration WebUI access ban duration in seconds
	WebUiBanDuration *int64 `json:"web_ui_ban_duration,omitempty"`

	// WebUiClickjackingProtectionEnabled True if WebUI clickjacking protection is enabled
	WebUiClickjackingProtectionEnabled *bool `json:"web_ui_clickjacking_protection_enabled,omitempty"`

	// WebUiCsrfProtectionEnabled True if WebUI CSRF protection is enabled
	WebUiCsrfProtectionEnabled *bool `json:"web_ui_csrf_protection_enabled,omitempty"`

	// WebUiCustomHttpHeaders For API ≥ v2.5.1: List of custom http headers
	WebUiCustomHttpHeaders *string `json:"web_ui_custom_http_headers,omitempty"`

	// WebUiDomainList Comma-separated list of domains to accept when performing Host header validation
	WebUiDomainList *[]string `json:"web_ui_domain_list,omitempty"`

	// WebUiHostHeaderValidationEnabled True if WebUI host header validation is enabled
	WebUiHostHeaderValidationEnabled *bool `json:"web_ui_host_header_validation_enabled,omitempty"`

	// WebUiHttpsCertPath For API ≥ v2.0.1: Path to SSL certificate
	WebUiHttpsCertPath *string `json:"web_ui_https_cert_path,omitempty"`

	// WebUiHttpsKeyPath For API ≥ v2.0.1: Path to SSL keyfile
	WebUiHttpsKeyPath *string `json:"web_ui_https_key_path,omitempty"`

	// WebUiMaxAuthFailCount Maximum number of authentication failures before WebUI access ban
	WebUiMaxAuthFailCount *int64 `json:"web_ui_max_auth_fail_count,omitempty"`

	// WebUiPort WebUI port
	WebUiPort *int32 `json:"web_ui_port,omitempty"`

	// WebUiSecureCookieEnabled True if WebUI cookie `Secure` flag is enabled
	WebUiSecureCookieEnabled *bool `json:"web_ui_secure_cookie_enabled,omitempty"`

	// WebUiSessionTimeout Seconds until WebUI is automatically signed off
	WebUiSessionTimeout *int64 `json:"web_ui_session_timeout,omitempty"`

	// WebUiUpnp True if UPnP is used for the WebUI port
	WebUiUpnp *bool `json:"web_ui_upnp,omitempty"`

	// WebUiUseCustomHttpHeadersEnabled For API ≥ v2.5.1: Enable custom http headers
	WebUiUseCustomHttpHeadersEnabled *bool `json:"web_ui_use_custom_http_headers_enabled,omitempty"`

	// WebUiUsername WebUI username
	WebUiUsername        *string                `json:"web_ui_username,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PreferencesBittorrentProtocol Bittorrent Protocol to use (see list of possible values below)
//
// | Value | Description |
// | ----- | ----------- |
// | 0     | TCP and μTP |
// | 1     | TCP         |
// | 2     | μTP         |
type PreferencesBittorrentProtocol int32

// PreferencesDyndnsService See list of possible values here below
//
// | Value | Description |
// | ----- | ----------- |
// | 0     | Use DyDNS   |
// | 1     | Use NOIP    |
type PreferencesDyndnsService int32

// PreferencesEncryption See list of possible values here below
//
// | Value | Description          |
// | ----- | -------------------- |
// | 0     | Prefer encryption    |
// | 1     | Force encryption on  |
// | 2     | Force encryption off |
type PreferencesEncryption int32

// PreferencesMaxRatioAct Action performed when a torrent reaches the maximum share ratio. See list of possible values here below.
//
// | Value | Description    |
// | ----- | -------------- |
// | 0     | Pause torrent  |
// | 1     | Remove torrent |
type PreferencesMaxRatioAct int64

// PreferencesProxyType See list of possible values here below
//
// | Value | Description                         |
// | ----- | ----------------------------------- |
// | -1    | Proxy is disabled                   |
// | 0     | Prefer encryption                   |
// | 1     | HTTP proxy without authentication   |
// | 2     | SOCKS5 proxy without authentication |
// | 3     | HTTP proxy with authentication      |
// | 4     | SOCKS5 proxy with authentication    |
// | 5     | SOCKS4 proxy without authentication |
type PreferencesProxyType int32

// PreferencesScanDirs0 defines model for Preferences.ScanDirs.0.
type PreferencesScanDirs0 int

// PreferencesScanDirs1 defines model for .
type PreferencesScanDirs1 = string

// Preferences_ScanDirs_AdditionalProperties defines model for Preferences.scan_dirs.AdditionalProperties.
type Preferences_ScanDirs_AdditionalProperties struct {
	union json.RawMessage
}

// PreferencesSchedulerDays Scheduler days. See possible values here below
//
// | Value | Description     |
// | ----- | --------------- |
// | 0     | Every day       |
// | 1     | Every weekday   |
// | 2     | Every weekend   |
// | 3     | Every Monday    |
// | 4     | Every Tuesday   |
// | 5     | Every Wednesday |
// | 6     | Every Thursday  |
// | 7     | Every Friday    |
// | 8     | Every Saturday  |
// | 9     | Every Sunday    |
type PreferencesSchedulerDays int32

// PreferencesUploadChokingAlgorithm Upload choking algorithm used (see list of possible values below)
//
// | Value | Description    |
// | ----- | -------------- |
// | 0     | Round-robin    |
// | 1     | Fastest upload |
// | 2     | Anti-leech     |
type PreferencesUploadChokingAlgorithm int32

// PreferencesUploadSlotsBehavior Upload slots behavior used (see list of possible values below)
//
// | Value | Description       |
// | ----- | ----------------- |
// | 0     | Fixed slots       |
// | 1     | Upload rate based |
type PreferencesUploadSlotsBehavior int32

// PreferencesUtpTcpMixedMode μTP-TCP mixed mode algorithm (see list of possible values below)
//
// | Value | Description       |
// | ----- | ----------------- |
// | 0     | Prefer TCP        |
// | 1     | Peer proportional |
type PreferencesUtpTcpMixedMode int32

// RenameTorrentFiles defines model for RenameTorrentFiles.
type RenameTorrentFiles struct {
	// Hash The hash of the torrent
	Hash string `json:"hash"`

	// NewPath The new path to use for the file
	NewPath string `json:"newPath"`

	// OldPath The old path of the torrent
	OldPath string `json:"oldPath"`
}

// RssRuleDef JSON encoded rule definition
//
// Rule definition is JSON encoded dictionary with the following fields:
// | Field                     | Type   | Description                                             |
// | ------------------------- | ------ | ------------------------------------------------------- |
// | enabled                   | bool   | Whether the rule is enabled                             |
// | mustContain               | string | The substring that the torrent name must contain        |
// | mustNotContain            | string | The substring that the torrent name must not contain    |
// | useRegex                  | bool   | Enable regex mode in "mustContain" and "mustNotContain" |
// | episodeFilter             | string | Episode filter definition                               |
// | smartFilter               | bool   | Enable smart episode filter                             |
// | previouslyMatchedEpisodes | list   | The list of episode IDs already matched by smart filter |
// | affectedFeeds             | list   | The feed URLs the rule applied to                       |
// | ignoreDays                | number | Ignore sunsequent rule matches                          |
// | lastMatch                 | string | The rule last match time                                |
// | addPaused                 | bool   | Add matched torrent in paused mode                      |
// | assignedCategory          | string | Assign category to the torrent                          |
// | savePath                  | string | Save torrent to the given directory                     |
type RssRuleDef struct {
	// AddPaused Add matched torrent in paused mode
	AddPaused *bool `json:"addPaused,omitempty"`

	// AffectedFeeds The feed URLs the rule applied to
	AffectedFeeds *[]string `json:"affectedFeeds,omitempty"`

	// AssignedCategory Assign category to the torrent
	AssignedCategory *string `json:"assignedCategory,omitempty"`

	// Enabled Whether the rule is enabled
	Enabled *bool `json:"enabled,omitempty"`

	// EpisodeFilter Episode filter definition
	EpisodeFilter *string `json:"episodeFilter,omitempty"`

	// IgnoreDays Ignore sunsequent rule matches
	IgnoreDays *float32 `json:"ignoreDays,omitempty"`

	// LastMatch The rule last match time
	LastMatch *string `json:"lastMatch,omitempty"`

	// MustContain The substring that the torrent name must contain
	MustContain *string `json:"mustContain,omitempty"`

	// MustNotContain The substring that the torrent name must not contain
	MustNotContain *string `json:"mustNotContain,omitempty"`

	// PreviouslyMatchedEpisodes The list of episode IDs already matched by smart filter
	PreviouslyMatchedEpisodes *[]int64 `json:"previouslyMatchedEpisodes,omitempty"`

	// SavePath Save torrent to the given directory
	SavePath *string `json:"savePath,omitempty"`

	// SmartFilter Enable smart episode filter
	SmartFilter *bool `json:"smartFilter,omitempty"`

	// UseRegex Enable regex mode in "mustContain" and "mustNotContain"
	UseRegex *bool `json:"useRegex,omitempty"`
}

// SearchJob The response is a JSON object with the following fields
type SearchJob struct {
	// Id ID of the search job
	Id *float32 `json:"id,omitempty"`
}

// SearchJobStatus defines model for SearchJobStatus.
type SearchJobStatus struct {
	// Id ID of the search job
	Id *float32 `json:"id,omitempty"`

	// Status Current status of the search job (either `Running` or `Stopped`)
	Status *SearchJobStatusStatus `json:"status,omitempty"`

	// Total Total number of results. If the status is `Running` this number may contineu to increase
	Total *float32 `json:"total,omitempty"`
}

// SearchJobStatusStatus Current status of the search job (either `Running` or `Stopped`)
type SearchJobStatusStatus string

// SearchPlugin defines model for SearchPlugin.
type SearchPlugin struct {
	// Enabled Whether the plugin is enabled
	Enabled *bool `json:"enabled,omitempty"`

	// FullName Full name of the plugin
	FullName *string `json:"fullName,omitempty"`

	// Name Short name of the plugin
	Name *string `json:"name,omitempty"`

	// SupportedCategories List of category objects
	SupportedCategories *[]struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"supportedCategories,omitempty"`

	// Url URL of the torrent site
	Url *string `json:"url,omitempty"`

	// Version Installed version of the plugin
	Version *string `json:"version,omitempty"`
}

// SearchResult defines model for SearchResult.
type SearchResult struct {
	// DescrLink URL of the torrent's description page
	DescrLink *string `json:"descrLink,omitempty"`

	// FileName Name of the file
	FileName *string `json:"fileName,omitempty"`

	// FileSize Size of the file in Bytes
	FileSize *float32 `json:"fileSize,omitempty"`

	// FileUrl Torrent download link (usually either .torrent file or magnet link)
	FileUrl *string `json:"fileUrl,omitempty"`

	// NbLeechers Number of leechers
	NbLeechers *float32 `json:"nbLeechers,omitempty"`

	// NbSeeders Number of seeders
	NbSeeders *float32 `json:"nbSeeders,omitempty"`

	// SiteUrl URL of the torrent site
	SiteUrl *string `json:"siteUrl,omitempty"`
}

// SearchResults defines model for SearchResults.
type SearchResults struct {
	Results *[]SearchResult `json:"results,omitempty"`

	// Status Current status of the search job (either `Running` or `Stopped`)
	Status *SearchResultsStatus `json:"status,omitempty"`

	// Total Total number of results. If the status is `Running` this number may continue to increase
	Total *float32 `json:"total,omitempty"`
}

// SearchResultsStatus Current status of the search job (either `Running` or `Stopped`)
type SearchResultsStatus string

// SetPreferences defines model for SetPreferences.
type SetPreferences struct {
	// AddTrackers List of trackers to add to new torrent
	AddTrackers *string `json:"add_trackers,omitempty"`

	// AddTrackersEnabled Enable automatic adding of trackers to new torrents
	AddTrackersEnabled *bool `json:"add_trackers_enabled,omitempty"`

	// AltDlLimit Alternative global download speed limit in KiB/s
	AltDlLimit *int64 `json:"alt_dl_limit,omitempty"`

	// AltUpLimit Alternative global upload speed limit in KiB/s
	AltUpLimit *int64 `json:"alt_up_limit,omitempty"`

	// AlternativeWebuiEnabled True if an alternative WebUI should be used
	AlternativeWebuiEnabled *bool `json:"alternative_webui_enabled,omitempty"`

	// AlternativeWebuiPath File path to the alternative WebUI
	AlternativeWebuiPath *string `json:"alternative_webui_path,omitempty"`

	// AnnounceIp TODO
	AnnounceIp *string `json:"announce_ip,omitempty"`

	// AnnounceToAllTiers True always announce to all tiers
	AnnounceToAllTiers *bool `json:"announce_to_all_tiers,omitempty"`

	// AnnounceToAllTrackers True always announce to all trackers in a tier
	AnnounceToAllTrackers *bool `json:"announce_to_all_trackers,omitempty"`

	// AnonymousMode If true anonymous mode will be enabled; read more [here](https://github.com/qbittorrent/qBittorrent/wiki/Anonymous-Mode); this option is only available in qBittorent built against libtorrent version 0.16.X and higher
	AnonymousMode *bool `json:"anonymous_mode,omitempty"`

	// AsyncIoThreads Number of asynchronous I/O threads
	AsyncIoThreads *int64 `json:"async_io_threads,omitempty"`

	// AutoDeleteMode TODO
	AutoDeleteMode *int `json:"auto_delete_mode,omitempty"`

	// AutoTmmEnabled True if Automatic Torrent Management is enabled by default
	AutoTmmEnabled *bool `json:"auto_tmm_enabled,omitempty"`

	// AutorunEnabled True if external program should be run after torrent has finished downloading
	AutorunEnabled *bool `json:"autorun_enabled,omitempty"`

	// AutorunProgram Program path/name/arguments to run if `autorun_enabled` is enabled; path is separated by slashes; you can use `%f` and `%n` arguments, which will be expanded by qBittorent as path_to_torrent_file and torrent_name (from the GUI; not the .torrent file name) respectively
	AutorunProgram *string `json:"autorun_program,omitempty"`

	// BannedIPs List of banned IPs
	BannedIPs *string `json:"banned_IPs,omitempty"`

	// BittorrentProtocol Bittorrent Protocol to use (see list of possible values below)
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | 0     | TCP and μTP |
	// | 1     | TCP         |
	// | 2     | μTP         |
	BittorrentProtocol *SetPreferencesBittorrentProtocol `json:"bittorrent_protocol,omitempty"`

	// BypassAuthSubnetWhitelist (White)list of ipv4/ipv6 subnets for which webui authentication should be bypassed; list entries are separated by commas
	BypassAuthSubnetWhitelist *[]string `json:"bypass_auth_subnet_whitelist,omitempty"`

	// BypassAuthSubnetWhitelistEnabled True if webui authentication should be bypassed for clients whose ip resides within (at least) one of the subnets on the whitelist
	BypassAuthSubnetWhitelistEnabled *bool `json:"bypass_auth_subnet_whitelist_enabled,omitempty"`

	// BypassLocalAuth True if authentication challenge for loopback address (127.0.0.1) should be disabled
	BypassLocalAuth *bool `json:"bypass_local_auth,omitempty"`

	// CategoryChangedTmmEnabled True if torrent should be relocated when its Category's save path changes
	CategoryChangedTmmEnabled *bool `json:"category_changed_tmm_enabled,omitempty"`

	// CheckingMemoryUse Outstanding memory when checking torrents in MiB
	CheckingMemoryUse *int64 `json:"checking_memory_use,omitempty"`

	// CreateSubfolderEnabled True if a subfolder should be created when adding a torrent
	CreateSubfolderEnabled *bool `json:"create_subfolder_enabled,omitempty"`

	// CurrentInterfaceAddress IP Address to bind to. Empty String means All addresses
	CurrentInterfaceAddress *string `json:"current_interface_address,omitempty"`

	// CurrentNetworkInterface Network Interface used
	CurrentNetworkInterface *string `json:"current_network_interface,omitempty"`

	// Dht True if DHT is enabled
	Dht *bool `json:"dht,omitempty"`

	// DiskCache Disk cache used in MiB
	DiskCache *int64 `json:"disk_cache,omitempty"`

	// DiskCacheTtl Disk cache expiry interval in seconds
	DiskCacheTtl *int64 `json:"disk_cache_ttl,omitempty"`

	// DlLimit Global download speed limit in KiB/s; `-1` means no limit is applied
	DlLimit *int64 `json:"dl_limit,omitempty"`

	// DontCountSlowTorrents If true torrents w/o any activity (stalled ones) will not be counted towards `max_active_*` limits; see [dont_count_slow_torrents](https://www.libtorrent.org/reference-Settings.html#dont_count_slow_torrents) for more information
	DontCountSlowTorrents *bool `json:"dont_count_slow_torrents,omitempty"`

	// DyndnsDomain Your DDNS domain name
	DyndnsDomain *string `json:"dyndns_domain,omitempty"`

	// DyndnsEnabled True if server DNS should be updated dynamically
	DyndnsEnabled *bool `json:"dyndns_enabled,omitempty"`

	// DyndnsPassword Password for DDNS service
	DyndnsPassword *string `json:"dyndns_password,omitempty"`

	// DyndnsService See list of possible values here below
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | 0     | Use DyDNS   |
	// | 1     | Use NOIP    |
	DyndnsService *SetPreferencesDyndnsService `json:"dyndns_service,omitempty"`

	// DyndnsUsername Username for DDNS service
	DyndnsUsername *string `json:"dyndns_username,omitempty"`

	// EmbeddedTrackerPort Port used for embedded tracker
	EmbeddedTrackerPort *int32 `json:"embedded_tracker_port,omitempty"`

	// EnableCoalesceReadWrite True enables coalesce reads & writes
	EnableCoalesceReadWrite *bool `json:"enable_coalesce_read_write,omitempty"`

	// EnableEmbeddedTracker True enables embedded tracker
	EnableEmbeddedTracker *bool `json:"enable_embedded_tracker,omitempty"`

	// EnableMultiConnectionsFromSameIp True allows multiple connections from the same IP address
	EnableMultiConnectionsFromSameIp *bool `json:"enable_multi_connections_from_same_ip,omitempty"`

	// EnableOsCache True enables os cache
	EnableOsCache *bool `json:"enable_os_cache,omitempty"`

	// EnablePieceExtentAffinity True if the advanced libtorrent option `piece_extent_affinity` is enabled
	EnablePieceExtentAffinity *bool `json:"enable_piece_extent_affinity,omitempty"`

	// EnableUploadSuggestions True enables sending of upload piece suggestions
	EnableUploadSuggestions *bool `json:"enable_upload_suggestions,omitempty"`

	// Encryption See list of possible values here below
	//
	// | Value | Description          |
	// | ----- | -------------------- |
	// | 0     | Prefer encryption    |
	// | 1     | Force encryption on  |
	// | 2     | Force encryption off |
	Encryption *SetPreferencesEncryption `json:"encryption,omitempty"`

	// ExportDir Path to directory to copy .torrent files to. Slashes are used as path separators
	ExportDir *string `json:"export_dir,omitempty"`

	// ExportDirFin Path to directory to copy .torrent files of completed downloads to. Slashes are used as path separators
	ExportDirFin *string `json:"export_dir_fin,omitempty"`

	// FilePoolSize File pool size
	FilePoolSize *int64 `json:"file_pool_size,omitempty"`

	// IncompleteFilesExt True if ".!qB" should be appended to incomplete files
	IncompleteFilesExt *bool `json:"incomplete_files_ext,omitempty"`

	// IpFilterEnabled True if external IP filter should be enabled
	IpFilterEnabled *bool `json:"ip_filter_enabled,omitempty"`

	// IpFilterPath Path to IP filter file (.dat, .p2p, .p2b files are supported); path is separated by slashes
	IpFilterPath *string `json:"ip_filter_path,omitempty"`

	// IpFilterTrackers True if IP filters are applied to trackers
	IpFilterTrackers *bool `json:"ip_filter_trackers,omitempty"`

	// LimitLanPeers True if `[du]l_limit` should be applied to peers on the LAN
	LimitLanPeers *bool `json:"limit_lan_peers,omitempty"`

	// LimitTcpOverhead True if `[du]l_limit` should be applied to estimated TCP overhead (service data: e.g. packet headers)
	LimitTcpOverhead *bool `json:"limit_tcp_overhead,omitempty"`

	// LimitUtpRate True if `[du]l_limit` should be applied to uTP connections; this option is only available in qBittorent built against libtorrent version 0.16.X and higher
	LimitUtpRate *bool `json:"limit_utp_rate,omitempty"`

	// ListenPort Port for incoming connections
	ListenPort *int32 `json:"listen_port,omitempty"`

	// Locale Currently selected language (e.g. en_GB for English)
	Locale *string `json:"locale,omitempty"`

	// Lsd True if LSD is enabled
	Lsd *bool `json:"lsd,omitempty"`

	// MailNotificationAuthEnabled True if smtp server requires authentication
	MailNotificationAuthEnabled *bool `json:"mail_notification_auth_enabled,omitempty"`

	// MailNotificationEmail e-mail to send notifications to
	MailNotificationEmail *string `json:"mail_notification_email,omitempty"`

	// MailNotificationEnabled True if e-mail notification should be enabled
	MailNotificationEnabled *bool `json:"mail_notification_enabled,omitempty"`

	// MailNotificationPassword Password for smtp authentication
	MailNotificationPassword *string `json:"mail_notification_password,omitempty"`

	// MailNotificationSender e-mail where notifications should originate from
	MailNotificationSender *string `json:"mail_notification_sender,omitempty"`

	// MailNotificationSmtp smtp server for e-mail notifications
	MailNotificationSmtp *string `json:"mail_notification_smtp,omitempty"`

	// MailNotificationSslEnabled True if smtp server requires SSL connection
	MailNotificationSslEnabled *bool `json:"mail_notification_ssl_enabled,omitempty"`

	// MailNotificationUsername Username for smtp authentication
	MailNotificationUsername *string `json:"mail_notification_username,omitempty"`

	// MaxActiveDownloads Maximum number of active simultaneous downloads
	MaxActiveDownloads *int64 `json:"max_active_downloads,omitempty"`

	// MaxActiveTorrents Maximum number of active simultaneous downloads and uploads
	MaxActiveTorrents *int64 `json:"max_active_torrents,omitempty"`

	// MaxActiveUploads Maximum number of active simultaneous uploads
	MaxActiveUploads *int64 `json:"max_active_uploads,omitempty"`

	// MaxConnec Maximum global number of simultaneous connections
	MaxConnec *int64 `json:"max_connec,omitempty"`

	// MaxConnecPerTorrent Maximum number of simultaneous connections per torrent
	MaxConnecPerTorrent *int64 `json:"max_connec_per_torrent,omitempty"`

	// MaxRatio Get the global share ratio limit
	MaxRatio *float32 `json:"max_ratio,omitempty"`

	// MaxRatioAct Action performed when a torrent reaches the maximum share ratio. See list of possible values here below.
	//
	// | Value | Description    |
	// | ----- | -------------- |
	// | 0     | Pause torrent  |
	// | 1     | Remove torrent |
	MaxRatioAct *SetPreferencesMaxRatioAct `json:"max_ratio_act,omitempty"`

	// MaxRatioEnabled True if share ratio limit is enabled
	MaxRatioEnabled *bool `json:"max_ratio_enabled,omitempty"`

	// MaxSeedingTime Number of minutes to seed a torrent
	MaxSeedingTime *int64 `json:"max_seeding_time,omitempty"`

	// MaxSeedingTimeEnabled True enables max seeding time
	MaxSeedingTimeEnabled *bool `json:"max_seeding_time_enabled,omitempty"`

	// MaxUploads Maximum number of upload slots
	MaxUploads *int64 `json:"max_uploads,omitempty"`

	// MaxUploadsPerTorrent Maximum number of upload slots per torrent
	MaxUploadsPerTorrent *int64 `json:"max_uploads_per_torrent,omitempty"`

	// OutgoingPortsMax Maximal outgoing port (0: Disabled)
	OutgoingPortsMax *int32 `json:"outgoing_ports_max,omitempty"`

	// OutgoingPortsMin Minimal outgoing port (0: Disabled)
	OutgoingPortsMin *int32 `json:"outgoing_ports_min,omitempty"`

	// Pex True if PeX is enabled
	Pex *bool `json:"pex,omitempty"`

	// PreallocateAll True if disk space should be pre-allocated for all files
	PreallocateAll *bool `json:"preallocate_all,omitempty"`

	// ProxyAuthEnabled True proxy requires authentication; doesn't apply to SOCKS4 proxies
	ProxyAuthEnabled *bool `json:"proxy_auth_enabled,omitempty"`

	// ProxyIp Proxy IP address or domain name
	ProxyIp *string `json:"proxy_ip,omitempty"`

	// ProxyPassword Password for proxy authentication
	ProxyPassword *string `json:"proxy_password,omitempty"`

	// ProxyPeerConnections True if peer and web seed connections should be proxified; this option will have any effect only in qBittorent built against libtorrent version 0.16.X and higher
	ProxyPeerConnections *bool `json:"proxy_peer_connections,omitempty"`

	// ProxyPort Proxy port
	ProxyPort *int32 `json:"proxy_port,omitempty"`

	// ProxyTorrentsOnly True if proxy is only used for torrents
	ProxyTorrentsOnly *bool `json:"proxy_torrents_only,omitempty"`

	// ProxyType See list of possible values here below
	//
	// | Value | Description                         |
	// | ----- | ----------------------------------- |
	// | -1    | Proxy is disabled                   |
	// | 0     | Prefer encryption                   |
	// | 1     | HTTP proxy without authentication   |
	// | 2     | SOCKS5 proxy without authentication |
	// | 3     | HTTP proxy with authentication      |
	// | 4     | SOCKS5 proxy with authentication    |
	// | 5     | SOCKS4 proxy without authentication |
	ProxyType *SetPreferencesProxyType `json:"proxy_type,omitempty"`

	// ProxyUsername Username for proxy authentication
	ProxyUsername *string `json:"proxy_username,omitempty"`

	// QueueingEnabled True if torrent queuing is enabled
	QueueingEnabled *bool `json:"queueing_enabled,omitempty"`

	// RandomPort True if the port is randomly selected
	RandomPort *bool `json:"random_port,omitempty"`

	// RecheckCompletedTorrents True rechecks torrents on completion
	RecheckCompletedTorrents *bool `json:"recheck_completed_torrents,omitempty"`

	// ResolvePeerCountries True resolves peer countries
	ResolvePeerCountries *bool `json:"resolve_peer_countries,omitempty"`

	// RssAutoDownloadingEnabled Enable auto-downloading of torrents from the RSS feeds
	RssAutoDownloadingEnabled *bool `json:"rss_auto_downloading_enabled,omitempty"`

	// RssDownloadRepackProperEpisodes For API ≥ v2.5.1: Enable downloading of repack/proper Episodes
	RssDownloadRepackProperEpisodes *bool `json:"rss_download_repack_proper_episodes,omitempty"`

	// RssMaxArticlesPerFeed Max stored articles per RSS feed
	RssMaxArticlesPerFeed *int64 `json:"rss_max_articles_per_feed,omitempty"`

	// RssProcessingEnabled Enable processing of RSS feeds
	RssProcessingEnabled *bool `json:"rss_processing_enabled,omitempty"`

	// RssRefreshInterval RSS refresh interval
	RssRefreshInterval *int64 `json:"rss_refresh_interval,omitempty"`

	// RssSmartEpisodeFilters For API ≥ v2.5.1: List of RSS Smart Episode Filters
	RssSmartEpisodeFilters *string `json:"rss_smart_episode_filters,omitempty"`

	// SavePath Default save path for torrents, separated by slashes
	SavePath *string `json:"save_path,omitempty"`

	// SavePathChangedTmmEnabled True if torrent should be relocated when the default save path changes
	SavePathChangedTmmEnabled *bool `json:"save_path_changed_tmm_enabled,omitempty"`

	// SaveResumeDataInterval Save resume data interval in min
	SaveResumeDataInterval *int64 `json:"save_resume_data_interval,omitempty"`

	// ScanDirs Property: directory to watch for torrent files, value: where torrents loaded from this directory should be downloaded to (see list of possible values below). Slashes are used as path separators; multiple key/value pairs can be specified
	//
	// | Value                  | Description                       |
	// | ---------------------- | --------------------------------- |
	// | 0                      | Download to the monitored folder  |
	// | 1                      | Download to the default save path |
	// | "/path/to/download/to" | Download to this path             |
	ScanDirs *map[string]SetPreferences_ScanDirs_AdditionalProperties `json:"scan_dirs,omitempty"`

	// ScheduleFromHour Scheduler starting hour
	ScheduleFromHour *int32 `json:"schedule_from_hour,omitempty"`

	// ScheduleFromMin Scheduler starting minute
	ScheduleFromMin *int32 `json:"schedule_from_min,omitempty"`

	// ScheduleToHour Scheduler ending hour
	ScheduleToHour *int32 `json:"schedule_to_hour,omitempty"`

	// ScheduleToMin Scheduler ending minute
	ScheduleToMin *int32 `json:"schedule_to_min,omitempty"`

	// SchedulerDays Scheduler days. See possible values here below
	//
	// | Value | Description     |
	// | ----- | --------------- |
	// | 0     | Every day       |
	// | 1     | Every weekday   |
	// | 2     | Every weekend   |
	// | 3     | Every Monday    |
	// | 4     | Every Tuesday   |
	// | 5     | Every Wednesday |
	// | 6     | Every Thursday  |
	// | 7     | Every Friday    |
	// | 8     | Every Saturday  |
	// | 9     | Every Sunday    |
	SchedulerDays *SetPreferencesSchedulerDays `json:"scheduler_days,omitempty"`

	// SchedulerEnabled True if alternative limits should be applied according to schedule
	SchedulerEnabled *bool `json:"scheduler_enabled,omitempty"`

	// SendBufferLowWatermark Send buffer low watermark in KiB
	SendBufferLowWatermark *int64 `json:"send_buffer_low_watermark,omitempty"`

	// SendBufferWatermark Send buffer watermark in KiB
	SendBufferWatermark *int64 `json:"send_buffer_watermark,omitempty"`

	// SendBufferWatermarkFactor Send buffer watermark factor in percent
	SendBufferWatermarkFactor *int32 `json:"send_buffer_watermark_factor,omitempty"`

	// SlowTorrentDlRateThreshold Download rate in KiB/s for a torrent to be considered "slow"
	SlowTorrentDlRateThreshold *int64 `json:"slow_torrent_dl_rate_threshold,omitempty"`

	// SlowTorrentInactiveTimer Seconds a torrent should be inactive before considered "slow"
	SlowTorrentInactiveTimer *int64 `json:"slow_torrent_inactive_timer,omitempty"`

	// SlowTorrentUlRateThreshold Upload rate in KiB/s for a torrent to be considered "slow"
	SlowTorrentUlRateThreshold *int64 `json:"slow_torrent_ul_rate_threshold,omitempty"`

	// SocketBacklogSize Socket backlog size
	SocketBacklogSize *int64 `json:"socket_backlog_size,omitempty"`

	// SslCert For API < v2.0.1: SSL certificate contents (this is a not a path)
	SslCert *string `json:"ssl_cert,omitempty"`

	// SslKey For API < v2.0.1: SSL keyfile contents (this is a not a path)
	SslKey *string `json:"ssl_key,omitempty"`

	// StartPausedEnabled True if torrents should be added in a Paused state
	StartPausedEnabled *bool `json:"start_paused_enabled,omitempty"`

	// StopTrackerTimeout Timeout in seconds for a `stopped` announce request to trackers
	StopTrackerTimeout *int64 `json:"stop_tracker_timeout,omitempty"`

	// TempPath Path for incomplete torrents, separated by slashes
	TempPath *string `json:"temp_path,omitempty"`

	// TempPathEnabled True if folder for incomplete torrents is enabled
	TempPathEnabled *bool `json:"temp_path_enabled,omitempty"`

	// TorrentChangedTmmEnabled True if torrent should be relocated when its Category changes
	TorrentChangedTmmEnabled *bool `json:"torrent_changed_tmm_enabled,omitempty"`

	// UpLimit Global upload speed limit in KiB/s; `-1` means no limit is applied
	UpLimit *int64 `json:"up_limit,omitempty"`

	// UploadChokingAlgorithm Upload choking algorithm used (see list of possible values below)
	//
	// | Value | Description    |
	// | ----- | -------------- |
	// | 0     | Round-robin    |
	// | 1     | Fastest upload |
	// | 2     | Anti-leech     |
	UploadChokingAlgorithm *SetPreferencesUploadChokingAlgorithm `json:"upload_choking_algorithm,omitempty"`

	// UploadSlotsBehavior Upload slots behavior used (see list of possible values below)
	//
	// | Value | Description       |
	// | ----- | ----------------- |
	// | 0     | Fixed slots       |
	// | 1     | Upload rate based |
	UploadSlotsBehavior *SetPreferencesUploadSlotsBehavior `json:"upload_slots_behavior,omitempty"`

	// Upnp True if UPnP/NAT-PMP is enabled
	Upnp *bool `json:"upnp,omitempty"`

	// UpnpLeaseDuration UPnP lease duration (0: Permanent lease)
	UpnpLeaseDuration *int64 `json:"upnp_lease_duration,omitempty"`

	// UseHttps True if WebUI HTTPS access is enabled
	UseHttps *bool `json:"use_https,omitempty"`

	// UtpTcpMixedMode μTP-TCP mixed mode algorithm (see list of possible values below)
	//
	// | Value | Description       |
	// | ----- | ----------------- |
	// | 0     | Prefer TCP        |
	// | 1     | Peer proportional |
	UtpTcpMixedMode *SetPreferencesUtpTcpMixedMode `json:"utp_tcp_mixed_mode,omitempty"`

	// WebUiAddress IP address to use for the WebUI
	WebUiAddress *string `json:"web_ui_address,omitempty"`

	// WebUiBanDuration WebUI access ban duration in seconds
	WebUiBanDuration *int64 `json:"web_ui_ban_duration,omitempty"`

	// WebUiClickjackingProtectionEnabled True if WebUI clickjacking protection is enabled
	WebUiClickjackingProtectionEnabled *bool `json:"web_ui_clickjacking_protection_enabled,omitempty"`

	// WebUiCsrfProtectionEnabled True if WebUI CSRF protection is enabled
	WebUiCsrfProtectionEnabled *bool `json:"web_ui_csrf_protection_enabled,omitempty"`

	// WebUiCustomHttpHeaders For API ≥ v2.5.1: List of custom http headers
	WebUiCustomHttpHeaders *string `json:"web_ui_custom_http_headers,omitempty"`

	// WebUiDomainList Comma-separated list of domains to accept when performing Host header validation
	WebUiDomainList *[]string `json:"web_ui_domain_list,omitempty"`

	// WebUiHostHeaderValidationEnabled True if WebUI host header validation is enabled
	WebUiHostHeaderValidationEnabled *bool `json:"web_ui_host_header_validation_enabled,omitempty"`

	// WebUiHttpsCertPath For API ≥ v2.0.1: Path to SSL certificate
	WebUiHttpsCertPath *string `json:"web_ui_https_cert_path,omitempty"`

	// WebUiHttpsKeyPath For API ≥ v2.0.1: Path to SSL keyfile
	WebUiHttpsKeyPath *string `json:"web_ui_https_key_path,omitempty"`

	// WebUiMaxAuthFailCount Maximum number of authentication failures before WebUI access ban
	WebUiMaxAuthFailCount *int64 `json:"web_ui_max_auth_fail_count,omitempty"`

	// WebUiPassword For API ≥ v2.3.0: Plaintext WebUI password, not readable, write-only. For API < v2.3.0: MD5 hash of WebUI password, hash is generated from the following string: `username:Web UI Access:plain_text_web_ui_password`
	WebUiPassword *string `json:"web_ui_password,omitempty"`

	// WebUiPort WebUI port
	WebUiPort *int32 `json:"web_ui_port,omitempty"`

	// WebUiSecureCookieEnabled True if WebUI cookie `Secure` flag is enabled
	WebUiSecureCookieEnabled *bool `json:"web_ui_secure_cookie_enabled,omitempty"`

	// WebUiSessionTimeout Seconds until WebUI is automatically signed off
	WebUiSessionTimeout *int64 `json:"web_ui_session_timeout,omitempty"`

	// WebUiUpnp True if UPnP is used for the WebUI port
	WebUiUpnp *bool `json:"web_ui_upnp,omitempty"`

	// WebUiUseCustomHttpHeadersEnabled For API ≥ v2.5.1: Enable custom http headers
	WebUiUseCustomHttpHeadersEnabled *bool `json:"web_ui_use_custom_http_headers_enabled,omitempty"`

	// WebUiUsername WebUI username
	WebUiUsername        *string                `json:"web_ui_username,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// SetPreferencesBittorrentProtocol Bittorrent Protocol to use (see list of possible values below)
//
// | Value | Description |
// | ----- | ----------- |
// | 0     | TCP and μTP |
// | 1     | TCP         |
// | 2     | μTP         |
type SetPreferencesBittorrentProtocol int32

// SetPreferencesDyndnsService See list of possible values here below
//
// | Value | Description |
// | ----- | ----------- |
// | 0     | Use DyDNS   |
// | 1     | Use NOIP    |
type SetPreferencesDyndnsService int32

// SetPreferencesEncryption See list of possible values here below
//
// | Value | Description          |
// | ----- | -------------------- |
// | 0     | Prefer encryption    |
// | 1     | Force encryption on  |
// | 2     | Force encryption off |
type SetPreferencesEncryption int32

// SetPreferencesMaxRatioAct Action performed when a torrent reaches the maximum share ratio. See list of possible values here below.
//
// | Value | Description    |
// | ----- | -------------- |
// | 0     | Pause torrent  |
// | 1     | Remove torrent |
type SetPreferencesMaxRatioAct int64

// SetPreferencesProxyType See list of possible values here below
//
// | Value | Description                         |
// | ----- | ----------------------------------- |
// | -1    | Proxy is disabled                   |
// | 0     | Prefer encryption                   |
// | 1     | HTTP proxy without authentication   |
// | 2     | SOCKS5 proxy without authentication |
// | 3     | HTTP proxy with authentication      |
// | 4     | SOCKS5 proxy with authentication    |
// | 5     | SOCKS4 proxy without authentication |
type SetPreferencesProxyType int32

// SetPreferencesScanDirs0 defines model for SetPreferences.ScanDirs.0.
type SetPreferencesScanDirs0 int

// SetPreferencesScanDirs1 defines model for .
type SetPreferencesScanDirs1 = string

// SetPreferences_ScanDirs_AdditionalProperties defines model for SetPreferences.scan_dirs.AdditionalProperties.
type SetPreferences_ScanDirs_AdditionalProperties struct {
	union json.RawMessage
}

// SetPreferencesSchedulerDays Scheduler days. See possible values here below
//
// | Value | Description     |
// | ----- | --------------- |
// | 0     | Every day       |
// | 1     | Every weekday   |
// | 2     | Every weekend   |
// | 3     | Every Monday    |
// | 4     | Every Tuesday   |
// | 5     | Every Wednesday |
// | 6     | Every Thursday  |
// | 7     | Every Friday    |
// | 8     | Every Saturday  |
// | 9     | Every Sunday    |
type SetPreferencesSchedulerDays int32

// SetPreferencesUploadChokingAlgorithm Upload choking algorithm used (see list of possible values below)
//
// | Value | Description    |
// | ----- | -------------- |
// | 0     | Round-robin    |
// | 1     | Fastest upload |
// | 2     | Anti-leech     |
type SetPreferencesUploadChokingAlgorithm int32

// SetPreferencesUploadSlotsBehavior Upload slots behavior used (see list of possible values below)
//
// | Value | Description       |
// | ----- | ----------------- |
// | 0     | Fixed slots       |
// | 1     | Upload rate based |
type SetPreferencesUploadSlotsBehavior int32

// SetPreferencesUtpTcpMixedMode μTP-TCP mixed mode algorithm (see list of possible values below)
//
// | Value | Description       |
// | ----- | ----------------- |
// | 0     | Prefer TCP        |
// | 1     | Peer proportional |
type SetPreferencesUtpTcpMixedMode int32

// SetTorrentsLimit defines model for SetTorrentsLimit.
type SetTorrentsLimit struct {
	Hashes []string `json:"hashes"`
	Limit  *int64   `json:"limit,omitempty"`
}

// SetTorrentsValue defines model for SetTorrentsValue.
type SetTorrentsValue struct {
	Hashes []string `json:"hashes"`

	// Value `value` is a boolean, affects the torrents listed in `hashes`, default is `false`
	Value *bool `json:"value,omitempty"`
}

// TorrentInfo defines model for TorrentInfo.
type TorrentInfo struct {
	// AddedOn Time (Unix Epoch) when the torrent was added to the client
	AddedOn *int64 `json:"added_on,omitempty"`

	// AmountLeft Amount of data left to download (bytes)
	AmountLeft *int64 `json:"amount_left,omitempty"`

	// AutoTmm Whether this torrent is managed by Automatic Torrent Management
	AutoTmm *bool `json:"auto_tmm,omitempty"`

	// Availability Percentage of file pieces currently available
	Availability *float32 `json:"availability,omitempty"`

	// Category Category of the torrent
	Category *string `json:"category,omitempty"`

	// Completed Amount of transfer data completed (bytes)
	Completed *int64 `json:"completed,omitempty"`

	// CompletionOn Time (Unix Epoch) when the torrent completed
	CompletionOn *int64 `json:"completion_on,omitempty"`

	// ContentPath Absolute path of torrent content (root path for multifile torrents, absolute file path for singlefile torrents)
	ContentPath *string `json:"content_path,omitempty"`

	// DlLimit Torrent download speed limit (bytes/s). `-1` if ulimited.
	DlLimit *int64 `json:"dl_limit,omitempty"`

	// Dlspeed Torrent download speed (bytes/s)
	Dlspeed *int64 `json:"dlspeed,omitempty"`

	// Downloaded Amount of data downloaded
	Downloaded *int64 `json:"downloaded,omitempty"`

	// DownloadedSession Amount of data downloaded this session
	DownloadedSession *int64 `json:"downloaded_session,omitempty"`

	// Eta Torrent ETA (seconds)
	Eta *int64 `json:"eta,omitempty"`

	// FLPiecePrio True if first last piece are prioritized
	FLPiecePrio *bool `json:"f_l_piece_prio,omitempty"`

	// ForceStart True if force start is enabled for this torrent
	ForceStart *bool `json:"force_start,omitempty"`

	// Hash Torrent hash
	Hash *string `json:"hash,omitempty"`

	// LastActivity Last time (Unix Epoch) when a chunk was downloaded/uploaded
	LastActivity *int64 `json:"last_activity,omitempty"`

	// MagnetUri Magnet URI corresponding to this torrent
	MagnetUri *string `json:"magnet_uri,omitempty"`

	// MaxRatio Maximum share ratio until torrent is stopped from seeding/uploading
	MaxRatio *float32 `json:"max_ratio,omitempty"`

	// MaxSeedingTime Maximum seeding time (seconds) until torrent is stopped from seeding
	MaxSeedingTime *int64 `json:"max_seeding_time,omitempty"`

	// Name Torrent name
	Name *string `json:"name,omitempty"`

	// NumComplete Number of seeds in the swarm
	NumComplete *int64 `json:"num_complete,omitempty"`

	// NumIncomplete Number of leechers in the swarm
	NumIncomplete *int64 `json:"num_incomplete,omitempty"`

	// NumLeechs Number of leechers connected to
	NumLeechs *int64 `json:"num_leechs,omitempty"`

	// NumSeeds Number of seeds connected to
	NumSeeds *int64 `json:"num_seeds,omitempty"`

	// Priority Torrent priority. Returns -1 if queuing is disabled or torrent is in seed mode
	Priority *int64 `json:"priority,omitempty"`

	// Progress Torrent progress (percentage/100)
	Progress *float32 `json:"progress,omitempty"`

	// Ratio Torrent share ratio. Max ratio value: 9999.
	Ratio *float32 `json:"ratio,omitempty"`

	// RatioLimit TODO (what is different from max_ratio?)
	RatioLimit *float32 `json:"ratio_limit,omitempty"`

	// SavePath Path where this torrent's data is stored
	SavePath *string `json:"save_path,omitempty"`

	// SeedingTime Torrent elapsed time while complete (seconds)
	SeedingTime *int64 `json:"seeding_time,omitempty"`

	// SeedingTimeLimit TODO (what is different from `max_seeding_time`?) seeding_time_limit is a per torrent setting, when Automatic Torrent Management is disabled, furthermore then max_seeding_time is set to seeding_time_limit for this torrent. If Automatic Torrent Management is enabled, the value is -2. And if max_seeding_time is unset it have a default value -1.
	SeedingTimeLimit *int64 `json:"seeding_time_limit,omitempty"`

	// SeenComplete Time (Unix Epoch) when this torrent was last seen complete
	SeenComplete *int64 `json:"seen_complete,omitempty"`

	// SeqDl True if sequential download is enabled
	SeqDl *bool `json:"seq_dl,omitempty"`

	// Size Total size (bytes) of files selected for download
	Size *int64 `json:"size,omitempty"`

	// State Torrent state. See table here below for the possible values
	//
	// | Value              | Description                                                   |
	// | ------------------ | ------------------------------------------------------------- |
	// | error              | Some error occurred, applies to paused torrents               |
	// | missingFiles       | Torrent data files is missing                                 |
	// | uploading          | Torrent is being seeded and data is being transferred         |
	// | pausedUP           | Torrent is paused and has finished downloading                |
	// | queuedUP           | Queuing is enabled and torrent is queued for upload           |
	// | stalledUP          | Torrent is being seeded, but no connection were made          |
	// | checkingUP         | Torrent has finished downloading and is being checked         |
	// | forcedUP           | Torrent is forced to uploading and ignore queue limit         |
	// | allocating         | Torrent is allocating disk space for download                 |
	// | downloading        | Torrent is being downloaded and data is being transferred     |
	// | metaDL             | Torrent has just started downloading and is fetching metadata |
	// | pausedDL           | Torrent is paused and has NOT finished downloading            |
	// | queuedDL           | Queuing is enabled and torrent is queued for download         |
	// | stalledDL          | Torrent is being downloaded, but no connection were made      |
	// | checkingDL         | Same as checkingUP, but torrent has NOT finished downloading  |
	// | forcedDL           | Torrent is forced to downloading to ignore queue limit        |
	// | checkingResumeData | Checking resume data on qBt startup                           |
	// | moving             | Torrent is moving to another location                         |
	// | unknown            | Unknown status                                                |
	State *TorrentInfoState `json:"state,omitempty"`

	// SuperSeeding True if super seeding is enabled
	SuperSeeding *bool `json:"super_seeding,omitempty"`

	// Tags Comma-concatenated tag list of the torrent
	Tags *string `json:"tags,omitempty"`

	// TimeActive Total active time (seconds)
	TimeActive *int64 `json:"time_active,omitempty"`

	// TotalSize Total size (bytes) of all file in this torrent (including unselected ones)
	TotalSize *int64 `json:"total_size,omitempty"`

	// Tracker The first tracker with working status. Returns empty string if no tracker is working.
	Tracker *string `json:"tracker,omitempty"`

	// UpLimit Torrent upload speed limit (bytes/s). `-1` if ulimited.
	UpLimit *int64 `json:"up_limit,omitempty"`

	// Uploaded Amount of data uploaded
	Uploaded *int64 `json:"uploaded,omitempty"`

	// UploadedSession Amount of data uploaded this session
	UploadedSession *int64 `json:"uploaded_session,omitempty"`

	// Upspeed Torrent upload speed (bytes/s)
	Upspeed *int64 `json:"upspeed,omitempty"`
}

// TorrentInfoState Torrent state. See table here below for the possible values
//
// | Value              | Description                                                   |
// | ------------------ | ------------------------------------------------------------- |
// | error              | Some error occurred, applies to paused torrents               |
// | missingFiles       | Torrent data files is missing                                 |
// | uploading          | Torrent is being seeded and data is being transferred         |
// | pausedUP           | Torrent is paused and has finished downloading                |
// | queuedUP           | Queuing is enabled and torrent is queued for upload           |
// | stalledUP          | Torrent is being seeded, but no connection were made          |
// | checkingUP         | Torrent has finished downloading and is being checked         |
// | forcedUP           | Torrent is forced to uploading and ignore queue limit         |
// | allocating         | Torrent is allocating disk space for download                 |
// | downloading        | Torrent is being downloaded and data is being transferred     |
// | metaDL             | Torrent has just started downloading and is fetching metadata |
// | pausedDL           | Torrent is paused and has NOT finished downloading            |
// | queuedDL           | Queuing is enabled and torrent is queued for download         |
// | stalledDL          | Torrent is being downloaded, but no connection were made      |
// | checkingDL         | Same as checkingUP, but torrent has NOT finished downloading  |
// | forcedDL           | Torrent is forced to downloading to ignore queue limit        |
// | checkingResumeData | Checking resume data on qBt startup                           |
// | moving             | Torrent is moving to another location                         |
// | unknown            | Unknown status                                                |
type TorrentInfoState string

// TorrentPeers The response is TODO
type TorrentPeers = map[string]interface{}

// TorrentsCategory defines model for TorrentsCategory.
type TorrentsCategory struct {
	Name     *string `json:"name,omitempty"`
	SavePath *string `json:"savePath,omitempty"`
}

// TorrentsFiles defines model for TorrentsFiles.
type TorrentsFiles struct {
	// Availability Percentage of file pieces currently available (percentage/100)
	Availability *float32 `json:"availability,omitempty"`

	// Index File index
	Index *int64 `json:"index,omitempty"`

	// IsSeed True if file is seeding/complete
	IsSeed *bool `json:"is_seed,omitempty"`

	// Name File name (including relative path)
	Name *string `json:"name,omitempty"`

	// PieceRange The first number is the starting piece index and the second number is the ending piece index (inclusive)
	PieceRange *[]int64 `json:"piece_range,omitempty"`

	// Priority File priority. See possible values here below
	//
	// | Value | Description      |
	// | ----- | ---------------- |
	// | 0     | Do not download  |
	// | 1     | Normal priority  |
	// | 6     | High priority    |
	// | 7     | Maximal priority |
	Priority *TorrentsFilesPriority `json:"priority,omitempty"`

	// Progress File progress (percentage/100)
	Progress *float32 `json:"progress,omitempty"`

	// Size File size (bytes)
	Size *int64 `json:"size,omitempty"`
}

// TorrentsFilesPriority File priority. See possible values here below
//
// | Value | Description      |
// | ----- | ---------------- |
// | 0     | Do not download  |
// | 1     | Normal priority  |
// | 6     | High priority    |
// | 7     | Maximal priority |
type TorrentsFilesPriority int64

// TorrentsLimit defines model for TorrentsLimit.
type TorrentsLimit map[string]int64

// TorrentsProperties The response is:
// - empty, if the torrent hash is invalid
// - otherwise, a JSON object with the following fields
//
// NB: `-1` is returned if the type of the property is integer but its value is not known.
type TorrentsProperties struct {
	// AdditionDate When this torrent was added (unix timestamp)
	AdditionDate *int64 `json:"addition_date,omitempty"`

	// Comment Torrent comment
	Comment *string `json:"comment,omitempty"`

	// CompletionDate Torrent completion date (unix timestamp)
	CompletionDate *int64 `json:"completion_date,omitempty"`

	// CreatedBy Torrent creator
	CreatedBy *string `json:"created_by,omitempty"`

	// CreationDate Torrent creation date (Unix timestamp)
	CreationDate *int64 `json:"creation_date,omitempty"`

	// DlLimit Torrent download limit (bytes/s)
	DlLimit *int64 `json:"dl_limit,omitempty"`

	// DlSpeed Torrent download speed (bytes/second)
	DlSpeed *int64 `json:"dl_speed,omitempty"`

	// DlSpeedAvg Torrent average download speed (bytes/second)
	DlSpeedAvg *int64 `json:"dl_speed_avg,omitempty"`

	// Eta Torrent ETA (seconds)
	Eta *int64 `json:"eta,omitempty"`

	// LastSeen Last seen complete date (unix timestamp)
	LastSeen *int64 `json:"last_seen,omitempty"`

	// NbConnections Torrent connection count
	NbConnections *int64 `json:"nb_connections,omitempty"`

	// NbConnectionsLimit Torrent connection count limit
	NbConnectionsLimit *int64 `json:"nb_connections_limit,omitempty"`

	// Peers Number of peers connected to
	Peers *int64 `json:"peers,omitempty"`

	// PeersTotal Number of peers in the swarm
	PeersTotal *int64 `json:"peers_total,omitempty"`

	// PieceSize Torrent piece size (bytes)
	PieceSize *int64 `json:"piece_size,omitempty"`

	// PiecesHave Number of pieces owned
	PiecesHave *int64 `json:"pieces_have,omitempty"`

	// PiecesNum Number of pieces of the torrent
	PiecesNum *int64 `json:"pieces_num,omitempty"`

	// Reannounce Number of seconds until the next announce
	Reannounce *int64 `json:"reannounce,omitempty"`

	// SavePath Torrent save path
	SavePath *string `json:"save_path,omitempty"`

	// SeedingTime Torrent elapsed time while complete (seconds)
	SeedingTime *int64 `json:"seeding_time,omitempty"`

	// Seeds Number of seeds connected to
	Seeds *int64 `json:"seeds,omitempty"`

	// SeedsTotal Number of seeds in the swarm
	SeedsTotal *int64 `json:"seeds_total,omitempty"`

	// ShareRatio Torrent share ratio
	ShareRatio *float32 `json:"share_ratio,omitempty"`

	// TimeElapsed Torrent elapsed time (seconds)
	TimeElapsed *int64 `json:"time_elapsed,omitempty"`

	// TotalDownloaded Total data downloaded for torrent (bytes)
	TotalDownloaded *int64 `json:"total_downloaded,omitempty"`

	// TotalDownloadedSession Total data downloaded this session (bytes)
	TotalDownloadedSession *int64 `json:"total_downloaded_session,omitempty"`

	// TotalSize Torrent total size (bytes)
	TotalSize *int64 `json:"total_size,omitempty"`

	// TotalUploaded Total data uploaded for torrent (bytes)
	TotalUploaded *int64 `json:"total_uploaded,omitempty"`

	// TotalUploadedSession Total data uploaded this session (bytes)
	TotalUploadedSession *int64 `json:"total_uploaded_session,omitempty"`

	// TotalWasted Total data wasted for torrent (bytes)
	TotalWasted *int64 `json:"total_wasted,omitempty"`

	// UpLimit Torrent upload limit (bytes/s)
	UpLimit *int64 `json:"up_limit,omitempty"`

	// UpSpeed Torrent upload speed (bytes/second)
	UpSpeed *int64 `json:"up_speed,omitempty"`

	// UpSpeedAvg Torrent average upload speed (bytes/second)
	UpSpeedAvg *int64 `json:"up_speed_avg,omitempty"`
}

// TorrentsTags defines model for TorrentsTags.
type TorrentsTags struct {
	Hashes []string  `json:"hashes"`
	Tags   *[]string `json:"tags,omitempty"`
}

// TorrentsTrackers defines model for TorrentsTrackers.
type TorrentsTrackers struct {
	// Msg Tracker message (there is no way of knowing what this message is - it's up to tracker admins)
	Msg *string `json:"msg,omitempty"`

	// NumDownloaded Number of completed downlods for current torrent, as reported by the tracker
	NumDownloaded *int64 `json:"num_downloaded,omitempty"`

	// NumLeeches Number of leeches for current torrent, as reported by the tracker
	NumLeeches *int64 `json:"num_leeches,omitempty"`

	// NumPeers Number of peers for current torrent, as reported by the tracker
	NumPeers *int64 `json:"num_peers,omitempty"`

	// NumSeeds Number of seeds for current torrent, asreported by the tracker
	NumSeeds *int64 `json:"num_seeds,omitempty"`

	// Status Tracker status. See the table below for possible values
	//
	// | Value | Description                                                                        |
	// | ----- | ---------------------------------------------------------------------------------- |
	// | 0     | Tracker is disabled (used for DHT, PeX, and LSD)                                   |
	// | 1     | Tracker has not been contacted yet                                                 |
	// | 2     | Tracker has been contacted and is working                                          |
	// | 3     | Tracker is updating                                                                |
	// | 4     | Tracker has been contacted, but it is not working (or doesn't send proper replies) |
	Status *TorrentsTrackersStatus `json:"status,omitempty"`

	// Tier Tracker priority tier. Lower tier trackers are tried before higher tiers. Tier numbers are valid when `>= 0`, `< 0` is used as placeholder when `tier` does not exist for special entries (such as DHT).
	Tier *int64 `json:"tier,omitempty"`

	// Url Tracker url
	Url *string `json:"url,omitempty"`
}

// TorrentsTrackersStatus Tracker status. See the table below for possible values
//
// | Value | Description                                                                        |
// | ----- | ---------------------------------------------------------------------------------- |
// | 0     | Tracker is disabled (used for DHT, PeX, and LSD)                                   |
// | 1     | Tracker has not been contacted yet                                                 |
// | 2     | Tracker has been contacted and is working                                          |
// | 3     | Tracker is updating                                                                |
// | 4     | Tracker has been contacted, but it is not working (or doesn't send proper replies) |
type TorrentsTrackersStatus int32

// TorrentsWebseeds defines model for TorrentsWebseeds.
type TorrentsWebseeds struct {
	// Url URL of the web seed
	Url *string `json:"url,omitempty"`
}

// TransferInfo The response is a JSON object with the following fields
//
// In addition to the above in partial data requests (see [Get partial data](https://github.com/qbittorrent/qBittorrent/wiki/WebUI-API-(qBittorrent-4.1)#get-partial-data) for more info):
type TransferInfo struct {
	// ConnectionStatus Connection status. See possible values here below
	//
	// Possible values of connection_status:
	// | Value        |
	// | ------------ |
	// | connected    |
	// | firewalled   |
	// | disconnected |
	ConnectionStatus *string `json:"connection_status,omitempty"`

	// DhtNodes DHT nodes connected to
	DhtNodes *int64 `json:"dht_nodes,omitempty"`

	// DlInfoData Data downloaded this session (bytes)
	DlInfoData *int64 `json:"dl_info_data,omitempty"`

	// DlInfoSpeed Global download rate (bytes/s)
	DlInfoSpeed *int64 `json:"dl_info_speed,omitempty"`

	// DlRateLimit Download rate limit (bytes/s)
	DlRateLimit *int64 `json:"dl_rate_limit,omitempty"`

	// Queueing True if torrent queueing is enabled
	Queueing *bool `json:"queueing,omitempty"`

	// RefreshInterval Transfer list refresh interval (milliseconds)
	RefreshInterval *int64 `json:"refresh_interval,omitempty"`

	// UpInfoData Data uploaded this session (bytes)
	UpInfoData *int64 `json:"up_info_data,omitempty"`

	// UpInfoSpeed Global upload rate (bytes/s)
	UpInfoSpeed *int64 `json:"up_info_speed,omitempty"`

	// UpRateLimit Upload rate limit (bytes/s)
	UpRateLimit *int64 `json:"up_rate_limit,omitempty"`

	// UseAltSpeedLimits True if alternative speed limits are enabled
	UseAltSpeedLimits *bool `json:"use_alt_speed_limits,omitempty"`
}

// AppSetPreferencesPostFormdataBody defines parameters for AppSetPreferencesPost.
type AppSetPreferencesPostFormdataBody struct {
	// Json A json object with key-value pairs of the settings you want to change and their new values.
	Json SetPreferences `form:"json" json:"json"`
}

// AuthLoginPostFormdataBody defines parameters for AuthLoginPost.
type AuthLoginPostFormdataBody struct {
	Password string `form:"password" json:"password"`
	Username string `form:"username" json:"username"`
}

// AuthLoginPostParams defines parameters for AuthLoginPost.
type AuthLoginPostParams struct {
	Referer *string `json:"Referer,omitempty"`
	Origin  *string `json:"Origin,omitempty"`
}

// LogMainPostFormdataBody defines parameters for LogMainPost.
type LogMainPostFormdataBody struct {
	// Critical Include critical messages (default: `true`)
	Critical bool `form:"critical" json:"critical"`

	// Info Include info messages (default: `true`)
	Info bool `form:"info" json:"info"`

	// LastKnownId Exclude messages with "message id" <= `last_known_id` (default: `-1`)
	LastKnownId int64 `form:"last_known_id" json:"last_known_id"`

	// Normal Include normal messages (default: `true`)
	Normal bool `form:"normal" json:"normal"`

	// Warning Include warning messages (default: `true`)
	Warning bool `form:"warning" json:"warning"`
}

// LogPeersPostFormdataBody defines parameters for LogPeersPost.
type LogPeersPostFormdataBody struct {
	// LastKnownId Exclude messages with "message id" <= `last_known_id` (default: `-1`)
	LastKnownId int64 `form:"last_known_id" json:"last_known_id"`
}

// RssAddFeedPostFormdataBody defines parameters for RssAddFeedPost.
type RssAddFeedPostFormdataBody struct {
	// Path Full path of added folder (e.g. "The Pirate Bay\Top100\Video")
	Path *string `form:"path,omitempty" json:"path,omitempty"`

	// Url URL of RSS feed (e.g. "http://thepiratebay.org/rss//top100/200")
	Url string `form:"url" json:"url"`
}

// RssAddFolderPostFormdataBody defines parameters for RssAddFolderPost.
type RssAddFolderPostFormdataBody struct {
	// Path Full path of added folder (e.g. "The Pirate Bay\Top100")
	Path string `form:"path" json:"path"`
}

// RssItemsPostFormdataBody defines parameters for RssItemsPost.
type RssItemsPostFormdataBody struct {
	// WithData True if you need current feed articles
	WithData *bool `form:"withData,omitempty" json:"withData,omitempty"`
}

// RssMarkAsReadPostFormdataBody defines parameters for RssMarkAsReadPost.
type RssMarkAsReadPostFormdataBody struct {
	// ArticleId ID of article
	ArticleId *string `form:"articleId,omitempty" json:"articleId,omitempty"`

	// ItemPath Current full path of item (e.g. "The Pirate Bay\Top100")
	ItemPath string `form:"itemPath" json:"itemPath"`
}

// RssMatchingArticlesPostFormdataBody defines parameters for RssMatchingArticlesPost.
type RssMatchingArticlesPostFormdataBody struct {
	// RuleName Rule name (e.g. "Linux")
	RuleName string `form:"ruleName" json:"ruleName"`
}

// RssMoveItemPostFormdataBody defines parameters for RssMoveItemPost.
type RssMoveItemPostFormdataBody struct {
	// DestPath New full path of item (e.g. "The Pirate Bay")
	DestPath string `form:"destPath" json:"destPath"`

	// ItemPath Current full path of item (e.g. "The Pirate Bay\Top100")
	ItemPath string `form:"itemPath" json:"itemPath"`
}

// RssRefreshItemPostFormdataBody defines parameters for RssRefreshItemPost.
type RssRefreshItemPostFormdataBody struct {
	// ItemPath Current full path of item (e.g. "The Pirate Bay\Top100")
	ItemPath string `form:"itemPath" json:"itemPath"`
}

// RssRemoveItemPostFormdataBody defines parameters for RssRemoveItemPost.
type RssRemoveItemPostFormdataBody struct {
	// Path Full path of removed item (e.g. "The Pirate Bay\Top100")
	Path string `form:"path" json:"path"`
}

// RssRemoveRulePostFormdataBody defines parameters for RssRemoveRulePost.
type RssRemoveRulePostFormdataBody struct {
	// RuleName Rule name (e.g. "Punisher")
	RuleName string `form:"ruleName" json:"ruleName"`
}

// RssRenameRulePostFormdataBody defines parameters for RssRenameRulePost.
type RssRenameRulePostFormdataBody struct {
	// NewRuleName New rule name (e.g. "The Punisher")
	NewRuleName string `form:"newRuleName" json:"newRuleName"`

	// RuleName Rule name (e.g. "Punisher")
	RuleName string `form:"ruleName" json:"ruleName"`
}

// RssSetRulePostFormdataBody defines parameters for RssSetRulePost.
type RssSetRulePostFormdataBody struct {
	// RuleDef JSON encoded rule definition
	//
	// Rule definition is JSON encoded dictionary with the following fields:
	// | Field                     | Type   | Description                                             |
	// | ------------------------- | ------ | ------------------------------------------------------- |
	// | enabled                   | bool   | Whether the rule is enabled                             |
	// | mustContain               | string | The substring that the torrent name must contain        |
	// | mustNotContain            | string | The substring that the torrent name must not contain    |
	// | useRegex                  | bool   | Enable regex mode in "mustContain" and "mustNotContain" |
	// | episodeFilter             | string | Episode filter definition                               |
	// | smartFilter               | bool   | Enable smart episode filter                             |
	// | previouslyMatchedEpisodes | list   | The list of episode IDs already matched by smart filter |
	// | affectedFeeds             | list   | The feed URLs the rule applied to                       |
	// | ignoreDays                | number | Ignore sunsequent rule matches                          |
	// | lastMatch                 | string | The rule last match time                                |
	// | addPaused                 | bool   | Add matched torrent in paused mode                      |
	// | assignedCategory          | string | Assign category to the torrent                          |
	// | savePath                  | string | Save torrent to the given directory                     |
	RuleDef RssRuleDef `form:"ruleDef" json:"ruleDef"`

	// RuleName Rule name (e.g. "Punisher")
	RuleName string `form:"ruleName" json:"ruleName"`
}

// SearchDeletePostFormdataBody defines parameters for SearchDeletePost.
type SearchDeletePostFormdataBody struct {
	// Id ID of the search job
	Id float32 `form:"id" json:"id"`
}

// SearchEnablePluginPostFormdataBody defines parameters for SearchEnablePluginPost.
type SearchEnablePluginPostFormdataBody struct {
	// Enable Whether the plugins should be enabled
	Enable bool `form:"enable" json:"enable"`

	// Names Name of the plugin to enable/disable (e.g. "legittorrents"). Supports multiple names separated by `|`
	Names []string `form:"names" json:"names"`
}

// SearchInstallPluginPostFormdataBody defines parameters for SearchInstallPluginPost.
type SearchInstallPluginPostFormdataBody struct {
	// Sources Url or file path of the plugin to install (e.g. "https://raw.githubusercontent.com/qbittorrent/search-plugins/master/nova3/engines/legittorrents.py"). Supports multiple sources separated by `|`
	Sources []string `form:"sources" json:"sources"`
}

// SearchResultsPostFormdataBody defines parameters for SearchResultsPost.
type SearchResultsPostFormdataBody struct {
	// Id ID of the search job
	Id *float32 `form:"id,omitempty" json:"id,omitempty"`

	// Limit max number of results to return. 0 or negative means no limit
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset result to start at. A negative number means count backwards (e.g. -2 returns the 2 most recent results)
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`
}

// SearchStartPostFormdataBody defines parameters for SearchStartPost.
type SearchStartPostFormdataBody struct {
	// Category Categories to limit your search to (e.g. "legittorrents"). Available categories depend on the specified `plugins`. Also supports `all`
	Category []string `form:"category" json:"category"`

	// Pattern Pattern to search for (e.g. "Ubuntu 18.04")
	Pattern string `form:"pattern" json:"pattern"`

	// Plugins Plugins to use for searching (e.g. "legittorrents"). Supports multiple plugins separated by `|`. Also supports `all` and `enabled`
	Plugins []string `form:"plugins" json:"plugins"`
}

// SearchStatusPostFormdataBody defines parameters for SearchStatusPost.
type SearchStatusPostFormdataBody struct {
	// Id ID of the search job. If not specified, all search jobs are returned
	Id *float32 `form:"id,omitempty" json:"id,omitempty"`
}

// SearchStopPostFormdataBody defines parameters for SearchStopPost.
type SearchStopPostFormdataBody = struct {
}

// SearchUninstallPluginPostFormdataBody defines parameters for SearchUninstallPluginPost.
type SearchUninstallPluginPostFormdataBody struct {
	// Names Name of the plugin to uninstall (e.g. "legittorrents"). Supports multiple names separated by `|`
	Names []string `form:"names" json:"names"`
}

// SyncMaindataPostFormdataBody defines parameters for SyncMaindataPost.
type SyncMaindataPostFormdataBody struct {
	// Rid Response ID. If not provided, `rid=0` will be assumed. If the given `rid` is different from the one of last server reply, `full_update` will be `true` (see the server reply details for more info)
	Rid *int64 `form:"rid,omitempty" json:"rid,omitempty"`
}

// SyncTorrentPeersPostFormdataBody defines parameters for SyncTorrentPeersPost.
type SyncTorrentPeersPostFormdataBody struct {
	// Hash Torrent hash
	Hash string `form:"hash" json:"hash"`

	// Rid Response ID. If not provided, `rid=0` will be assumed. If the given `rid` is different from the one of last server reply, `full_update` will be `true` (see the server reply details for more info)
	Rid *int64 `form:"rid,omitempty" json:"rid,omitempty"`
}

// TorrentsAddPostMultipartBody defines parameters for TorrentsAddPost.
type TorrentsAddPostMultipartBody struct {
	union json.RawMessage
}

// TorrentsAddPeersPostFormdataBody defines parameters for TorrentsAddPeersPost.
type TorrentsAddPeersPostFormdataBody struct {
	// Hashes The hash of the torrent, or multiple hashes separated by a pipe `|`
	Hashes []string `form:"hashes" json:"hashes"`

	// Peers The peer to add, or multiple peers separated by a pipe `|`. Each peer is a colon-separated `host:port`
	Peers []string `form:"peers" json:"peers"`
}

// TorrentsAddTrackersPostFormdataBody defines parameters for TorrentsAddTrackersPost.
type TorrentsAddTrackersPostFormdataBody struct {
	Hash string `form:"hash" json:"hash"`
	Urls string `form:"urls" json:"urls"`
}

// TorrentsCreateCategoryPostFormdataBody defines parameters for TorrentsCreateCategoryPost.
type TorrentsCreateCategoryPostFormdataBody = struct {
}

// TorrentsCreateTagsPostFormdataBody defines parameters for TorrentsCreateTagsPost.
type TorrentsCreateTagsPostFormdataBody struct {
	// Tags `tags` is a list of tags you want to create. Can contain multiple tags separated by `,`.
	Tags []string `form:"tags" json:"tags"`
}

// TorrentsDeletePostFormdataBody defines parameters for TorrentsDeletePost.
type TorrentsDeletePostFormdataBody struct {
	// DeleteFiles If set to `true`, the downloaded data will also be deleted, otherwise has no effect.
	DeleteFiles *bool    `form:"deleteFiles,omitempty" json:"deleteFiles,omitempty"`
	Hashes      []string `form:"hashes" json:"hashes"`
}

// TorrentsDeleteTagsPostFormdataBody defines parameters for TorrentsDeleteTagsPost.
type TorrentsDeleteTagsPostFormdataBody struct {
	// Tags `tags` is a list of tags you want to delete. Can contain multiple tags separated by `,`.
	Tags []string `form:"tags" json:"tags"`
}

// TorrentsEditCategoryPostFormdataBody defines parameters for TorrentsEditCategoryPost.
type TorrentsEditCategoryPostFormdataBody = struct {
}

// TorrentsEditTrackerPostFormdataBody defines parameters for TorrentsEditTrackerPost.
type TorrentsEditTrackerPostFormdataBody struct {
	// Hash The hash of the torrent
	Hash string `form:"hash" json:"hash"`

	// NewUrl The new URL to replace the `origUrl`
	NewUrl string `form:"newUrl" json:"newUrl"`

	// OrigUrl The tracker URL you want to edit
	OrigUrl string `form:"origUrl" json:"origUrl"`
}

// TorrentsFilePrioPostFormdataBody defines parameters for TorrentsFilePrioPost.
type TorrentsFilePrioPostFormdataBody struct {
	// Hash The hash of the torrent
	Hash string `form:"hash" json:"hash"`

	// Id File ids, separated by `|`
	Id []int64 `form:"id" json:"id"`

	// Priority File priority to set (consult [torrent contents API](https://github.com/qbittorrent/qBittorrent/wiki/WebUI-API-(qBittorrent-4.1)#get-torrent-contents) for possible values)
	Priority TorrentsFilePrioPostFormdataBodyPriority `form:"priority" json:"priority"`
}

// TorrentsFilePrioPostFormdataBodyPriority defines parameters for TorrentsFilePrioPost.
type TorrentsFilePrioPostFormdataBodyPriority int32

// TorrentsFilesPostFormdataBody defines parameters for TorrentsFilesPost.
type TorrentsFilesPostFormdataBody struct {
	// Hash The hash of the torrent you want to get the contents of
	Hash string `form:"hash" json:"hash"`

	// Indexes The indexes of the files you want to retrieve. `indexes` can contain multiple values separated by `|`.
	Indexes *[]string `form:"indexes,omitempty" json:"indexes,omitempty"`
}

// TorrentsInfoGetParams defines parameters for TorrentsInfoGet.
type TorrentsInfoGetParams struct {
	// Filter Filter torrent list by state.
	Filter *TorrentsInfoGetParamsFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// Category Get torrents with the given category.
	Category *string `form:"category,omitempty" json:"category,omitempty"`

	// Tag Get torrents with the given tag.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Sort Sort torrents by given key.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Reverse Enable reverse sorting.
	Reverse *bool `form:"reverse,omitempty" json:"reverse,omitempty"`

	// Limit Limit the number of torrents returned.
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Set offset.
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Hashes Filter by hashes. Each hash should be provided as a separate parameter, e.g., hashes=value1&hashes=value2
	Hashes *[]string `form:"hashes,omitempty" json:"hashes,omitempty"`
}

// TorrentsInfoGetParamsFilter defines parameters for TorrentsInfoGet.
type TorrentsInfoGetParamsFilter string

// TorrentsInfoPostFormdataBody defines parameters for TorrentsInfoPost.
type TorrentsInfoPostFormdataBody struct {
	// Category Get torrents with the given category (empty string means "without category"; no "category" parameter means "any category" <- broken until [#11748](https://github.com/qbittorrent/qBittorrent/issues/11748) is resolved). Remember to URL-encode the category name. For example, `My category` becomes `My%20category`
	Category *string `form:"category,omitempty" json:"category,omitempty"`

	// Filter Filter torrent list by state. Allowed state filters: `all`, `downloading`, `seeding`, `completed`, `paused`, `active`, `inactive`, `resumed`, `stalled`, `stalled_uploading`, `stalled_downloading`, `errored`
	Filter *TorrentsInfoPostFormdataBodyFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// Hashes Filter by hashes. Can contain multiple hashes separated by `|`
	Hashes *[]string `form:"hashes,omitempty" json:"hashes,omitempty"`

	// Limit Limit the number of torrents returned
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Set offset (if less than 0, offset from end)
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Reverse Enable reverse sorting. Defaults to `false`
	Reverse *bool `form:"reverse,omitempty" json:"reverse,omitempty"`

	// Sort Sort torrents by given key. They can be sorted using any field of the response's JSON array (which are documented below) as the sort key.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Tag Get torrents with the given tag (empty string means "without tag"; no "tag" parameter means "any tag". Remember to URL-encode the category name. For example, `My tag` becomes `My%20tag`
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`
}

// TorrentsInfoPostFormdataBodyFilter defines parameters for TorrentsInfoPost.
type TorrentsInfoPostFormdataBodyFilter string

// TorrentsPieceHashesPostFormdataBody defines parameters for TorrentsPieceHashesPost.
type TorrentsPieceHashesPostFormdataBody struct {
	// Hash The hash of the torrent you want to get the pieces' hashes of
	Hash string `form:"hash" json:"hash"`
}

// TorrentsPieceStatesPostFormdataBody defines parameters for TorrentsPieceStatesPost.
type TorrentsPieceStatesPostFormdataBody struct {
	// Hash The hash of the torrent you want to get the pieces' states of
	Hash string `form:"hash" json:"hash"`
}

// TorrentsPropertiesPostFormdataBody defines parameters for TorrentsPropertiesPost.
type TorrentsPropertiesPostFormdataBody struct {
	// Hash The hash of the torrent you want to get the generic properties of
	Hash string `form:"hash" json:"hash"`
}

// TorrentsRemoveCategoriesPostFormdataBody defines parameters for TorrentsRemoveCategoriesPost.
type TorrentsRemoveCategoriesPostFormdataBody struct {
	// Categories `categories` can contain multiple cateogies separated by `\n` (%0A urlencoded)
	Categories string `form:"categories" json:"categories"`
}

// TorrentsRemoveTrackersPostFormdataBody defines parameters for TorrentsRemoveTrackersPost.
type TorrentsRemoveTrackersPostFormdataBody struct {
	// Hash The hash of the torrent
	Hash string `form:"hash" json:"hash"`

	// Urls URLs to remove, separated by `|`
	Urls []string `form:"urls" json:"urls"`
}

// TorrentsRenamePostFormdataBody defines parameters for TorrentsRenamePost.
type TorrentsRenamePostFormdataBody struct {
	Hash string `form:"hash" json:"hash"`
	Name string `form:"name" json:"name"`
}

// TorrentsSetAutoManagementPostFormdataBody defines parameters for TorrentsSetAutoManagementPost.
type TorrentsSetAutoManagementPostFormdataBody struct {
	// Enable `enable` is a boolean, affects the torrents listed in `hashes`, default is `false`
	Enable *bool    `form:"enable,omitempty" json:"enable,omitempty"`
	Hashes []string `form:"hashes" json:"hashes"`
}

// TorrentsSetCategoryPostFormdataBody defines parameters for TorrentsSetCategoryPost.
type TorrentsSetCategoryPostFormdataBody struct {
	// Category `category` is the torrent category you want to set.
	Category *string  `form:"category,omitempty" json:"category,omitempty"`
	Hashes   []string `form:"hashes" json:"hashes"`
}

// TorrentsSetLocationPostFormdataBody defines parameters for TorrentsSetLocationPost.
type TorrentsSetLocationPostFormdataBody struct {
	Hashes []string `form:"hashes" json:"hashes"`

	// Location `location` is the location to download the torrent to. If the location doesn't exist, the torrent's location is unchanged.
	Location *string `form:"location,omitempty" json:"location,omitempty"`
}

// TorrentsSetShareLimitsPostFormdataBody defines parameters for TorrentsSetShareLimitsPost.
type TorrentsSetShareLimitsPostFormdataBody struct {
	Hashes []string `form:"hashes" json:"hashes"`

	// RatioLimit `ratioLimit` is the max ratio the torrent should be seeded until. `-2` means the global limit should be used, -1 means no limit.
	RatioLimit *float32 `form:"ratioLimit,omitempty" json:"ratioLimit,omitempty"`

	// SeedingTimeLimit `seedingTimeLimit` is the max amount of time the torrent should be seeded. `-2` means the global limit should be used, `-1` means no limit.
	SeedingTimeLimit *float32 `form:"seedingTimeLimit,omitempty" json:"seedingTimeLimit,omitempty"`
}

// TorrentsTrackersPostFormdataBody defines parameters for TorrentsTrackersPost.
type TorrentsTrackersPostFormdataBody struct {
	// Hash The hash of the torrent you want to get the trackers of
	Hash string `form:"hash" json:"hash"`
}

// TorrentWebseedsPostFormdataBody defines parameters for TorrentWebseedsPost.
type TorrentWebseedsPostFormdataBody struct {
	// Hash The hash of the torrent you want to get the webseeds of
	Hash string `form:"hash" json:"hash"`
}

// TransferBanPeersPostFormdataBody defines parameters for TransferBanPeersPost.
type TransferBanPeersPostFormdataBody struct {
	// Peers The peer to ban, or multiple peers separated by a pipe `|`. Each peer is a colon-separated `host:port`
	Peers *[]string `form:"peers,omitempty" json:"peers,omitempty"`
}

// TransferSetDownloadLimitPostFormdataBody defines parameters for TransferSetDownloadLimitPost.
type TransferSetDownloadLimitPostFormdataBody struct {
	// Limit The global download speed limit to set in bytes/second
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`
}

// TransferSetUploadLimitPostFormdataBody defines parameters for TransferSetUploadLimitPost.
type TransferSetUploadLimitPostFormdataBody struct {
	// Limit The global upload speed limit to set in bytes/second
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`
}

// AppSetPreferencesPostFormdataRequestBody defines body for AppSetPreferencesPost for application/x-www-form-urlencoded ContentType.
type AppSetPreferencesPostFormdataRequestBody AppSetPreferencesPostFormdataBody

// AuthLoginPostFormdataRequestBody defines body for AuthLoginPost for application/x-www-form-urlencoded ContentType.
type AuthLoginPostFormdataRequestBody AuthLoginPostFormdataBody

// LogMainPostFormdataRequestBody defines body for LogMainPost for application/x-www-form-urlencoded ContentType.
type LogMainPostFormdataRequestBody LogMainPostFormdataBody

// LogPeersPostFormdataRequestBody defines body for LogPeersPost for application/x-www-form-urlencoded ContentType.
type LogPeersPostFormdataRequestBody LogPeersPostFormdataBody

// RssAddFeedPostFormdataRequestBody defines body for RssAddFeedPost for application/x-www-form-urlencoded ContentType.
type RssAddFeedPostFormdataRequestBody RssAddFeedPostFormdataBody

// RssAddFolderPostFormdataRequestBody defines body for RssAddFolderPost for application/x-www-form-urlencoded ContentType.
type RssAddFolderPostFormdataRequestBody RssAddFolderPostFormdataBody

// RssItemsPostFormdataRequestBody defines body for RssItemsPost for application/x-www-form-urlencoded ContentType.
type RssItemsPostFormdataRequestBody RssItemsPostFormdataBody

// RssMarkAsReadPostFormdataRequestBody defines body for RssMarkAsReadPost for application/x-www-form-urlencoded ContentType.
type RssMarkAsReadPostFormdataRequestBody RssMarkAsReadPostFormdataBody

// RssMatchingArticlesPostFormdataRequestBody defines body for RssMatchingArticlesPost for application/x-www-form-urlencoded ContentType.
type RssMatchingArticlesPostFormdataRequestBody RssMatchingArticlesPostFormdataBody

// RssMoveItemPostFormdataRequestBody defines body for RssMoveItemPost for application/x-www-form-urlencoded ContentType.
type RssMoveItemPostFormdataRequestBody RssMoveItemPostFormdataBody

// RssRefreshItemPostFormdataRequestBody defines body for RssRefreshItemPost for application/x-www-form-urlencoded ContentType.
type RssRefreshItemPostFormdataRequestBody RssRefreshItemPostFormdataBody

// RssRemoveItemPostFormdataRequestBody defines body for RssRemoveItemPost for application/x-www-form-urlencoded ContentType.
type RssRemoveItemPostFormdataRequestBody RssRemoveItemPostFormdataBody

// RssRemoveRulePostFormdataRequestBody defines body for RssRemoveRulePost for application/x-www-form-urlencoded ContentType.
type RssRemoveRulePostFormdataRequestBody RssRemoveRulePostFormdataBody

// RssRenameRulePostFormdataRequestBody defines body for RssRenameRulePost for application/x-www-form-urlencoded ContentType.
type RssRenameRulePostFormdataRequestBody RssRenameRulePostFormdataBody

// RssSetRulePostFormdataRequestBody defines body for RssSetRulePost for application/x-www-form-urlencoded ContentType.
type RssSetRulePostFormdataRequestBody RssSetRulePostFormdataBody

// SearchDeletePostFormdataRequestBody defines body for SearchDeletePost for application/x-www-form-urlencoded ContentType.
type SearchDeletePostFormdataRequestBody SearchDeletePostFormdataBody

// SearchEnablePluginPostFormdataRequestBody defines body for SearchEnablePluginPost for application/x-www-form-urlencoded ContentType.
type SearchEnablePluginPostFormdataRequestBody SearchEnablePluginPostFormdataBody

// SearchInstallPluginPostFormdataRequestBody defines body for SearchInstallPluginPost for application/x-www-form-urlencoded ContentType.
type SearchInstallPluginPostFormdataRequestBody SearchInstallPluginPostFormdataBody

// SearchResultsPostFormdataRequestBody defines body for SearchResultsPost for application/x-www-form-urlencoded ContentType.
type SearchResultsPostFormdataRequestBody SearchResultsPostFormdataBody

// SearchStartPostFormdataRequestBody defines body for SearchStartPost for application/x-www-form-urlencoded ContentType.
type SearchStartPostFormdataRequestBody SearchStartPostFormdataBody

// SearchStatusPostFormdataRequestBody defines body for SearchStatusPost for application/x-www-form-urlencoded ContentType.
type SearchStatusPostFormdataRequestBody SearchStatusPostFormdataBody

// SearchStopPostFormdataRequestBody defines body for SearchStopPost for application/x-www-form-urlencoded ContentType.
type SearchStopPostFormdataRequestBody = SearchStopPostFormdataBody

// SearchUninstallPluginPostFormdataRequestBody defines body for SearchUninstallPluginPost for application/x-www-form-urlencoded ContentType.
type SearchUninstallPluginPostFormdataRequestBody SearchUninstallPluginPostFormdataBody

// SyncMaindataPostFormdataRequestBody defines body for SyncMaindataPost for application/x-www-form-urlencoded ContentType.
type SyncMaindataPostFormdataRequestBody SyncMaindataPostFormdataBody

// SyncTorrentPeersPostFormdataRequestBody defines body for SyncTorrentPeersPost for application/x-www-form-urlencoded ContentType.
type SyncTorrentPeersPostFormdataRequestBody SyncTorrentPeersPostFormdataBody

// TorrentsAddPostMultipartRequestBody defines body for TorrentsAddPost for multipart/form-data ContentType.
type TorrentsAddPostMultipartRequestBody TorrentsAddPostMultipartBody

// TorrentsAddPeersPostFormdataRequestBody defines body for TorrentsAddPeersPost for application/x-www-form-urlencoded ContentType.
type TorrentsAddPeersPostFormdataRequestBody TorrentsAddPeersPostFormdataBody

// TorrentsAddTagsPostFormdataRequestBody defines body for TorrentsAddTagsPost for application/x-www-form-urlencoded ContentType.
type TorrentsAddTagsPostFormdataRequestBody = TorrentsTags

// TorrentsAddTrackersPostFormdataRequestBody defines body for TorrentsAddTrackersPost for application/x-www-form-urlencoded ContentType.
type TorrentsAddTrackersPostFormdataRequestBody TorrentsAddTrackersPostFormdataBody

// TorrentsBottomPrioPostFormdataRequestBody defines body for TorrentsBottomPrioPost for application/x-www-form-urlencoded ContentType.
type TorrentsBottomPrioPostFormdataRequestBody = Hashes

// TorrentsCreateCategoryPostFormdataRequestBody defines body for TorrentsCreateCategoryPost for application/x-www-form-urlencoded ContentType.
type TorrentsCreateCategoryPostFormdataRequestBody = TorrentsCreateCategoryPostFormdataBody

// TorrentsCreateTagsPostFormdataRequestBody defines body for TorrentsCreateTagsPost for application/x-www-form-urlencoded ContentType.
type TorrentsCreateTagsPostFormdataRequestBody TorrentsCreateTagsPostFormdataBody

// TorrentsDecreasePrioPostFormdataRequestBody defines body for TorrentsDecreasePrioPost for application/x-www-form-urlencoded ContentType.
type TorrentsDecreasePrioPostFormdataRequestBody = Hashes

// TorrentsDeletePostFormdataRequestBody defines body for TorrentsDeletePost for application/x-www-form-urlencoded ContentType.
type TorrentsDeletePostFormdataRequestBody TorrentsDeletePostFormdataBody

// TorrentsDeleteTagsPostFormdataRequestBody defines body for TorrentsDeleteTagsPost for application/x-www-form-urlencoded ContentType.
type TorrentsDeleteTagsPostFormdataRequestBody TorrentsDeleteTagsPostFormdataBody

// TorrentsDownloadLimitPostFormdataRequestBody defines body for TorrentsDownloadLimitPost for application/x-www-form-urlencoded ContentType.
type TorrentsDownloadLimitPostFormdataRequestBody = Hashes

// TorrentsEditCategoryPostFormdataRequestBody defines body for TorrentsEditCategoryPost for application/x-www-form-urlencoded ContentType.
type TorrentsEditCategoryPostFormdataRequestBody = TorrentsEditCategoryPostFormdataBody

// TorrentsEditTrackerPostFormdataRequestBody defines body for TorrentsEditTrackerPost for application/x-www-form-urlencoded ContentType.
type TorrentsEditTrackerPostFormdataRequestBody TorrentsEditTrackerPostFormdataBody

// TorrentsFilePrioPostFormdataRequestBody defines body for TorrentsFilePrioPost for application/x-www-form-urlencoded ContentType.
type TorrentsFilePrioPostFormdataRequestBody TorrentsFilePrioPostFormdataBody

// TorrentsFilesPostFormdataRequestBody defines body for TorrentsFilesPost for application/x-www-form-urlencoded ContentType.
type TorrentsFilesPostFormdataRequestBody TorrentsFilesPostFormdataBody

// TorrentsIncreasePrioPostFormdataRequestBody defines body for TorrentsIncreasePrioPost for application/x-www-form-urlencoded ContentType.
type TorrentsIncreasePrioPostFormdataRequestBody = Hashes

// TorrentsInfoPostFormdataRequestBody defines body for TorrentsInfoPost for application/x-www-form-urlencoded ContentType.
type TorrentsInfoPostFormdataRequestBody TorrentsInfoPostFormdataBody

// TorrentsPausePostFormdataRequestBody defines body for TorrentsPausePost for application/x-www-form-urlencoded ContentType.
type TorrentsPausePostFormdataRequestBody = Hashes

// TorrentsPieceHashesPostFormdataRequestBody defines body for TorrentsPieceHashesPost for application/x-www-form-urlencoded ContentType.
type TorrentsPieceHashesPostFormdataRequestBody TorrentsPieceHashesPostFormdataBody

// TorrentsPieceStatesPostFormdataRequestBody defines body for TorrentsPieceStatesPost for application/x-www-form-urlencoded ContentType.
type TorrentsPieceStatesPostFormdataRequestBody TorrentsPieceStatesPostFormdataBody

// TorrentsPropertiesPostFormdataRequestBody defines body for TorrentsPropertiesPost for application/x-www-form-urlencoded ContentType.
type TorrentsPropertiesPostFormdataRequestBody TorrentsPropertiesPostFormdataBody

// TorrentsReannouncePostFormdataRequestBody defines body for TorrentsReannouncePost for application/x-www-form-urlencoded ContentType.
type TorrentsReannouncePostFormdataRequestBody = Hashes

// TorrentsRecheckPostFormdataRequestBody defines body for TorrentsRecheckPost for application/x-www-form-urlencoded ContentType.
type TorrentsRecheckPostFormdataRequestBody = Hashes

// TorrentsRemoveCategoriesPostFormdataRequestBody defines body for TorrentsRemoveCategoriesPost for application/x-www-form-urlencoded ContentType.
type TorrentsRemoveCategoriesPostFormdataRequestBody TorrentsRemoveCategoriesPostFormdataBody

// TorrentsRemoveTagsPostFormdataRequestBody defines body for TorrentsRemoveTagsPost for application/x-www-form-urlencoded ContentType.
type TorrentsRemoveTagsPostFormdataRequestBody = TorrentsTags

// TorrentsRemoveTrackersPostFormdataRequestBody defines body for TorrentsRemoveTrackersPost for application/x-www-form-urlencoded ContentType.
type TorrentsRemoveTrackersPostFormdataRequestBody TorrentsRemoveTrackersPostFormdataBody

// TorrentsRenamePostFormdataRequestBody defines body for TorrentsRenamePost for application/x-www-form-urlencoded ContentType.
type TorrentsRenamePostFormdataRequestBody TorrentsRenamePostFormdataBody

// TorrentsRenameFilePostFormdataRequestBody defines body for TorrentsRenameFilePost for application/x-www-form-urlencoded ContentType.
type TorrentsRenameFilePostFormdataRequestBody = RenameTorrentFiles

// TorrentsRenameFolderPostFormdataRequestBody defines body for TorrentsRenameFolderPost for application/x-www-form-urlencoded ContentType.
type TorrentsRenameFolderPostFormdataRequestBody = RenameTorrentFiles

// TorrentsResumePostFormdataRequestBody defines body for TorrentsResumePost for application/x-www-form-urlencoded ContentType.
type TorrentsResumePostFormdataRequestBody = Hashes

// TorrentsSetAutoManagementPostFormdataRequestBody defines body for TorrentsSetAutoManagementPost for application/x-www-form-urlencoded ContentType.
type TorrentsSetAutoManagementPostFormdataRequestBody TorrentsSetAutoManagementPostFormdataBody

// TorrentsSetCategoryPostFormdataRequestBody defines body for TorrentsSetCategoryPost for application/x-www-form-urlencoded ContentType.
type TorrentsSetCategoryPostFormdataRequestBody TorrentsSetCategoryPostFormdataBody

// TorrentsSetDownloadLimitPostFormdataRequestBody defines body for TorrentsSetDownloadLimitPost for application/x-www-form-urlencoded ContentType.
type TorrentsSetDownloadLimitPostFormdataRequestBody = SetTorrentsLimit

// TorrentsSetForceStartPostFormdataRequestBody defines body for TorrentsSetForceStartPost for application/x-www-form-urlencoded ContentType.
type TorrentsSetForceStartPostFormdataRequestBody = SetTorrentsValue

// TorrentsSetLocationPostFormdataRequestBody defines body for TorrentsSetLocationPost for application/x-www-form-urlencoded ContentType.
type TorrentsSetLocationPostFormdataRequestBody TorrentsSetLocationPostFormdataBody

// TorrentsSetShareLimitsPostFormdataRequestBody defines body for TorrentsSetShareLimitsPost for application/x-www-form-urlencoded ContentType.
type TorrentsSetShareLimitsPostFormdataRequestBody TorrentsSetShareLimitsPostFormdataBody

// TorrentsSetSuperSeedingPostFormdataRequestBody defines body for TorrentsSetSuperSeedingPost for application/x-www-form-urlencoded ContentType.
type TorrentsSetSuperSeedingPostFormdataRequestBody = SetTorrentsValue

// TorrentsSetUploadLimitPostFormdataRequestBody defines body for TorrentsSetUploadLimitPost for application/x-www-form-urlencoded ContentType.
type TorrentsSetUploadLimitPostFormdataRequestBody = SetTorrentsLimit

// TorrentsToggleFirstLastPiecePrioPostFormdataRequestBody defines body for TorrentsToggleFirstLastPiecePrioPost for application/x-www-form-urlencoded ContentType.
type TorrentsToggleFirstLastPiecePrioPostFormdataRequestBody = Hashes

// TorrentsToggleSequentialDownloadPostFormdataRequestBody defines body for TorrentsToggleSequentialDownloadPost for application/x-www-form-urlencoded ContentType.
type TorrentsToggleSequentialDownloadPostFormdataRequestBody = Hashes

// TorrentsTopPrioPostFormdataRequestBody defines body for TorrentsTopPrioPost for application/x-www-form-urlencoded ContentType.
type TorrentsTopPrioPostFormdataRequestBody = Hashes

// TorrentsTrackersPostFormdataRequestBody defines body for TorrentsTrackersPost for application/x-www-form-urlencoded ContentType.
type TorrentsTrackersPostFormdataRequestBody TorrentsTrackersPostFormdataBody

// TorrentsUploadLimitPostFormdataRequestBody defines body for TorrentsUploadLimitPost for application/x-www-form-urlencoded ContentType.
type TorrentsUploadLimitPostFormdataRequestBody = Hashes

// TorrentWebseedsPostFormdataRequestBody defines body for TorrentWebseedsPost for application/x-www-form-urlencoded ContentType.
type TorrentWebseedsPostFormdataRequestBody TorrentWebseedsPostFormdataBody

// TransferBanPeersPostFormdataRequestBody defines body for TransferBanPeersPost for application/x-www-form-urlencoded ContentType.
type TransferBanPeersPostFormdataRequestBody TransferBanPeersPostFormdataBody

// TransferSetDownloadLimitPostFormdataRequestBody defines body for TransferSetDownloadLimitPost for application/x-www-form-urlencoded ContentType.
type TransferSetDownloadLimitPostFormdataRequestBody TransferSetDownloadLimitPostFormdataBody

// TransferSetUploadLimitPostFormdataRequestBody defines body for TransferSetUploadLimitPost for application/x-www-form-urlencoded ContentType.
type TransferSetUploadLimitPostFormdataRequestBody TransferSetUploadLimitPostFormdataBody

// Getter for additional properties for Preferences. Returns the specified
// element and whether it was found
func (a Preferences) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Preferences
func (a *Preferences) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Preferences to handle AdditionalProperties
func (a *Preferences) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["add_trackers"]; found {
		err = json.Unmarshal(raw, &a.AddTrackers)
		if err != nil {
			return fmt.Errorf("error reading 'add_trackers': %w", err)
		}
		delete(object, "add_trackers")
	}

	if raw, found := object["add_trackers_enabled"]; found {
		err = json.Unmarshal(raw, &a.AddTrackersEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'add_trackers_enabled': %w", err)
		}
		delete(object, "add_trackers_enabled")
	}

	if raw, found := object["alt_dl_limit"]; found {
		err = json.Unmarshal(raw, &a.AltDlLimit)
		if err != nil {
			return fmt.Errorf("error reading 'alt_dl_limit': %w", err)
		}
		delete(object, "alt_dl_limit")
	}

	if raw, found := object["alt_up_limit"]; found {
		err = json.Unmarshal(raw, &a.AltUpLimit)
		if err != nil {
			return fmt.Errorf("error reading 'alt_up_limit': %w", err)
		}
		delete(object, "alt_up_limit")
	}

	if raw, found := object["alternative_webui_enabled"]; found {
		err = json.Unmarshal(raw, &a.AlternativeWebuiEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'alternative_webui_enabled': %w", err)
		}
		delete(object, "alternative_webui_enabled")
	}

	if raw, found := object["alternative_webui_path"]; found {
		err = json.Unmarshal(raw, &a.AlternativeWebuiPath)
		if err != nil {
			return fmt.Errorf("error reading 'alternative_webui_path': %w", err)
		}
		delete(object, "alternative_webui_path")
	}

	if raw, found := object["announce_ip"]; found {
		err = json.Unmarshal(raw, &a.AnnounceIp)
		if err != nil {
			return fmt.Errorf("error reading 'announce_ip': %w", err)
		}
		delete(object, "announce_ip")
	}

	if raw, found := object["announce_to_all_tiers"]; found {
		err = json.Unmarshal(raw, &a.AnnounceToAllTiers)
		if err != nil {
			return fmt.Errorf("error reading 'announce_to_all_tiers': %w", err)
		}
		delete(object, "announce_to_all_tiers")
	}

	if raw, found := object["announce_to_all_trackers"]; found {
		err = json.Unmarshal(raw, &a.AnnounceToAllTrackers)
		if err != nil {
			return fmt.Errorf("error reading 'announce_to_all_trackers': %w", err)
		}
		delete(object, "announce_to_all_trackers")
	}

	if raw, found := object["anonymous_mode"]; found {
		err = json.Unmarshal(raw, &a.AnonymousMode)
		if err != nil {
			return fmt.Errorf("error reading 'anonymous_mode': %w", err)
		}
		delete(object, "anonymous_mode")
	}

	if raw, found := object["async_io_threads"]; found {
		err = json.Unmarshal(raw, &a.AsyncIoThreads)
		if err != nil {
			return fmt.Errorf("error reading 'async_io_threads': %w", err)
		}
		delete(object, "async_io_threads")
	}

	if raw, found := object["auto_delete_mode"]; found {
		err = json.Unmarshal(raw, &a.AutoDeleteMode)
		if err != nil {
			return fmt.Errorf("error reading 'auto_delete_mode': %w", err)
		}
		delete(object, "auto_delete_mode")
	}

	if raw, found := object["auto_tmm_enabled"]; found {
		err = json.Unmarshal(raw, &a.AutoTmmEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'auto_tmm_enabled': %w", err)
		}
		delete(object, "auto_tmm_enabled")
	}

	if raw, found := object["autorun_enabled"]; found {
		err = json.Unmarshal(raw, &a.AutorunEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'autorun_enabled': %w", err)
		}
		delete(object, "autorun_enabled")
	}

	if raw, found := object["autorun_program"]; found {
		err = json.Unmarshal(raw, &a.AutorunProgram)
		if err != nil {
			return fmt.Errorf("error reading 'autorun_program': %w", err)
		}
		delete(object, "autorun_program")
	}

	if raw, found := object["banned_IPs"]; found {
		err = json.Unmarshal(raw, &a.BannedIPs)
		if err != nil {
			return fmt.Errorf("error reading 'banned_IPs': %w", err)
		}
		delete(object, "banned_IPs")
	}

	if raw, found := object["bittorrent_protocol"]; found {
		err = json.Unmarshal(raw, &a.BittorrentProtocol)
		if err != nil {
			return fmt.Errorf("error reading 'bittorrent_protocol': %w", err)
		}
		delete(object, "bittorrent_protocol")
	}

	if raw, found := object["bypass_auth_subnet_whitelist"]; found {
		err = json.Unmarshal(raw, &a.BypassAuthSubnetWhitelist)
		if err != nil {
			return fmt.Errorf("error reading 'bypass_auth_subnet_whitelist': %w", err)
		}
		delete(object, "bypass_auth_subnet_whitelist")
	}

	if raw, found := object["bypass_auth_subnet_whitelist_enabled"]; found {
		err = json.Unmarshal(raw, &a.BypassAuthSubnetWhitelistEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'bypass_auth_subnet_whitelist_enabled': %w", err)
		}
		delete(object, "bypass_auth_subnet_whitelist_enabled")
	}

	if raw, found := object["bypass_local_auth"]; found {
		err = json.Unmarshal(raw, &a.BypassLocalAuth)
		if err != nil {
			return fmt.Errorf("error reading 'bypass_local_auth': %w", err)
		}
		delete(object, "bypass_local_auth")
	}

	if raw, found := object["category_changed_tmm_enabled"]; found {
		err = json.Unmarshal(raw, &a.CategoryChangedTmmEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'category_changed_tmm_enabled': %w", err)
		}
		delete(object, "category_changed_tmm_enabled")
	}

	if raw, found := object["checking_memory_use"]; found {
		err = json.Unmarshal(raw, &a.CheckingMemoryUse)
		if err != nil {
			return fmt.Errorf("error reading 'checking_memory_use': %w", err)
		}
		delete(object, "checking_memory_use")
	}

	if raw, found := object["create_subfolder_enabled"]; found {
		err = json.Unmarshal(raw, &a.CreateSubfolderEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'create_subfolder_enabled': %w", err)
		}
		delete(object, "create_subfolder_enabled")
	}

	if raw, found := object["current_interface_address"]; found {
		err = json.Unmarshal(raw, &a.CurrentInterfaceAddress)
		if err != nil {
			return fmt.Errorf("error reading 'current_interface_address': %w", err)
		}
		delete(object, "current_interface_address")
	}

	if raw, found := object["current_network_interface"]; found {
		err = json.Unmarshal(raw, &a.CurrentNetworkInterface)
		if err != nil {
			return fmt.Errorf("error reading 'current_network_interface': %w", err)
		}
		delete(object, "current_network_interface")
	}

	if raw, found := object["dht"]; found {
		err = json.Unmarshal(raw, &a.Dht)
		if err != nil {
			return fmt.Errorf("error reading 'dht': %w", err)
		}
		delete(object, "dht")
	}

	if raw, found := object["disk_cache"]; found {
		err = json.Unmarshal(raw, &a.DiskCache)
		if err != nil {
			return fmt.Errorf("error reading 'disk_cache': %w", err)
		}
		delete(object, "disk_cache")
	}

	if raw, found := object["disk_cache_ttl"]; found {
		err = json.Unmarshal(raw, &a.DiskCacheTtl)
		if err != nil {
			return fmt.Errorf("error reading 'disk_cache_ttl': %w", err)
		}
		delete(object, "disk_cache_ttl")
	}

	if raw, found := object["dl_limit"]; found {
		err = json.Unmarshal(raw, &a.DlLimit)
		if err != nil {
			return fmt.Errorf("error reading 'dl_limit': %w", err)
		}
		delete(object, "dl_limit")
	}

	if raw, found := object["dont_count_slow_torrents"]; found {
		err = json.Unmarshal(raw, &a.DontCountSlowTorrents)
		if err != nil {
			return fmt.Errorf("error reading 'dont_count_slow_torrents': %w", err)
		}
		delete(object, "dont_count_slow_torrents")
	}

	if raw, found := object["dyndns_domain"]; found {
		err = json.Unmarshal(raw, &a.DyndnsDomain)
		if err != nil {
			return fmt.Errorf("error reading 'dyndns_domain': %w", err)
		}
		delete(object, "dyndns_domain")
	}

	if raw, found := object["dyndns_enabled"]; found {
		err = json.Unmarshal(raw, &a.DyndnsEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'dyndns_enabled': %w", err)
		}
		delete(object, "dyndns_enabled")
	}

	if raw, found := object["dyndns_password"]; found {
		err = json.Unmarshal(raw, &a.DyndnsPassword)
		if err != nil {
			return fmt.Errorf("error reading 'dyndns_password': %w", err)
		}
		delete(object, "dyndns_password")
	}

	if raw, found := object["dyndns_service"]; found {
		err = json.Unmarshal(raw, &a.DyndnsService)
		if err != nil {
			return fmt.Errorf("error reading 'dyndns_service': %w", err)
		}
		delete(object, "dyndns_service")
	}

	if raw, found := object["dyndns_username"]; found {
		err = json.Unmarshal(raw, &a.DyndnsUsername)
		if err != nil {
			return fmt.Errorf("error reading 'dyndns_username': %w", err)
		}
		delete(object, "dyndns_username")
	}

	if raw, found := object["embedded_tracker_port"]; found {
		err = json.Unmarshal(raw, &a.EmbeddedTrackerPort)
		if err != nil {
			return fmt.Errorf("error reading 'embedded_tracker_port': %w", err)
		}
		delete(object, "embedded_tracker_port")
	}

	if raw, found := object["enable_coalesce_read_write"]; found {
		err = json.Unmarshal(raw, &a.EnableCoalesceReadWrite)
		if err != nil {
			return fmt.Errorf("error reading 'enable_coalesce_read_write': %w", err)
		}
		delete(object, "enable_coalesce_read_write")
	}

	if raw, found := object["enable_embedded_tracker"]; found {
		err = json.Unmarshal(raw, &a.EnableEmbeddedTracker)
		if err != nil {
			return fmt.Errorf("error reading 'enable_embedded_tracker': %w", err)
		}
		delete(object, "enable_embedded_tracker")
	}

	if raw, found := object["enable_multi_connections_from_same_ip"]; found {
		err = json.Unmarshal(raw, &a.EnableMultiConnectionsFromSameIp)
		if err != nil {
			return fmt.Errorf("error reading 'enable_multi_connections_from_same_ip': %w", err)
		}
		delete(object, "enable_multi_connections_from_same_ip")
	}

	if raw, found := object["enable_os_cache"]; found {
		err = json.Unmarshal(raw, &a.EnableOsCache)
		if err != nil {
			return fmt.Errorf("error reading 'enable_os_cache': %w", err)
		}
		delete(object, "enable_os_cache")
	}

	if raw, found := object["enable_piece_extent_affinity"]; found {
		err = json.Unmarshal(raw, &a.EnablePieceExtentAffinity)
		if err != nil {
			return fmt.Errorf("error reading 'enable_piece_extent_affinity': %w", err)
		}
		delete(object, "enable_piece_extent_affinity")
	}

	if raw, found := object["enable_upload_suggestions"]; found {
		err = json.Unmarshal(raw, &a.EnableUploadSuggestions)
		if err != nil {
			return fmt.Errorf("error reading 'enable_upload_suggestions': %w", err)
		}
		delete(object, "enable_upload_suggestions")
	}

	if raw, found := object["encryption"]; found {
		err = json.Unmarshal(raw, &a.Encryption)
		if err != nil {
			return fmt.Errorf("error reading 'encryption': %w", err)
		}
		delete(object, "encryption")
	}

	if raw, found := object["export_dir"]; found {
		err = json.Unmarshal(raw, &a.ExportDir)
		if err != nil {
			return fmt.Errorf("error reading 'export_dir': %w", err)
		}
		delete(object, "export_dir")
	}

	if raw, found := object["export_dir_fin"]; found {
		err = json.Unmarshal(raw, &a.ExportDirFin)
		if err != nil {
			return fmt.Errorf("error reading 'export_dir_fin': %w", err)
		}
		delete(object, "export_dir_fin")
	}

	if raw, found := object["file_pool_size"]; found {
		err = json.Unmarshal(raw, &a.FilePoolSize)
		if err != nil {
			return fmt.Errorf("error reading 'file_pool_size': %w", err)
		}
		delete(object, "file_pool_size")
	}

	if raw, found := object["incomplete_files_ext"]; found {
		err = json.Unmarshal(raw, &a.IncompleteFilesExt)
		if err != nil {
			return fmt.Errorf("error reading 'incomplete_files_ext': %w", err)
		}
		delete(object, "incomplete_files_ext")
	}

	if raw, found := object["ip_filter_enabled"]; found {
		err = json.Unmarshal(raw, &a.IpFilterEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'ip_filter_enabled': %w", err)
		}
		delete(object, "ip_filter_enabled")
	}

	if raw, found := object["ip_filter_path"]; found {
		err = json.Unmarshal(raw, &a.IpFilterPath)
		if err != nil {
			return fmt.Errorf("error reading 'ip_filter_path': %w", err)
		}
		delete(object, "ip_filter_path")
	}

	if raw, found := object["ip_filter_trackers"]; found {
		err = json.Unmarshal(raw, &a.IpFilterTrackers)
		if err != nil {
			return fmt.Errorf("error reading 'ip_filter_trackers': %w", err)
		}
		delete(object, "ip_filter_trackers")
	}

	if raw, found := object["limit_lan_peers"]; found {
		err = json.Unmarshal(raw, &a.LimitLanPeers)
		if err != nil {
			return fmt.Errorf("error reading 'limit_lan_peers': %w", err)
		}
		delete(object, "limit_lan_peers")
	}

	if raw, found := object["limit_tcp_overhead"]; found {
		err = json.Unmarshal(raw, &a.LimitTcpOverhead)
		if err != nil {
			return fmt.Errorf("error reading 'limit_tcp_overhead': %w", err)
		}
		delete(object, "limit_tcp_overhead")
	}

	if raw, found := object["limit_utp_rate"]; found {
		err = json.Unmarshal(raw, &a.LimitUtpRate)
		if err != nil {
			return fmt.Errorf("error reading 'limit_utp_rate': %w", err)
		}
		delete(object, "limit_utp_rate")
	}

	if raw, found := object["listen_port"]; found {
		err = json.Unmarshal(raw, &a.ListenPort)
		if err != nil {
			return fmt.Errorf("error reading 'listen_port': %w", err)
		}
		delete(object, "listen_port")
	}

	if raw, found := object["locale"]; found {
		err = json.Unmarshal(raw, &a.Locale)
		if err != nil {
			return fmt.Errorf("error reading 'locale': %w", err)
		}
		delete(object, "locale")
	}

	if raw, found := object["lsd"]; found {
		err = json.Unmarshal(raw, &a.Lsd)
		if err != nil {
			return fmt.Errorf("error reading 'lsd': %w", err)
		}
		delete(object, "lsd")
	}

	if raw, found := object["mail_notification_auth_enabled"]; found {
		err = json.Unmarshal(raw, &a.MailNotificationAuthEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'mail_notification_auth_enabled': %w", err)
		}
		delete(object, "mail_notification_auth_enabled")
	}

	if raw, found := object["mail_notification_email"]; found {
		err = json.Unmarshal(raw, &a.MailNotificationEmail)
		if err != nil {
			return fmt.Errorf("error reading 'mail_notification_email': %w", err)
		}
		delete(object, "mail_notification_email")
	}

	if raw, found := object["mail_notification_enabled"]; found {
		err = json.Unmarshal(raw, &a.MailNotificationEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'mail_notification_enabled': %w", err)
		}
		delete(object, "mail_notification_enabled")
	}

	if raw, found := object["mail_notification_password"]; found {
		err = json.Unmarshal(raw, &a.MailNotificationPassword)
		if err != nil {
			return fmt.Errorf("error reading 'mail_notification_password': %w", err)
		}
		delete(object, "mail_notification_password")
	}

	if raw, found := object["mail_notification_sender"]; found {
		err = json.Unmarshal(raw, &a.MailNotificationSender)
		if err != nil {
			return fmt.Errorf("error reading 'mail_notification_sender': %w", err)
		}
		delete(object, "mail_notification_sender")
	}

	if raw, found := object["mail_notification_smtp"]; found {
		err = json.Unmarshal(raw, &a.MailNotificationSmtp)
		if err != nil {
			return fmt.Errorf("error reading 'mail_notification_smtp': %w", err)
		}
		delete(object, "mail_notification_smtp")
	}

	if raw, found := object["mail_notification_ssl_enabled"]; found {
		err = json.Unmarshal(raw, &a.MailNotificationSslEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'mail_notification_ssl_enabled': %w", err)
		}
		delete(object, "mail_notification_ssl_enabled")
	}

	if raw, found := object["mail_notification_username"]; found {
		err = json.Unmarshal(raw, &a.MailNotificationUsername)
		if err != nil {
			return fmt.Errorf("error reading 'mail_notification_username': %w", err)
		}
		delete(object, "mail_notification_username")
	}

	if raw, found := object["max_active_downloads"]; found {
		err = json.Unmarshal(raw, &a.MaxActiveDownloads)
		if err != nil {
			return fmt.Errorf("error reading 'max_active_downloads': %w", err)
		}
		delete(object, "max_active_downloads")
	}

	if raw, found := object["max_active_torrents"]; found {
		err = json.Unmarshal(raw, &a.MaxActiveTorrents)
		if err != nil {
			return fmt.Errorf("error reading 'max_active_torrents': %w", err)
		}
		delete(object, "max_active_torrents")
	}

	if raw, found := object["max_active_uploads"]; found {
		err = json.Unmarshal(raw, &a.MaxActiveUploads)
		if err != nil {
			return fmt.Errorf("error reading 'max_active_uploads': %w", err)
		}
		delete(object, "max_active_uploads")
	}

	if raw, found := object["max_connec"]; found {
		err = json.Unmarshal(raw, &a.MaxConnec)
		if err != nil {
			return fmt.Errorf("error reading 'max_connec': %w", err)
		}
		delete(object, "max_connec")
	}

	if raw, found := object["max_connec_per_torrent"]; found {
		err = json.Unmarshal(raw, &a.MaxConnecPerTorrent)
		if err != nil {
			return fmt.Errorf("error reading 'max_connec_per_torrent': %w", err)
		}
		delete(object, "max_connec_per_torrent")
	}

	if raw, found := object["max_ratio"]; found {
		err = json.Unmarshal(raw, &a.MaxRatio)
		if err != nil {
			return fmt.Errorf("error reading 'max_ratio': %w", err)
		}
		delete(object, "max_ratio")
	}

	if raw, found := object["max_ratio_act"]; found {
		err = json.Unmarshal(raw, &a.MaxRatioAct)
		if err != nil {
			return fmt.Errorf("error reading 'max_ratio_act': %w", err)
		}
		delete(object, "max_ratio_act")
	}

	if raw, found := object["max_ratio_enabled"]; found {
		err = json.Unmarshal(raw, &a.MaxRatioEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'max_ratio_enabled': %w", err)
		}
		delete(object, "max_ratio_enabled")
	}

	if raw, found := object["max_seeding_time"]; found {
		err = json.Unmarshal(raw, &a.MaxSeedingTime)
		if err != nil {
			return fmt.Errorf("error reading 'max_seeding_time': %w", err)
		}
		delete(object, "max_seeding_time")
	}

	if raw, found := object["max_seeding_time_enabled"]; found {
		err = json.Unmarshal(raw, &a.MaxSeedingTimeEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'max_seeding_time_enabled': %w", err)
		}
		delete(object, "max_seeding_time_enabled")
	}

	if raw, found := object["max_uploads"]; found {
		err = json.Unmarshal(raw, &a.MaxUploads)
		if err != nil {
			return fmt.Errorf("error reading 'max_uploads': %w", err)
		}
		delete(object, "max_uploads")
	}

	if raw, found := object["max_uploads_per_torrent"]; found {
		err = json.Unmarshal(raw, &a.MaxUploadsPerTorrent)
		if err != nil {
			return fmt.Errorf("error reading 'max_uploads_per_torrent': %w", err)
		}
		delete(object, "max_uploads_per_torrent")
	}

	if raw, found := object["outgoing_ports_max"]; found {
		err = json.Unmarshal(raw, &a.OutgoingPortsMax)
		if err != nil {
			return fmt.Errorf("error reading 'outgoing_ports_max': %w", err)
		}
		delete(object, "outgoing_ports_max")
	}

	if raw, found := object["outgoing_ports_min"]; found {
		err = json.Unmarshal(raw, &a.OutgoingPortsMin)
		if err != nil {
			return fmt.Errorf("error reading 'outgoing_ports_min': %w", err)
		}
		delete(object, "outgoing_ports_min")
	}

	if raw, found := object["pex"]; found {
		err = json.Unmarshal(raw, &a.Pex)
		if err != nil {
			return fmt.Errorf("error reading 'pex': %w", err)
		}
		delete(object, "pex")
	}

	if raw, found := object["preallocate_all"]; found {
		err = json.Unmarshal(raw, &a.PreallocateAll)
		if err != nil {
			return fmt.Errorf("error reading 'preallocate_all': %w", err)
		}
		delete(object, "preallocate_all")
	}

	if raw, found := object["proxy_auth_enabled"]; found {
		err = json.Unmarshal(raw, &a.ProxyAuthEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_auth_enabled': %w", err)
		}
		delete(object, "proxy_auth_enabled")
	}

	if raw, found := object["proxy_ip"]; found {
		err = json.Unmarshal(raw, &a.ProxyIp)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_ip': %w", err)
		}
		delete(object, "proxy_ip")
	}

	if raw, found := object["proxy_password"]; found {
		err = json.Unmarshal(raw, &a.ProxyPassword)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_password': %w", err)
		}
		delete(object, "proxy_password")
	}

	if raw, found := object["proxy_peer_connections"]; found {
		err = json.Unmarshal(raw, &a.ProxyPeerConnections)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_peer_connections': %w", err)
		}
		delete(object, "proxy_peer_connections")
	}

	if raw, found := object["proxy_port"]; found {
		err = json.Unmarshal(raw, &a.ProxyPort)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_port': %w", err)
		}
		delete(object, "proxy_port")
	}

	if raw, found := object["proxy_torrents_only"]; found {
		err = json.Unmarshal(raw, &a.ProxyTorrentsOnly)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_torrents_only': %w", err)
		}
		delete(object, "proxy_torrents_only")
	}

	if raw, found := object["proxy_type"]; found {
		err = json.Unmarshal(raw, &a.ProxyType)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_type': %w", err)
		}
		delete(object, "proxy_type")
	}

	if raw, found := object["proxy_username"]; found {
		err = json.Unmarshal(raw, &a.ProxyUsername)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_username': %w", err)
		}
		delete(object, "proxy_username")
	}

	if raw, found := object["queueing_enabled"]; found {
		err = json.Unmarshal(raw, &a.QueueingEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'queueing_enabled': %w", err)
		}
		delete(object, "queueing_enabled")
	}

	if raw, found := object["random_port"]; found {
		err = json.Unmarshal(raw, &a.RandomPort)
		if err != nil {
			return fmt.Errorf("error reading 'random_port': %w", err)
		}
		delete(object, "random_port")
	}

	if raw, found := object["recheck_completed_torrents"]; found {
		err = json.Unmarshal(raw, &a.RecheckCompletedTorrents)
		if err != nil {
			return fmt.Errorf("error reading 'recheck_completed_torrents': %w", err)
		}
		delete(object, "recheck_completed_torrents")
	}

	if raw, found := object["resolve_peer_countries"]; found {
		err = json.Unmarshal(raw, &a.ResolvePeerCountries)
		if err != nil {
			return fmt.Errorf("error reading 'resolve_peer_countries': %w", err)
		}
		delete(object, "resolve_peer_countries")
	}

	if raw, found := object["rss_auto_downloading_enabled"]; found {
		err = json.Unmarshal(raw, &a.RssAutoDownloadingEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'rss_auto_downloading_enabled': %w", err)
		}
		delete(object, "rss_auto_downloading_enabled")
	}

	if raw, found := object["rss_download_repack_proper_episodes"]; found {
		err = json.Unmarshal(raw, &a.RssDownloadRepackProperEpisodes)
		if err != nil {
			return fmt.Errorf("error reading 'rss_download_repack_proper_episodes': %w", err)
		}
		delete(object, "rss_download_repack_proper_episodes")
	}

	if raw, found := object["rss_max_articles_per_feed"]; found {
		err = json.Unmarshal(raw, &a.RssMaxArticlesPerFeed)
		if err != nil {
			return fmt.Errorf("error reading 'rss_max_articles_per_feed': %w", err)
		}
		delete(object, "rss_max_articles_per_feed")
	}

	if raw, found := object["rss_processing_enabled"]; found {
		err = json.Unmarshal(raw, &a.RssProcessingEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'rss_processing_enabled': %w", err)
		}
		delete(object, "rss_processing_enabled")
	}

	if raw, found := object["rss_refresh_interval"]; found {
		err = json.Unmarshal(raw, &a.RssRefreshInterval)
		if err != nil {
			return fmt.Errorf("error reading 'rss_refresh_interval': %w", err)
		}
		delete(object, "rss_refresh_interval")
	}

	if raw, found := object["rss_smart_episode_filters"]; found {
		err = json.Unmarshal(raw, &a.RssSmartEpisodeFilters)
		if err != nil {
			return fmt.Errorf("error reading 'rss_smart_episode_filters': %w", err)
		}
		delete(object, "rss_smart_episode_filters")
	}

	if raw, found := object["save_path"]; found {
		err = json.Unmarshal(raw, &a.SavePath)
		if err != nil {
			return fmt.Errorf("error reading 'save_path': %w", err)
		}
		delete(object, "save_path")
	}

	if raw, found := object["save_path_changed_tmm_enabled"]; found {
		err = json.Unmarshal(raw, &a.SavePathChangedTmmEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'save_path_changed_tmm_enabled': %w", err)
		}
		delete(object, "save_path_changed_tmm_enabled")
	}

	if raw, found := object["save_resume_data_interval"]; found {
		err = json.Unmarshal(raw, &a.SaveResumeDataInterval)
		if err != nil {
			return fmt.Errorf("error reading 'save_resume_data_interval': %w", err)
		}
		delete(object, "save_resume_data_interval")
	}

	if raw, found := object["scan_dirs"]; found {
		err = json.Unmarshal(raw, &a.ScanDirs)
		if err != nil {
			return fmt.Errorf("error reading 'scan_dirs': %w", err)
		}
		delete(object, "scan_dirs")
	}

	if raw, found := object["schedule_from_hour"]; found {
		err = json.Unmarshal(raw, &a.ScheduleFromHour)
		if err != nil {
			return fmt.Errorf("error reading 'schedule_from_hour': %w", err)
		}
		delete(object, "schedule_from_hour")
	}

	if raw, found := object["schedule_from_min"]; found {
		err = json.Unmarshal(raw, &a.ScheduleFromMin)
		if err != nil {
			return fmt.Errorf("error reading 'schedule_from_min': %w", err)
		}
		delete(object, "schedule_from_min")
	}

	if raw, found := object["schedule_to_hour"]; found {
		err = json.Unmarshal(raw, &a.ScheduleToHour)
		if err != nil {
			return fmt.Errorf("error reading 'schedule_to_hour': %w", err)
		}
		delete(object, "schedule_to_hour")
	}

	if raw, found := object["schedule_to_min"]; found {
		err = json.Unmarshal(raw, &a.ScheduleToMin)
		if err != nil {
			return fmt.Errorf("error reading 'schedule_to_min': %w", err)
		}
		delete(object, "schedule_to_min")
	}

	if raw, found := object["scheduler_days"]; found {
		err = json.Unmarshal(raw, &a.SchedulerDays)
		if err != nil {
			return fmt.Errorf("error reading 'scheduler_days': %w", err)
		}
		delete(object, "scheduler_days")
	}

	if raw, found := object["scheduler_enabled"]; found {
		err = json.Unmarshal(raw, &a.SchedulerEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'scheduler_enabled': %w", err)
		}
		delete(object, "scheduler_enabled")
	}

	if raw, found := object["send_buffer_low_watermark"]; found {
		err = json.Unmarshal(raw, &a.SendBufferLowWatermark)
		if err != nil {
			return fmt.Errorf("error reading 'send_buffer_low_watermark': %w", err)
		}
		delete(object, "send_buffer_low_watermark")
	}

	if raw, found := object["send_buffer_watermark"]; found {
		err = json.Unmarshal(raw, &a.SendBufferWatermark)
		if err != nil {
			return fmt.Errorf("error reading 'send_buffer_watermark': %w", err)
		}
		delete(object, "send_buffer_watermark")
	}

	if raw, found := object["send_buffer_watermark_factor"]; found {
		err = json.Unmarshal(raw, &a.SendBufferWatermarkFactor)
		if err != nil {
			return fmt.Errorf("error reading 'send_buffer_watermark_factor': %w", err)
		}
		delete(object, "send_buffer_watermark_factor")
	}

	if raw, found := object["slow_torrent_dl_rate_threshold"]; found {
		err = json.Unmarshal(raw, &a.SlowTorrentDlRateThreshold)
		if err != nil {
			return fmt.Errorf("error reading 'slow_torrent_dl_rate_threshold': %w", err)
		}
		delete(object, "slow_torrent_dl_rate_threshold")
	}

	if raw, found := object["slow_torrent_inactive_timer"]; found {
		err = json.Unmarshal(raw, &a.SlowTorrentInactiveTimer)
		if err != nil {
			return fmt.Errorf("error reading 'slow_torrent_inactive_timer': %w", err)
		}
		delete(object, "slow_torrent_inactive_timer")
	}

	if raw, found := object["slow_torrent_ul_rate_threshold"]; found {
		err = json.Unmarshal(raw, &a.SlowTorrentUlRateThreshold)
		if err != nil {
			return fmt.Errorf("error reading 'slow_torrent_ul_rate_threshold': %w", err)
		}
		delete(object, "slow_torrent_ul_rate_threshold")
	}

	if raw, found := object["socket_backlog_size"]; found {
		err = json.Unmarshal(raw, &a.SocketBacklogSize)
		if err != nil {
			return fmt.Errorf("error reading 'socket_backlog_size': %w", err)
		}
		delete(object, "socket_backlog_size")
	}

	if raw, found := object["ssl_cert"]; found {
		err = json.Unmarshal(raw, &a.SslCert)
		if err != nil {
			return fmt.Errorf("error reading 'ssl_cert': %w", err)
		}
		delete(object, "ssl_cert")
	}

	if raw, found := object["ssl_key"]; found {
		err = json.Unmarshal(raw, &a.SslKey)
		if err != nil {
			return fmt.Errorf("error reading 'ssl_key': %w", err)
		}
		delete(object, "ssl_key")
	}

	if raw, found := object["start_paused_enabled"]; found {
		err = json.Unmarshal(raw, &a.StartPausedEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'start_paused_enabled': %w", err)
		}
		delete(object, "start_paused_enabled")
	}

	if raw, found := object["stop_tracker_timeout"]; found {
		err = json.Unmarshal(raw, &a.StopTrackerTimeout)
		if err != nil {
			return fmt.Errorf("error reading 'stop_tracker_timeout': %w", err)
		}
		delete(object, "stop_tracker_timeout")
	}

	if raw, found := object["temp_path"]; found {
		err = json.Unmarshal(raw, &a.TempPath)
		if err != nil {
			return fmt.Errorf("error reading 'temp_path': %w", err)
		}
		delete(object, "temp_path")
	}

	if raw, found := object["temp_path_enabled"]; found {
		err = json.Unmarshal(raw, &a.TempPathEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'temp_path_enabled': %w", err)
		}
		delete(object, "temp_path_enabled")
	}

	if raw, found := object["torrent_changed_tmm_enabled"]; found {
		err = json.Unmarshal(raw, &a.TorrentChangedTmmEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'torrent_changed_tmm_enabled': %w", err)
		}
		delete(object, "torrent_changed_tmm_enabled")
	}

	if raw, found := object["up_limit"]; found {
		err = json.Unmarshal(raw, &a.UpLimit)
		if err != nil {
			return fmt.Errorf("error reading 'up_limit': %w", err)
		}
		delete(object, "up_limit")
	}

	if raw, found := object["upload_choking_algorithm"]; found {
		err = json.Unmarshal(raw, &a.UploadChokingAlgorithm)
		if err != nil {
			return fmt.Errorf("error reading 'upload_choking_algorithm': %w", err)
		}
		delete(object, "upload_choking_algorithm")
	}

	if raw, found := object["upload_slots_behavior"]; found {
		err = json.Unmarshal(raw, &a.UploadSlotsBehavior)
		if err != nil {
			return fmt.Errorf("error reading 'upload_slots_behavior': %w", err)
		}
		delete(object, "upload_slots_behavior")
	}

	if raw, found := object["upnp"]; found {
		err = json.Unmarshal(raw, &a.Upnp)
		if err != nil {
			return fmt.Errorf("error reading 'upnp': %w", err)
		}
		delete(object, "upnp")
	}

	if raw, found := object["upnp_lease_duration"]; found {
		err = json.Unmarshal(raw, &a.UpnpLeaseDuration)
		if err != nil {
			return fmt.Errorf("error reading 'upnp_lease_duration': %w", err)
		}
		delete(object, "upnp_lease_duration")
	}

	if raw, found := object["use_https"]; found {
		err = json.Unmarshal(raw, &a.UseHttps)
		if err != nil {
			return fmt.Errorf("error reading 'use_https': %w", err)
		}
		delete(object, "use_https")
	}

	if raw, found := object["utp_tcp_mixed_mode"]; found {
		err = json.Unmarshal(raw, &a.UtpTcpMixedMode)
		if err != nil {
			return fmt.Errorf("error reading 'utp_tcp_mixed_mode': %w", err)
		}
		delete(object, "utp_tcp_mixed_mode")
	}

	if raw, found := object["web_ui_address"]; found {
		err = json.Unmarshal(raw, &a.WebUiAddress)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_address': %w", err)
		}
		delete(object, "web_ui_address")
	}

	if raw, found := object["web_ui_ban_duration"]; found {
		err = json.Unmarshal(raw, &a.WebUiBanDuration)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_ban_duration': %w", err)
		}
		delete(object, "web_ui_ban_duration")
	}

	if raw, found := object["web_ui_clickjacking_protection_enabled"]; found {
		err = json.Unmarshal(raw, &a.WebUiClickjackingProtectionEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_clickjacking_protection_enabled': %w", err)
		}
		delete(object, "web_ui_clickjacking_protection_enabled")
	}

	if raw, found := object["web_ui_csrf_protection_enabled"]; found {
		err = json.Unmarshal(raw, &a.WebUiCsrfProtectionEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_csrf_protection_enabled': %w", err)
		}
		delete(object, "web_ui_csrf_protection_enabled")
	}

	if raw, found := object["web_ui_custom_http_headers"]; found {
		err = json.Unmarshal(raw, &a.WebUiCustomHttpHeaders)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_custom_http_headers': %w", err)
		}
		delete(object, "web_ui_custom_http_headers")
	}

	if raw, found := object["web_ui_domain_list"]; found {
		err = json.Unmarshal(raw, &a.WebUiDomainList)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_domain_list': %w", err)
		}
		delete(object, "web_ui_domain_list")
	}

	if raw, found := object["web_ui_host_header_validation_enabled"]; found {
		err = json.Unmarshal(raw, &a.WebUiHostHeaderValidationEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_host_header_validation_enabled': %w", err)
		}
		delete(object, "web_ui_host_header_validation_enabled")
	}

	if raw, found := object["web_ui_https_cert_path"]; found {
		err = json.Unmarshal(raw, &a.WebUiHttpsCertPath)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_https_cert_path': %w", err)
		}
		delete(object, "web_ui_https_cert_path")
	}

	if raw, found := object["web_ui_https_key_path"]; found {
		err = json.Unmarshal(raw, &a.WebUiHttpsKeyPath)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_https_key_path': %w", err)
		}
		delete(object, "web_ui_https_key_path")
	}

	if raw, found := object["web_ui_max_auth_fail_count"]; found {
		err = json.Unmarshal(raw, &a.WebUiMaxAuthFailCount)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_max_auth_fail_count': %w", err)
		}
		delete(object, "web_ui_max_auth_fail_count")
	}

	if raw, found := object["web_ui_port"]; found {
		err = json.Unmarshal(raw, &a.WebUiPort)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_port': %w", err)
		}
		delete(object, "web_ui_port")
	}

	if raw, found := object["web_ui_secure_cookie_enabled"]; found {
		err = json.Unmarshal(raw, &a.WebUiSecureCookieEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_secure_cookie_enabled': %w", err)
		}
		delete(object, "web_ui_secure_cookie_enabled")
	}

	if raw, found := object["web_ui_session_timeout"]; found {
		err = json.Unmarshal(raw, &a.WebUiSessionTimeout)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_session_timeout': %w", err)
		}
		delete(object, "web_ui_session_timeout")
	}

	if raw, found := object["web_ui_upnp"]; found {
		err = json.Unmarshal(raw, &a.WebUiUpnp)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_upnp': %w", err)
		}
		delete(object, "web_ui_upnp")
	}

	if raw, found := object["web_ui_use_custom_http_headers_enabled"]; found {
		err = json.Unmarshal(raw, &a.WebUiUseCustomHttpHeadersEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_use_custom_http_headers_enabled': %w", err)
		}
		delete(object, "web_ui_use_custom_http_headers_enabled")
	}

	if raw, found := object["web_ui_username"]; found {
		err = json.Unmarshal(raw, &a.WebUiUsername)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_username': %w", err)
		}
		delete(object, "web_ui_username")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Preferences to handle AdditionalProperties
func (a Preferences) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AddTrackers != nil {
		object["add_trackers"], err = json.Marshal(a.AddTrackers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'add_trackers': %w", err)
		}
	}

	if a.AddTrackersEnabled != nil {
		object["add_trackers_enabled"], err = json.Marshal(a.AddTrackersEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'add_trackers_enabled': %w", err)
		}
	}

	if a.AltDlLimit != nil {
		object["alt_dl_limit"], err = json.Marshal(a.AltDlLimit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'alt_dl_limit': %w", err)
		}
	}

	if a.AltUpLimit != nil {
		object["alt_up_limit"], err = json.Marshal(a.AltUpLimit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'alt_up_limit': %w", err)
		}
	}

	if a.AlternativeWebuiEnabled != nil {
		object["alternative_webui_enabled"], err = json.Marshal(a.AlternativeWebuiEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'alternative_webui_enabled': %w", err)
		}
	}

	if a.AlternativeWebuiPath != nil {
		object["alternative_webui_path"], err = json.Marshal(a.AlternativeWebuiPath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'alternative_webui_path': %w", err)
		}
	}

	if a.AnnounceIp != nil {
		object["announce_ip"], err = json.Marshal(a.AnnounceIp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'announce_ip': %w", err)
		}
	}

	if a.AnnounceToAllTiers != nil {
		object["announce_to_all_tiers"], err = json.Marshal(a.AnnounceToAllTiers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'announce_to_all_tiers': %w", err)
		}
	}

	if a.AnnounceToAllTrackers != nil {
		object["announce_to_all_trackers"], err = json.Marshal(a.AnnounceToAllTrackers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'announce_to_all_trackers': %w", err)
		}
	}

	if a.AnonymousMode != nil {
		object["anonymous_mode"], err = json.Marshal(a.AnonymousMode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'anonymous_mode': %w", err)
		}
	}

	if a.AsyncIoThreads != nil {
		object["async_io_threads"], err = json.Marshal(a.AsyncIoThreads)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'async_io_threads': %w", err)
		}
	}

	if a.AutoDeleteMode != nil {
		object["auto_delete_mode"], err = json.Marshal(a.AutoDeleteMode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'auto_delete_mode': %w", err)
		}
	}

	if a.AutoTmmEnabled != nil {
		object["auto_tmm_enabled"], err = json.Marshal(a.AutoTmmEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'auto_tmm_enabled': %w", err)
		}
	}

	if a.AutorunEnabled != nil {
		object["autorun_enabled"], err = json.Marshal(a.AutorunEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'autorun_enabled': %w", err)
		}
	}

	if a.AutorunProgram != nil {
		object["autorun_program"], err = json.Marshal(a.AutorunProgram)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'autorun_program': %w", err)
		}
	}

	if a.BannedIPs != nil {
		object["banned_IPs"], err = json.Marshal(a.BannedIPs)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'banned_IPs': %w", err)
		}
	}

	if a.BittorrentProtocol != nil {
		object["bittorrent_protocol"], err = json.Marshal(a.BittorrentProtocol)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'bittorrent_protocol': %w", err)
		}
	}

	if a.BypassAuthSubnetWhitelist != nil {
		object["bypass_auth_subnet_whitelist"], err = json.Marshal(a.BypassAuthSubnetWhitelist)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'bypass_auth_subnet_whitelist': %w", err)
		}
	}

	if a.BypassAuthSubnetWhitelistEnabled != nil {
		object["bypass_auth_subnet_whitelist_enabled"], err = json.Marshal(a.BypassAuthSubnetWhitelistEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'bypass_auth_subnet_whitelist_enabled': %w", err)
		}
	}

	if a.BypassLocalAuth != nil {
		object["bypass_local_auth"], err = json.Marshal(a.BypassLocalAuth)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'bypass_local_auth': %w", err)
		}
	}

	if a.CategoryChangedTmmEnabled != nil {
		object["category_changed_tmm_enabled"], err = json.Marshal(a.CategoryChangedTmmEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'category_changed_tmm_enabled': %w", err)
		}
	}

	if a.CheckingMemoryUse != nil {
		object["checking_memory_use"], err = json.Marshal(a.CheckingMemoryUse)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'checking_memory_use': %w", err)
		}
	}

	if a.CreateSubfolderEnabled != nil {
		object["create_subfolder_enabled"], err = json.Marshal(a.CreateSubfolderEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'create_subfolder_enabled': %w", err)
		}
	}

	if a.CurrentInterfaceAddress != nil {
		object["current_interface_address"], err = json.Marshal(a.CurrentInterfaceAddress)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'current_interface_address': %w", err)
		}
	}

	if a.CurrentNetworkInterface != nil {
		object["current_network_interface"], err = json.Marshal(a.CurrentNetworkInterface)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'current_network_interface': %w", err)
		}
	}

	if a.Dht != nil {
		object["dht"], err = json.Marshal(a.Dht)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dht': %w", err)
		}
	}

	if a.DiskCache != nil {
		object["disk_cache"], err = json.Marshal(a.DiskCache)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'disk_cache': %w", err)
		}
	}

	if a.DiskCacheTtl != nil {
		object["disk_cache_ttl"], err = json.Marshal(a.DiskCacheTtl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'disk_cache_ttl': %w", err)
		}
	}

	if a.DlLimit != nil {
		object["dl_limit"], err = json.Marshal(a.DlLimit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dl_limit': %w", err)
		}
	}

	if a.DontCountSlowTorrents != nil {
		object["dont_count_slow_torrents"], err = json.Marshal(a.DontCountSlowTorrents)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dont_count_slow_torrents': %w", err)
		}
	}

	if a.DyndnsDomain != nil {
		object["dyndns_domain"], err = json.Marshal(a.DyndnsDomain)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dyndns_domain': %w", err)
		}
	}

	if a.DyndnsEnabled != nil {
		object["dyndns_enabled"], err = json.Marshal(a.DyndnsEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dyndns_enabled': %w", err)
		}
	}

	if a.DyndnsPassword != nil {
		object["dyndns_password"], err = json.Marshal(a.DyndnsPassword)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dyndns_password': %w", err)
		}
	}

	if a.DyndnsService != nil {
		object["dyndns_service"], err = json.Marshal(a.DyndnsService)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dyndns_service': %w", err)
		}
	}

	if a.DyndnsUsername != nil {
		object["dyndns_username"], err = json.Marshal(a.DyndnsUsername)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dyndns_username': %w", err)
		}
	}

	if a.EmbeddedTrackerPort != nil {
		object["embedded_tracker_port"], err = json.Marshal(a.EmbeddedTrackerPort)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'embedded_tracker_port': %w", err)
		}
	}

	if a.EnableCoalesceReadWrite != nil {
		object["enable_coalesce_read_write"], err = json.Marshal(a.EnableCoalesceReadWrite)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enable_coalesce_read_write': %w", err)
		}
	}

	if a.EnableEmbeddedTracker != nil {
		object["enable_embedded_tracker"], err = json.Marshal(a.EnableEmbeddedTracker)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enable_embedded_tracker': %w", err)
		}
	}

	if a.EnableMultiConnectionsFromSameIp != nil {
		object["enable_multi_connections_from_same_ip"], err = json.Marshal(a.EnableMultiConnectionsFromSameIp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enable_multi_connections_from_same_ip': %w", err)
		}
	}

	if a.EnableOsCache != nil {
		object["enable_os_cache"], err = json.Marshal(a.EnableOsCache)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enable_os_cache': %w", err)
		}
	}

	if a.EnablePieceExtentAffinity != nil {
		object["enable_piece_extent_affinity"], err = json.Marshal(a.EnablePieceExtentAffinity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enable_piece_extent_affinity': %w", err)
		}
	}

	if a.EnableUploadSuggestions != nil {
		object["enable_upload_suggestions"], err = json.Marshal(a.EnableUploadSuggestions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enable_upload_suggestions': %w", err)
		}
	}

	if a.Encryption != nil {
		object["encryption"], err = json.Marshal(a.Encryption)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'encryption': %w", err)
		}
	}

	if a.ExportDir != nil {
		object["export_dir"], err = json.Marshal(a.ExportDir)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'export_dir': %w", err)
		}
	}

	if a.ExportDirFin != nil {
		object["export_dir_fin"], err = json.Marshal(a.ExportDirFin)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'export_dir_fin': %w", err)
		}
	}

	if a.FilePoolSize != nil {
		object["file_pool_size"], err = json.Marshal(a.FilePoolSize)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'file_pool_size': %w", err)
		}
	}

	if a.IncompleteFilesExt != nil {
		object["incomplete_files_ext"], err = json.Marshal(a.IncompleteFilesExt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'incomplete_files_ext': %w", err)
		}
	}

	if a.IpFilterEnabled != nil {
		object["ip_filter_enabled"], err = json.Marshal(a.IpFilterEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ip_filter_enabled': %w", err)
		}
	}

	if a.IpFilterPath != nil {
		object["ip_filter_path"], err = json.Marshal(a.IpFilterPath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ip_filter_path': %w", err)
		}
	}

	if a.IpFilterTrackers != nil {
		object["ip_filter_trackers"], err = json.Marshal(a.IpFilterTrackers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ip_filter_trackers': %w", err)
		}
	}

	if a.LimitLanPeers != nil {
		object["limit_lan_peers"], err = json.Marshal(a.LimitLanPeers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'limit_lan_peers': %w", err)
		}
	}

	if a.LimitTcpOverhead != nil {
		object["limit_tcp_overhead"], err = json.Marshal(a.LimitTcpOverhead)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'limit_tcp_overhead': %w", err)
		}
	}

	if a.LimitUtpRate != nil {
		object["limit_utp_rate"], err = json.Marshal(a.LimitUtpRate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'limit_utp_rate': %w", err)
		}
	}

	if a.ListenPort != nil {
		object["listen_port"], err = json.Marshal(a.ListenPort)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'listen_port': %w", err)
		}
	}

	if a.Locale != nil {
		object["locale"], err = json.Marshal(a.Locale)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'locale': %w", err)
		}
	}

	if a.Lsd != nil {
		object["lsd"], err = json.Marshal(a.Lsd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'lsd': %w", err)
		}
	}

	if a.MailNotificationAuthEnabled != nil {
		object["mail_notification_auth_enabled"], err = json.Marshal(a.MailNotificationAuthEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mail_notification_auth_enabled': %w", err)
		}
	}

	if a.MailNotificationEmail != nil {
		object["mail_notification_email"], err = json.Marshal(a.MailNotificationEmail)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mail_notification_email': %w", err)
		}
	}

	if a.MailNotificationEnabled != nil {
		object["mail_notification_enabled"], err = json.Marshal(a.MailNotificationEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mail_notification_enabled': %w", err)
		}
	}

	if a.MailNotificationPassword != nil {
		object["mail_notification_password"], err = json.Marshal(a.MailNotificationPassword)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mail_notification_password': %w", err)
		}
	}

	if a.MailNotificationSender != nil {
		object["mail_notification_sender"], err = json.Marshal(a.MailNotificationSender)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mail_notification_sender': %w", err)
		}
	}

	if a.MailNotificationSmtp != nil {
		object["mail_notification_smtp"], err = json.Marshal(a.MailNotificationSmtp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mail_notification_smtp': %w", err)
		}
	}

	if a.MailNotificationSslEnabled != nil {
		object["mail_notification_ssl_enabled"], err = json.Marshal(a.MailNotificationSslEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mail_notification_ssl_enabled': %w", err)
		}
	}

	if a.MailNotificationUsername != nil {
		object["mail_notification_username"], err = json.Marshal(a.MailNotificationUsername)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mail_notification_username': %w", err)
		}
	}

	if a.MaxActiveDownloads != nil {
		object["max_active_downloads"], err = json.Marshal(a.MaxActiveDownloads)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_active_downloads': %w", err)
		}
	}

	if a.MaxActiveTorrents != nil {
		object["max_active_torrents"], err = json.Marshal(a.MaxActiveTorrents)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_active_torrents': %w", err)
		}
	}

	if a.MaxActiveUploads != nil {
		object["max_active_uploads"], err = json.Marshal(a.MaxActiveUploads)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_active_uploads': %w", err)
		}
	}

	if a.MaxConnec != nil {
		object["max_connec"], err = json.Marshal(a.MaxConnec)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_connec': %w", err)
		}
	}

	if a.MaxConnecPerTorrent != nil {
		object["max_connec_per_torrent"], err = json.Marshal(a.MaxConnecPerTorrent)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_connec_per_torrent': %w", err)
		}
	}

	if a.MaxRatio != nil {
		object["max_ratio"], err = json.Marshal(a.MaxRatio)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_ratio': %w", err)
		}
	}

	if a.MaxRatioAct != nil {
		object["max_ratio_act"], err = json.Marshal(a.MaxRatioAct)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_ratio_act': %w", err)
		}
	}

	if a.MaxRatioEnabled != nil {
		object["max_ratio_enabled"], err = json.Marshal(a.MaxRatioEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_ratio_enabled': %w", err)
		}
	}

	if a.MaxSeedingTime != nil {
		object["max_seeding_time"], err = json.Marshal(a.MaxSeedingTime)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_seeding_time': %w", err)
		}
	}

	if a.MaxSeedingTimeEnabled != nil {
		object["max_seeding_time_enabled"], err = json.Marshal(a.MaxSeedingTimeEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_seeding_time_enabled': %w", err)
		}
	}

	if a.MaxUploads != nil {
		object["max_uploads"], err = json.Marshal(a.MaxUploads)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_uploads': %w", err)
		}
	}

	if a.MaxUploadsPerTorrent != nil {
		object["max_uploads_per_torrent"], err = json.Marshal(a.MaxUploadsPerTorrent)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_uploads_per_torrent': %w", err)
		}
	}

	if a.OutgoingPortsMax != nil {
		object["outgoing_ports_max"], err = json.Marshal(a.OutgoingPortsMax)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'outgoing_ports_max': %w", err)
		}
	}

	if a.OutgoingPortsMin != nil {
		object["outgoing_ports_min"], err = json.Marshal(a.OutgoingPortsMin)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'outgoing_ports_min': %w", err)
		}
	}

	if a.Pex != nil {
		object["pex"], err = json.Marshal(a.Pex)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pex': %w", err)
		}
	}

	if a.PreallocateAll != nil {
		object["preallocate_all"], err = json.Marshal(a.PreallocateAll)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'preallocate_all': %w", err)
		}
	}

	if a.ProxyAuthEnabled != nil {
		object["proxy_auth_enabled"], err = json.Marshal(a.ProxyAuthEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_auth_enabled': %w", err)
		}
	}

	if a.ProxyIp != nil {
		object["proxy_ip"], err = json.Marshal(a.ProxyIp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_ip': %w", err)
		}
	}

	if a.ProxyPassword != nil {
		object["proxy_password"], err = json.Marshal(a.ProxyPassword)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_password': %w", err)
		}
	}

	if a.ProxyPeerConnections != nil {
		object["proxy_peer_connections"], err = json.Marshal(a.ProxyPeerConnections)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_peer_connections': %w", err)
		}
	}

	if a.ProxyPort != nil {
		object["proxy_port"], err = json.Marshal(a.ProxyPort)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_port': %w", err)
		}
	}

	if a.ProxyTorrentsOnly != nil {
		object["proxy_torrents_only"], err = json.Marshal(a.ProxyTorrentsOnly)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_torrents_only': %w", err)
		}
	}

	if a.ProxyType != nil {
		object["proxy_type"], err = json.Marshal(a.ProxyType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_type': %w", err)
		}
	}

	if a.ProxyUsername != nil {
		object["proxy_username"], err = json.Marshal(a.ProxyUsername)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_username': %w", err)
		}
	}

	if a.QueueingEnabled != nil {
		object["queueing_enabled"], err = json.Marshal(a.QueueingEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'queueing_enabled': %w", err)
		}
	}

	if a.RandomPort != nil {
		object["random_port"], err = json.Marshal(a.RandomPort)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'random_port': %w", err)
		}
	}

	if a.RecheckCompletedTorrents != nil {
		object["recheck_completed_torrents"], err = json.Marshal(a.RecheckCompletedTorrents)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'recheck_completed_torrents': %w", err)
		}
	}

	if a.ResolvePeerCountries != nil {
		object["resolve_peer_countries"], err = json.Marshal(a.ResolvePeerCountries)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'resolve_peer_countries': %w", err)
		}
	}

	if a.RssAutoDownloadingEnabled != nil {
		object["rss_auto_downloading_enabled"], err = json.Marshal(a.RssAutoDownloadingEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'rss_auto_downloading_enabled': %w", err)
		}
	}

	if a.RssDownloadRepackProperEpisodes != nil {
		object["rss_download_repack_proper_episodes"], err = json.Marshal(a.RssDownloadRepackProperEpisodes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'rss_download_repack_proper_episodes': %w", err)
		}
	}

	if a.RssMaxArticlesPerFeed != nil {
		object["rss_max_articles_per_feed"], err = json.Marshal(a.RssMaxArticlesPerFeed)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'rss_max_articles_per_feed': %w", err)
		}
	}

	if a.RssProcessingEnabled != nil {
		object["rss_processing_enabled"], err = json.Marshal(a.RssProcessingEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'rss_processing_enabled': %w", err)
		}
	}

	if a.RssRefreshInterval != nil {
		object["rss_refresh_interval"], err = json.Marshal(a.RssRefreshInterval)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'rss_refresh_interval': %w", err)
		}
	}

	if a.RssSmartEpisodeFilters != nil {
		object["rss_smart_episode_filters"], err = json.Marshal(a.RssSmartEpisodeFilters)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'rss_smart_episode_filters': %w", err)
		}
	}

	if a.SavePath != nil {
		object["save_path"], err = json.Marshal(a.SavePath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'save_path': %w", err)
		}
	}

	if a.SavePathChangedTmmEnabled != nil {
		object["save_path_changed_tmm_enabled"], err = json.Marshal(a.SavePathChangedTmmEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'save_path_changed_tmm_enabled': %w", err)
		}
	}

	if a.SaveResumeDataInterval != nil {
		object["save_resume_data_interval"], err = json.Marshal(a.SaveResumeDataInterval)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'save_resume_data_interval': %w", err)
		}
	}

	if a.ScanDirs != nil {
		object["scan_dirs"], err = json.Marshal(a.ScanDirs)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'scan_dirs': %w", err)
		}
	}

	if a.ScheduleFromHour != nil {
		object["schedule_from_hour"], err = json.Marshal(a.ScheduleFromHour)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'schedule_from_hour': %w", err)
		}
	}

	if a.ScheduleFromMin != nil {
		object["schedule_from_min"], err = json.Marshal(a.ScheduleFromMin)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'schedule_from_min': %w", err)
		}
	}

	if a.ScheduleToHour != nil {
		object["schedule_to_hour"], err = json.Marshal(a.ScheduleToHour)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'schedule_to_hour': %w", err)
		}
	}

	if a.ScheduleToMin != nil {
		object["schedule_to_min"], err = json.Marshal(a.ScheduleToMin)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'schedule_to_min': %w", err)
		}
	}

	if a.SchedulerDays != nil {
		object["scheduler_days"], err = json.Marshal(a.SchedulerDays)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'scheduler_days': %w", err)
		}
	}

	if a.SchedulerEnabled != nil {
		object["scheduler_enabled"], err = json.Marshal(a.SchedulerEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'scheduler_enabled': %w", err)
		}
	}

	if a.SendBufferLowWatermark != nil {
		object["send_buffer_low_watermark"], err = json.Marshal(a.SendBufferLowWatermark)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'send_buffer_low_watermark': %w", err)
		}
	}

	if a.SendBufferWatermark != nil {
		object["send_buffer_watermark"], err = json.Marshal(a.SendBufferWatermark)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'send_buffer_watermark': %w", err)
		}
	}

	if a.SendBufferWatermarkFactor != nil {
		object["send_buffer_watermark_factor"], err = json.Marshal(a.SendBufferWatermarkFactor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'send_buffer_watermark_factor': %w", err)
		}
	}

	if a.SlowTorrentDlRateThreshold != nil {
		object["slow_torrent_dl_rate_threshold"], err = json.Marshal(a.SlowTorrentDlRateThreshold)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'slow_torrent_dl_rate_threshold': %w", err)
		}
	}

	if a.SlowTorrentInactiveTimer != nil {
		object["slow_torrent_inactive_timer"], err = json.Marshal(a.SlowTorrentInactiveTimer)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'slow_torrent_inactive_timer': %w", err)
		}
	}

	if a.SlowTorrentUlRateThreshold != nil {
		object["slow_torrent_ul_rate_threshold"], err = json.Marshal(a.SlowTorrentUlRateThreshold)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'slow_torrent_ul_rate_threshold': %w", err)
		}
	}

	if a.SocketBacklogSize != nil {
		object["socket_backlog_size"], err = json.Marshal(a.SocketBacklogSize)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'socket_backlog_size': %w", err)
		}
	}

	if a.SslCert != nil {
		object["ssl_cert"], err = json.Marshal(a.SslCert)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ssl_cert': %w", err)
		}
	}

	if a.SslKey != nil {
		object["ssl_key"], err = json.Marshal(a.SslKey)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ssl_key': %w", err)
		}
	}

	if a.StartPausedEnabled != nil {
		object["start_paused_enabled"], err = json.Marshal(a.StartPausedEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'start_paused_enabled': %w", err)
		}
	}

	if a.StopTrackerTimeout != nil {
		object["stop_tracker_timeout"], err = json.Marshal(a.StopTrackerTimeout)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stop_tracker_timeout': %w", err)
		}
	}

	if a.TempPath != nil {
		object["temp_path"], err = json.Marshal(a.TempPath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'temp_path': %w", err)
		}
	}

	if a.TempPathEnabled != nil {
		object["temp_path_enabled"], err = json.Marshal(a.TempPathEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'temp_path_enabled': %w", err)
		}
	}

	if a.TorrentChangedTmmEnabled != nil {
		object["torrent_changed_tmm_enabled"], err = json.Marshal(a.TorrentChangedTmmEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'torrent_changed_tmm_enabled': %w", err)
		}
	}

	if a.UpLimit != nil {
		object["up_limit"], err = json.Marshal(a.UpLimit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'up_limit': %w", err)
		}
	}

	if a.UploadChokingAlgorithm != nil {
		object["upload_choking_algorithm"], err = json.Marshal(a.UploadChokingAlgorithm)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'upload_choking_algorithm': %w", err)
		}
	}

	if a.UploadSlotsBehavior != nil {
		object["upload_slots_behavior"], err = json.Marshal(a.UploadSlotsBehavior)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'upload_slots_behavior': %w", err)
		}
	}

	if a.Upnp != nil {
		object["upnp"], err = json.Marshal(a.Upnp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'upnp': %w", err)
		}
	}

	if a.UpnpLeaseDuration != nil {
		object["upnp_lease_duration"], err = json.Marshal(a.UpnpLeaseDuration)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'upnp_lease_duration': %w", err)
		}
	}

	if a.UseHttps != nil {
		object["use_https"], err = json.Marshal(a.UseHttps)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'use_https': %w", err)
		}
	}

	if a.UtpTcpMixedMode != nil {
		object["utp_tcp_mixed_mode"], err = json.Marshal(a.UtpTcpMixedMode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'utp_tcp_mixed_mode': %w", err)
		}
	}

	if a.WebUiAddress != nil {
		object["web_ui_address"], err = json.Marshal(a.WebUiAddress)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_address': %w", err)
		}
	}

	if a.WebUiBanDuration != nil {
		object["web_ui_ban_duration"], err = json.Marshal(a.WebUiBanDuration)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_ban_duration': %w", err)
		}
	}

	if a.WebUiClickjackingProtectionEnabled != nil {
		object["web_ui_clickjacking_protection_enabled"], err = json.Marshal(a.WebUiClickjackingProtectionEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_clickjacking_protection_enabled': %w", err)
		}
	}

	if a.WebUiCsrfProtectionEnabled != nil {
		object["web_ui_csrf_protection_enabled"], err = json.Marshal(a.WebUiCsrfProtectionEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_csrf_protection_enabled': %w", err)
		}
	}

	if a.WebUiCustomHttpHeaders != nil {
		object["web_ui_custom_http_headers"], err = json.Marshal(a.WebUiCustomHttpHeaders)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_custom_http_headers': %w", err)
		}
	}

	if a.WebUiDomainList != nil {
		object["web_ui_domain_list"], err = json.Marshal(a.WebUiDomainList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_domain_list': %w", err)
		}
	}

	if a.WebUiHostHeaderValidationEnabled != nil {
		object["web_ui_host_header_validation_enabled"], err = json.Marshal(a.WebUiHostHeaderValidationEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_host_header_validation_enabled': %w", err)
		}
	}

	if a.WebUiHttpsCertPath != nil {
		object["web_ui_https_cert_path"], err = json.Marshal(a.WebUiHttpsCertPath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_https_cert_path': %w", err)
		}
	}

	if a.WebUiHttpsKeyPath != nil {
		object["web_ui_https_key_path"], err = json.Marshal(a.WebUiHttpsKeyPath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_https_key_path': %w", err)
		}
	}

	if a.WebUiMaxAuthFailCount != nil {
		object["web_ui_max_auth_fail_count"], err = json.Marshal(a.WebUiMaxAuthFailCount)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_max_auth_fail_count': %w", err)
		}
	}

	if a.WebUiPort != nil {
		object["web_ui_port"], err = json.Marshal(a.WebUiPort)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_port': %w", err)
		}
	}

	if a.WebUiSecureCookieEnabled != nil {
		object["web_ui_secure_cookie_enabled"], err = json.Marshal(a.WebUiSecureCookieEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_secure_cookie_enabled': %w", err)
		}
	}

	if a.WebUiSessionTimeout != nil {
		object["web_ui_session_timeout"], err = json.Marshal(a.WebUiSessionTimeout)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_session_timeout': %w", err)
		}
	}

	if a.WebUiUpnp != nil {
		object["web_ui_upnp"], err = json.Marshal(a.WebUiUpnp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_upnp': %w", err)
		}
	}

	if a.WebUiUseCustomHttpHeadersEnabled != nil {
		object["web_ui_use_custom_http_headers_enabled"], err = json.Marshal(a.WebUiUseCustomHttpHeadersEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_use_custom_http_headers_enabled': %w", err)
		}
	}

	if a.WebUiUsername != nil {
		object["web_ui_username"], err = json.Marshal(a.WebUiUsername)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_username': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SetPreferences. Returns the specified
// element and whether it was found
func (a SetPreferences) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SetPreferences
func (a *SetPreferences) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SetPreferences to handle AdditionalProperties
func (a *SetPreferences) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["add_trackers"]; found {
		err = json.Unmarshal(raw, &a.AddTrackers)
		if err != nil {
			return fmt.Errorf("error reading 'add_trackers': %w", err)
		}
		delete(object, "add_trackers")
	}

	if raw, found := object["add_trackers_enabled"]; found {
		err = json.Unmarshal(raw, &a.AddTrackersEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'add_trackers_enabled': %w", err)
		}
		delete(object, "add_trackers_enabled")
	}

	if raw, found := object["alt_dl_limit"]; found {
		err = json.Unmarshal(raw, &a.AltDlLimit)
		if err != nil {
			return fmt.Errorf("error reading 'alt_dl_limit': %w", err)
		}
		delete(object, "alt_dl_limit")
	}

	if raw, found := object["alt_up_limit"]; found {
		err = json.Unmarshal(raw, &a.AltUpLimit)
		if err != nil {
			return fmt.Errorf("error reading 'alt_up_limit': %w", err)
		}
		delete(object, "alt_up_limit")
	}

	if raw, found := object["alternative_webui_enabled"]; found {
		err = json.Unmarshal(raw, &a.AlternativeWebuiEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'alternative_webui_enabled': %w", err)
		}
		delete(object, "alternative_webui_enabled")
	}

	if raw, found := object["alternative_webui_path"]; found {
		err = json.Unmarshal(raw, &a.AlternativeWebuiPath)
		if err != nil {
			return fmt.Errorf("error reading 'alternative_webui_path': %w", err)
		}
		delete(object, "alternative_webui_path")
	}

	if raw, found := object["announce_ip"]; found {
		err = json.Unmarshal(raw, &a.AnnounceIp)
		if err != nil {
			return fmt.Errorf("error reading 'announce_ip': %w", err)
		}
		delete(object, "announce_ip")
	}

	if raw, found := object["announce_to_all_tiers"]; found {
		err = json.Unmarshal(raw, &a.AnnounceToAllTiers)
		if err != nil {
			return fmt.Errorf("error reading 'announce_to_all_tiers': %w", err)
		}
		delete(object, "announce_to_all_tiers")
	}

	if raw, found := object["announce_to_all_trackers"]; found {
		err = json.Unmarshal(raw, &a.AnnounceToAllTrackers)
		if err != nil {
			return fmt.Errorf("error reading 'announce_to_all_trackers': %w", err)
		}
		delete(object, "announce_to_all_trackers")
	}

	if raw, found := object["anonymous_mode"]; found {
		err = json.Unmarshal(raw, &a.AnonymousMode)
		if err != nil {
			return fmt.Errorf("error reading 'anonymous_mode': %w", err)
		}
		delete(object, "anonymous_mode")
	}

	if raw, found := object["async_io_threads"]; found {
		err = json.Unmarshal(raw, &a.AsyncIoThreads)
		if err != nil {
			return fmt.Errorf("error reading 'async_io_threads': %w", err)
		}
		delete(object, "async_io_threads")
	}

	if raw, found := object["auto_delete_mode"]; found {
		err = json.Unmarshal(raw, &a.AutoDeleteMode)
		if err != nil {
			return fmt.Errorf("error reading 'auto_delete_mode': %w", err)
		}
		delete(object, "auto_delete_mode")
	}

	if raw, found := object["auto_tmm_enabled"]; found {
		err = json.Unmarshal(raw, &a.AutoTmmEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'auto_tmm_enabled': %w", err)
		}
		delete(object, "auto_tmm_enabled")
	}

	if raw, found := object["autorun_enabled"]; found {
		err = json.Unmarshal(raw, &a.AutorunEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'autorun_enabled': %w", err)
		}
		delete(object, "autorun_enabled")
	}

	if raw, found := object["autorun_program"]; found {
		err = json.Unmarshal(raw, &a.AutorunProgram)
		if err != nil {
			return fmt.Errorf("error reading 'autorun_program': %w", err)
		}
		delete(object, "autorun_program")
	}

	if raw, found := object["banned_IPs"]; found {
		err = json.Unmarshal(raw, &a.BannedIPs)
		if err != nil {
			return fmt.Errorf("error reading 'banned_IPs': %w", err)
		}
		delete(object, "banned_IPs")
	}

	if raw, found := object["bittorrent_protocol"]; found {
		err = json.Unmarshal(raw, &a.BittorrentProtocol)
		if err != nil {
			return fmt.Errorf("error reading 'bittorrent_protocol': %w", err)
		}
		delete(object, "bittorrent_protocol")
	}

	if raw, found := object["bypass_auth_subnet_whitelist"]; found {
		err = json.Unmarshal(raw, &a.BypassAuthSubnetWhitelist)
		if err != nil {
			return fmt.Errorf("error reading 'bypass_auth_subnet_whitelist': %w", err)
		}
		delete(object, "bypass_auth_subnet_whitelist")
	}

	if raw, found := object["bypass_auth_subnet_whitelist_enabled"]; found {
		err = json.Unmarshal(raw, &a.BypassAuthSubnetWhitelistEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'bypass_auth_subnet_whitelist_enabled': %w", err)
		}
		delete(object, "bypass_auth_subnet_whitelist_enabled")
	}

	if raw, found := object["bypass_local_auth"]; found {
		err = json.Unmarshal(raw, &a.BypassLocalAuth)
		if err != nil {
			return fmt.Errorf("error reading 'bypass_local_auth': %w", err)
		}
		delete(object, "bypass_local_auth")
	}

	if raw, found := object["category_changed_tmm_enabled"]; found {
		err = json.Unmarshal(raw, &a.CategoryChangedTmmEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'category_changed_tmm_enabled': %w", err)
		}
		delete(object, "category_changed_tmm_enabled")
	}

	if raw, found := object["checking_memory_use"]; found {
		err = json.Unmarshal(raw, &a.CheckingMemoryUse)
		if err != nil {
			return fmt.Errorf("error reading 'checking_memory_use': %w", err)
		}
		delete(object, "checking_memory_use")
	}

	if raw, found := object["create_subfolder_enabled"]; found {
		err = json.Unmarshal(raw, &a.CreateSubfolderEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'create_subfolder_enabled': %w", err)
		}
		delete(object, "create_subfolder_enabled")
	}

	if raw, found := object["current_interface_address"]; found {
		err = json.Unmarshal(raw, &a.CurrentInterfaceAddress)
		if err != nil {
			return fmt.Errorf("error reading 'current_interface_address': %w", err)
		}
		delete(object, "current_interface_address")
	}

	if raw, found := object["current_network_interface"]; found {
		err = json.Unmarshal(raw, &a.CurrentNetworkInterface)
		if err != nil {
			return fmt.Errorf("error reading 'current_network_interface': %w", err)
		}
		delete(object, "current_network_interface")
	}

	if raw, found := object["dht"]; found {
		err = json.Unmarshal(raw, &a.Dht)
		if err != nil {
			return fmt.Errorf("error reading 'dht': %w", err)
		}
		delete(object, "dht")
	}

	if raw, found := object["disk_cache"]; found {
		err = json.Unmarshal(raw, &a.DiskCache)
		if err != nil {
			return fmt.Errorf("error reading 'disk_cache': %w", err)
		}
		delete(object, "disk_cache")
	}

	if raw, found := object["disk_cache_ttl"]; found {
		err = json.Unmarshal(raw, &a.DiskCacheTtl)
		if err != nil {
			return fmt.Errorf("error reading 'disk_cache_ttl': %w", err)
		}
		delete(object, "disk_cache_ttl")
	}

	if raw, found := object["dl_limit"]; found {
		err = json.Unmarshal(raw, &a.DlLimit)
		if err != nil {
			return fmt.Errorf("error reading 'dl_limit': %w", err)
		}
		delete(object, "dl_limit")
	}

	if raw, found := object["dont_count_slow_torrents"]; found {
		err = json.Unmarshal(raw, &a.DontCountSlowTorrents)
		if err != nil {
			return fmt.Errorf("error reading 'dont_count_slow_torrents': %w", err)
		}
		delete(object, "dont_count_slow_torrents")
	}

	if raw, found := object["dyndns_domain"]; found {
		err = json.Unmarshal(raw, &a.DyndnsDomain)
		if err != nil {
			return fmt.Errorf("error reading 'dyndns_domain': %w", err)
		}
		delete(object, "dyndns_domain")
	}

	if raw, found := object["dyndns_enabled"]; found {
		err = json.Unmarshal(raw, &a.DyndnsEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'dyndns_enabled': %w", err)
		}
		delete(object, "dyndns_enabled")
	}

	if raw, found := object["dyndns_password"]; found {
		err = json.Unmarshal(raw, &a.DyndnsPassword)
		if err != nil {
			return fmt.Errorf("error reading 'dyndns_password': %w", err)
		}
		delete(object, "dyndns_password")
	}

	if raw, found := object["dyndns_service"]; found {
		err = json.Unmarshal(raw, &a.DyndnsService)
		if err != nil {
			return fmt.Errorf("error reading 'dyndns_service': %w", err)
		}
		delete(object, "dyndns_service")
	}

	if raw, found := object["dyndns_username"]; found {
		err = json.Unmarshal(raw, &a.DyndnsUsername)
		if err != nil {
			return fmt.Errorf("error reading 'dyndns_username': %w", err)
		}
		delete(object, "dyndns_username")
	}

	if raw, found := object["embedded_tracker_port"]; found {
		err = json.Unmarshal(raw, &a.EmbeddedTrackerPort)
		if err != nil {
			return fmt.Errorf("error reading 'embedded_tracker_port': %w", err)
		}
		delete(object, "embedded_tracker_port")
	}

	if raw, found := object["enable_coalesce_read_write"]; found {
		err = json.Unmarshal(raw, &a.EnableCoalesceReadWrite)
		if err != nil {
			return fmt.Errorf("error reading 'enable_coalesce_read_write': %w", err)
		}
		delete(object, "enable_coalesce_read_write")
	}

	if raw, found := object["enable_embedded_tracker"]; found {
		err = json.Unmarshal(raw, &a.EnableEmbeddedTracker)
		if err != nil {
			return fmt.Errorf("error reading 'enable_embedded_tracker': %w", err)
		}
		delete(object, "enable_embedded_tracker")
	}

	if raw, found := object["enable_multi_connections_from_same_ip"]; found {
		err = json.Unmarshal(raw, &a.EnableMultiConnectionsFromSameIp)
		if err != nil {
			return fmt.Errorf("error reading 'enable_multi_connections_from_same_ip': %w", err)
		}
		delete(object, "enable_multi_connections_from_same_ip")
	}

	if raw, found := object["enable_os_cache"]; found {
		err = json.Unmarshal(raw, &a.EnableOsCache)
		if err != nil {
			return fmt.Errorf("error reading 'enable_os_cache': %w", err)
		}
		delete(object, "enable_os_cache")
	}

	if raw, found := object["enable_piece_extent_affinity"]; found {
		err = json.Unmarshal(raw, &a.EnablePieceExtentAffinity)
		if err != nil {
			return fmt.Errorf("error reading 'enable_piece_extent_affinity': %w", err)
		}
		delete(object, "enable_piece_extent_affinity")
	}

	if raw, found := object["enable_upload_suggestions"]; found {
		err = json.Unmarshal(raw, &a.EnableUploadSuggestions)
		if err != nil {
			return fmt.Errorf("error reading 'enable_upload_suggestions': %w", err)
		}
		delete(object, "enable_upload_suggestions")
	}

	if raw, found := object["encryption"]; found {
		err = json.Unmarshal(raw, &a.Encryption)
		if err != nil {
			return fmt.Errorf("error reading 'encryption': %w", err)
		}
		delete(object, "encryption")
	}

	if raw, found := object["export_dir"]; found {
		err = json.Unmarshal(raw, &a.ExportDir)
		if err != nil {
			return fmt.Errorf("error reading 'export_dir': %w", err)
		}
		delete(object, "export_dir")
	}

	if raw, found := object["export_dir_fin"]; found {
		err = json.Unmarshal(raw, &a.ExportDirFin)
		if err != nil {
			return fmt.Errorf("error reading 'export_dir_fin': %w", err)
		}
		delete(object, "export_dir_fin")
	}

	if raw, found := object["file_pool_size"]; found {
		err = json.Unmarshal(raw, &a.FilePoolSize)
		if err != nil {
			return fmt.Errorf("error reading 'file_pool_size': %w", err)
		}
		delete(object, "file_pool_size")
	}

	if raw, found := object["incomplete_files_ext"]; found {
		err = json.Unmarshal(raw, &a.IncompleteFilesExt)
		if err != nil {
			return fmt.Errorf("error reading 'incomplete_files_ext': %w", err)
		}
		delete(object, "incomplete_files_ext")
	}

	if raw, found := object["ip_filter_enabled"]; found {
		err = json.Unmarshal(raw, &a.IpFilterEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'ip_filter_enabled': %w", err)
		}
		delete(object, "ip_filter_enabled")
	}

	if raw, found := object["ip_filter_path"]; found {
		err = json.Unmarshal(raw, &a.IpFilterPath)
		if err != nil {
			return fmt.Errorf("error reading 'ip_filter_path': %w", err)
		}
		delete(object, "ip_filter_path")
	}

	if raw, found := object["ip_filter_trackers"]; found {
		err = json.Unmarshal(raw, &a.IpFilterTrackers)
		if err != nil {
			return fmt.Errorf("error reading 'ip_filter_trackers': %w", err)
		}
		delete(object, "ip_filter_trackers")
	}

	if raw, found := object["limit_lan_peers"]; found {
		err = json.Unmarshal(raw, &a.LimitLanPeers)
		if err != nil {
			return fmt.Errorf("error reading 'limit_lan_peers': %w", err)
		}
		delete(object, "limit_lan_peers")
	}

	if raw, found := object["limit_tcp_overhead"]; found {
		err = json.Unmarshal(raw, &a.LimitTcpOverhead)
		if err != nil {
			return fmt.Errorf("error reading 'limit_tcp_overhead': %w", err)
		}
		delete(object, "limit_tcp_overhead")
	}

	if raw, found := object["limit_utp_rate"]; found {
		err = json.Unmarshal(raw, &a.LimitUtpRate)
		if err != nil {
			return fmt.Errorf("error reading 'limit_utp_rate': %w", err)
		}
		delete(object, "limit_utp_rate")
	}

	if raw, found := object["listen_port"]; found {
		err = json.Unmarshal(raw, &a.ListenPort)
		if err != nil {
			return fmt.Errorf("error reading 'listen_port': %w", err)
		}
		delete(object, "listen_port")
	}

	if raw, found := object["locale"]; found {
		err = json.Unmarshal(raw, &a.Locale)
		if err != nil {
			return fmt.Errorf("error reading 'locale': %w", err)
		}
		delete(object, "locale")
	}

	if raw, found := object["lsd"]; found {
		err = json.Unmarshal(raw, &a.Lsd)
		if err != nil {
			return fmt.Errorf("error reading 'lsd': %w", err)
		}
		delete(object, "lsd")
	}

	if raw, found := object["mail_notification_auth_enabled"]; found {
		err = json.Unmarshal(raw, &a.MailNotificationAuthEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'mail_notification_auth_enabled': %w", err)
		}
		delete(object, "mail_notification_auth_enabled")
	}

	if raw, found := object["mail_notification_email"]; found {
		err = json.Unmarshal(raw, &a.MailNotificationEmail)
		if err != nil {
			return fmt.Errorf("error reading 'mail_notification_email': %w", err)
		}
		delete(object, "mail_notification_email")
	}

	if raw, found := object["mail_notification_enabled"]; found {
		err = json.Unmarshal(raw, &a.MailNotificationEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'mail_notification_enabled': %w", err)
		}
		delete(object, "mail_notification_enabled")
	}

	if raw, found := object["mail_notification_password"]; found {
		err = json.Unmarshal(raw, &a.MailNotificationPassword)
		if err != nil {
			return fmt.Errorf("error reading 'mail_notification_password': %w", err)
		}
		delete(object, "mail_notification_password")
	}

	if raw, found := object["mail_notification_sender"]; found {
		err = json.Unmarshal(raw, &a.MailNotificationSender)
		if err != nil {
			return fmt.Errorf("error reading 'mail_notification_sender': %w", err)
		}
		delete(object, "mail_notification_sender")
	}

	if raw, found := object["mail_notification_smtp"]; found {
		err = json.Unmarshal(raw, &a.MailNotificationSmtp)
		if err != nil {
			return fmt.Errorf("error reading 'mail_notification_smtp': %w", err)
		}
		delete(object, "mail_notification_smtp")
	}

	if raw, found := object["mail_notification_ssl_enabled"]; found {
		err = json.Unmarshal(raw, &a.MailNotificationSslEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'mail_notification_ssl_enabled': %w", err)
		}
		delete(object, "mail_notification_ssl_enabled")
	}

	if raw, found := object["mail_notification_username"]; found {
		err = json.Unmarshal(raw, &a.MailNotificationUsername)
		if err != nil {
			return fmt.Errorf("error reading 'mail_notification_username': %w", err)
		}
		delete(object, "mail_notification_username")
	}

	if raw, found := object["max_active_downloads"]; found {
		err = json.Unmarshal(raw, &a.MaxActiveDownloads)
		if err != nil {
			return fmt.Errorf("error reading 'max_active_downloads': %w", err)
		}
		delete(object, "max_active_downloads")
	}

	if raw, found := object["max_active_torrents"]; found {
		err = json.Unmarshal(raw, &a.MaxActiveTorrents)
		if err != nil {
			return fmt.Errorf("error reading 'max_active_torrents': %w", err)
		}
		delete(object, "max_active_torrents")
	}

	if raw, found := object["max_active_uploads"]; found {
		err = json.Unmarshal(raw, &a.MaxActiveUploads)
		if err != nil {
			return fmt.Errorf("error reading 'max_active_uploads': %w", err)
		}
		delete(object, "max_active_uploads")
	}

	if raw, found := object["max_connec"]; found {
		err = json.Unmarshal(raw, &a.MaxConnec)
		if err != nil {
			return fmt.Errorf("error reading 'max_connec': %w", err)
		}
		delete(object, "max_connec")
	}

	if raw, found := object["max_connec_per_torrent"]; found {
		err = json.Unmarshal(raw, &a.MaxConnecPerTorrent)
		if err != nil {
			return fmt.Errorf("error reading 'max_connec_per_torrent': %w", err)
		}
		delete(object, "max_connec_per_torrent")
	}

	if raw, found := object["max_ratio"]; found {
		err = json.Unmarshal(raw, &a.MaxRatio)
		if err != nil {
			return fmt.Errorf("error reading 'max_ratio': %w", err)
		}
		delete(object, "max_ratio")
	}

	if raw, found := object["max_ratio_act"]; found {
		err = json.Unmarshal(raw, &a.MaxRatioAct)
		if err != nil {
			return fmt.Errorf("error reading 'max_ratio_act': %w", err)
		}
		delete(object, "max_ratio_act")
	}

	if raw, found := object["max_ratio_enabled"]; found {
		err = json.Unmarshal(raw, &a.MaxRatioEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'max_ratio_enabled': %w", err)
		}
		delete(object, "max_ratio_enabled")
	}

	if raw, found := object["max_seeding_time"]; found {
		err = json.Unmarshal(raw, &a.MaxSeedingTime)
		if err != nil {
			return fmt.Errorf("error reading 'max_seeding_time': %w", err)
		}
		delete(object, "max_seeding_time")
	}

	if raw, found := object["max_seeding_time_enabled"]; found {
		err = json.Unmarshal(raw, &a.MaxSeedingTimeEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'max_seeding_time_enabled': %w", err)
		}
		delete(object, "max_seeding_time_enabled")
	}

	if raw, found := object["max_uploads"]; found {
		err = json.Unmarshal(raw, &a.MaxUploads)
		if err != nil {
			return fmt.Errorf("error reading 'max_uploads': %w", err)
		}
		delete(object, "max_uploads")
	}

	if raw, found := object["max_uploads_per_torrent"]; found {
		err = json.Unmarshal(raw, &a.MaxUploadsPerTorrent)
		if err != nil {
			return fmt.Errorf("error reading 'max_uploads_per_torrent': %w", err)
		}
		delete(object, "max_uploads_per_torrent")
	}

	if raw, found := object["outgoing_ports_max"]; found {
		err = json.Unmarshal(raw, &a.OutgoingPortsMax)
		if err != nil {
			return fmt.Errorf("error reading 'outgoing_ports_max': %w", err)
		}
		delete(object, "outgoing_ports_max")
	}

	if raw, found := object["outgoing_ports_min"]; found {
		err = json.Unmarshal(raw, &a.OutgoingPortsMin)
		if err != nil {
			return fmt.Errorf("error reading 'outgoing_ports_min': %w", err)
		}
		delete(object, "outgoing_ports_min")
	}

	if raw, found := object["pex"]; found {
		err = json.Unmarshal(raw, &a.Pex)
		if err != nil {
			return fmt.Errorf("error reading 'pex': %w", err)
		}
		delete(object, "pex")
	}

	if raw, found := object["preallocate_all"]; found {
		err = json.Unmarshal(raw, &a.PreallocateAll)
		if err != nil {
			return fmt.Errorf("error reading 'preallocate_all': %w", err)
		}
		delete(object, "preallocate_all")
	}

	if raw, found := object["proxy_auth_enabled"]; found {
		err = json.Unmarshal(raw, &a.ProxyAuthEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_auth_enabled': %w", err)
		}
		delete(object, "proxy_auth_enabled")
	}

	if raw, found := object["proxy_ip"]; found {
		err = json.Unmarshal(raw, &a.ProxyIp)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_ip': %w", err)
		}
		delete(object, "proxy_ip")
	}

	if raw, found := object["proxy_password"]; found {
		err = json.Unmarshal(raw, &a.ProxyPassword)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_password': %w", err)
		}
		delete(object, "proxy_password")
	}

	if raw, found := object["proxy_peer_connections"]; found {
		err = json.Unmarshal(raw, &a.ProxyPeerConnections)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_peer_connections': %w", err)
		}
		delete(object, "proxy_peer_connections")
	}

	if raw, found := object["proxy_port"]; found {
		err = json.Unmarshal(raw, &a.ProxyPort)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_port': %w", err)
		}
		delete(object, "proxy_port")
	}

	if raw, found := object["proxy_torrents_only"]; found {
		err = json.Unmarshal(raw, &a.ProxyTorrentsOnly)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_torrents_only': %w", err)
		}
		delete(object, "proxy_torrents_only")
	}

	if raw, found := object["proxy_type"]; found {
		err = json.Unmarshal(raw, &a.ProxyType)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_type': %w", err)
		}
		delete(object, "proxy_type")
	}

	if raw, found := object["proxy_username"]; found {
		err = json.Unmarshal(raw, &a.ProxyUsername)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_username': %w", err)
		}
		delete(object, "proxy_username")
	}

	if raw, found := object["queueing_enabled"]; found {
		err = json.Unmarshal(raw, &a.QueueingEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'queueing_enabled': %w", err)
		}
		delete(object, "queueing_enabled")
	}

	if raw, found := object["random_port"]; found {
		err = json.Unmarshal(raw, &a.RandomPort)
		if err != nil {
			return fmt.Errorf("error reading 'random_port': %w", err)
		}
		delete(object, "random_port")
	}

	if raw, found := object["recheck_completed_torrents"]; found {
		err = json.Unmarshal(raw, &a.RecheckCompletedTorrents)
		if err != nil {
			return fmt.Errorf("error reading 'recheck_completed_torrents': %w", err)
		}
		delete(object, "recheck_completed_torrents")
	}

	if raw, found := object["resolve_peer_countries"]; found {
		err = json.Unmarshal(raw, &a.ResolvePeerCountries)
		if err != nil {
			return fmt.Errorf("error reading 'resolve_peer_countries': %w", err)
		}
		delete(object, "resolve_peer_countries")
	}

	if raw, found := object["rss_auto_downloading_enabled"]; found {
		err = json.Unmarshal(raw, &a.RssAutoDownloadingEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'rss_auto_downloading_enabled': %w", err)
		}
		delete(object, "rss_auto_downloading_enabled")
	}

	if raw, found := object["rss_download_repack_proper_episodes"]; found {
		err = json.Unmarshal(raw, &a.RssDownloadRepackProperEpisodes)
		if err != nil {
			return fmt.Errorf("error reading 'rss_download_repack_proper_episodes': %w", err)
		}
		delete(object, "rss_download_repack_proper_episodes")
	}

	if raw, found := object["rss_max_articles_per_feed"]; found {
		err = json.Unmarshal(raw, &a.RssMaxArticlesPerFeed)
		if err != nil {
			return fmt.Errorf("error reading 'rss_max_articles_per_feed': %w", err)
		}
		delete(object, "rss_max_articles_per_feed")
	}

	if raw, found := object["rss_processing_enabled"]; found {
		err = json.Unmarshal(raw, &a.RssProcessingEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'rss_processing_enabled': %w", err)
		}
		delete(object, "rss_processing_enabled")
	}

	if raw, found := object["rss_refresh_interval"]; found {
		err = json.Unmarshal(raw, &a.RssRefreshInterval)
		if err != nil {
			return fmt.Errorf("error reading 'rss_refresh_interval': %w", err)
		}
		delete(object, "rss_refresh_interval")
	}

	if raw, found := object["rss_smart_episode_filters"]; found {
		err = json.Unmarshal(raw, &a.RssSmartEpisodeFilters)
		if err != nil {
			return fmt.Errorf("error reading 'rss_smart_episode_filters': %w", err)
		}
		delete(object, "rss_smart_episode_filters")
	}

	if raw, found := object["save_path"]; found {
		err = json.Unmarshal(raw, &a.SavePath)
		if err != nil {
			return fmt.Errorf("error reading 'save_path': %w", err)
		}
		delete(object, "save_path")
	}

	if raw, found := object["save_path_changed_tmm_enabled"]; found {
		err = json.Unmarshal(raw, &a.SavePathChangedTmmEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'save_path_changed_tmm_enabled': %w", err)
		}
		delete(object, "save_path_changed_tmm_enabled")
	}

	if raw, found := object["save_resume_data_interval"]; found {
		err = json.Unmarshal(raw, &a.SaveResumeDataInterval)
		if err != nil {
			return fmt.Errorf("error reading 'save_resume_data_interval': %w", err)
		}
		delete(object, "save_resume_data_interval")
	}

	if raw, found := object["scan_dirs"]; found {
		err = json.Unmarshal(raw, &a.ScanDirs)
		if err != nil {
			return fmt.Errorf("error reading 'scan_dirs': %w", err)
		}
		delete(object, "scan_dirs")
	}

	if raw, found := object["schedule_from_hour"]; found {
		err = json.Unmarshal(raw, &a.ScheduleFromHour)
		if err != nil {
			return fmt.Errorf("error reading 'schedule_from_hour': %w", err)
		}
		delete(object, "schedule_from_hour")
	}

	if raw, found := object["schedule_from_min"]; found {
		err = json.Unmarshal(raw, &a.ScheduleFromMin)
		if err != nil {
			return fmt.Errorf("error reading 'schedule_from_min': %w", err)
		}
		delete(object, "schedule_from_min")
	}

	if raw, found := object["schedule_to_hour"]; found {
		err = json.Unmarshal(raw, &a.ScheduleToHour)
		if err != nil {
			return fmt.Errorf("error reading 'schedule_to_hour': %w", err)
		}
		delete(object, "schedule_to_hour")
	}

	if raw, found := object["schedule_to_min"]; found {
		err = json.Unmarshal(raw, &a.ScheduleToMin)
		if err != nil {
			return fmt.Errorf("error reading 'schedule_to_min': %w", err)
		}
		delete(object, "schedule_to_min")
	}

	if raw, found := object["scheduler_days"]; found {
		err = json.Unmarshal(raw, &a.SchedulerDays)
		if err != nil {
			return fmt.Errorf("error reading 'scheduler_days': %w", err)
		}
		delete(object, "scheduler_days")
	}

	if raw, found := object["scheduler_enabled"]; found {
		err = json.Unmarshal(raw, &a.SchedulerEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'scheduler_enabled': %w", err)
		}
		delete(object, "scheduler_enabled")
	}

	if raw, found := object["send_buffer_low_watermark"]; found {
		err = json.Unmarshal(raw, &a.SendBufferLowWatermark)
		if err != nil {
			return fmt.Errorf("error reading 'send_buffer_low_watermark': %w", err)
		}
		delete(object, "send_buffer_low_watermark")
	}

	if raw, found := object["send_buffer_watermark"]; found {
		err = json.Unmarshal(raw, &a.SendBufferWatermark)
		if err != nil {
			return fmt.Errorf("error reading 'send_buffer_watermark': %w", err)
		}
		delete(object, "send_buffer_watermark")
	}

	if raw, found := object["send_buffer_watermark_factor"]; found {
		err = json.Unmarshal(raw, &a.SendBufferWatermarkFactor)
		if err != nil {
			return fmt.Errorf("error reading 'send_buffer_watermark_factor': %w", err)
		}
		delete(object, "send_buffer_watermark_factor")
	}

	if raw, found := object["slow_torrent_dl_rate_threshold"]; found {
		err = json.Unmarshal(raw, &a.SlowTorrentDlRateThreshold)
		if err != nil {
			return fmt.Errorf("error reading 'slow_torrent_dl_rate_threshold': %w", err)
		}
		delete(object, "slow_torrent_dl_rate_threshold")
	}

	if raw, found := object["slow_torrent_inactive_timer"]; found {
		err = json.Unmarshal(raw, &a.SlowTorrentInactiveTimer)
		if err != nil {
			return fmt.Errorf("error reading 'slow_torrent_inactive_timer': %w", err)
		}
		delete(object, "slow_torrent_inactive_timer")
	}

	if raw, found := object["slow_torrent_ul_rate_threshold"]; found {
		err = json.Unmarshal(raw, &a.SlowTorrentUlRateThreshold)
		if err != nil {
			return fmt.Errorf("error reading 'slow_torrent_ul_rate_threshold': %w", err)
		}
		delete(object, "slow_torrent_ul_rate_threshold")
	}

	if raw, found := object["socket_backlog_size"]; found {
		err = json.Unmarshal(raw, &a.SocketBacklogSize)
		if err != nil {
			return fmt.Errorf("error reading 'socket_backlog_size': %w", err)
		}
		delete(object, "socket_backlog_size")
	}

	if raw, found := object["ssl_cert"]; found {
		err = json.Unmarshal(raw, &a.SslCert)
		if err != nil {
			return fmt.Errorf("error reading 'ssl_cert': %w", err)
		}
		delete(object, "ssl_cert")
	}

	if raw, found := object["ssl_key"]; found {
		err = json.Unmarshal(raw, &a.SslKey)
		if err != nil {
			return fmt.Errorf("error reading 'ssl_key': %w", err)
		}
		delete(object, "ssl_key")
	}

	if raw, found := object["start_paused_enabled"]; found {
		err = json.Unmarshal(raw, &a.StartPausedEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'start_paused_enabled': %w", err)
		}
		delete(object, "start_paused_enabled")
	}

	if raw, found := object["stop_tracker_timeout"]; found {
		err = json.Unmarshal(raw, &a.StopTrackerTimeout)
		if err != nil {
			return fmt.Errorf("error reading 'stop_tracker_timeout': %w", err)
		}
		delete(object, "stop_tracker_timeout")
	}

	if raw, found := object["temp_path"]; found {
		err = json.Unmarshal(raw, &a.TempPath)
		if err != nil {
			return fmt.Errorf("error reading 'temp_path': %w", err)
		}
		delete(object, "temp_path")
	}

	if raw, found := object["temp_path_enabled"]; found {
		err = json.Unmarshal(raw, &a.TempPathEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'temp_path_enabled': %w", err)
		}
		delete(object, "temp_path_enabled")
	}

	if raw, found := object["torrent_changed_tmm_enabled"]; found {
		err = json.Unmarshal(raw, &a.TorrentChangedTmmEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'torrent_changed_tmm_enabled': %w", err)
		}
		delete(object, "torrent_changed_tmm_enabled")
	}

	if raw, found := object["up_limit"]; found {
		err = json.Unmarshal(raw, &a.UpLimit)
		if err != nil {
			return fmt.Errorf("error reading 'up_limit': %w", err)
		}
		delete(object, "up_limit")
	}

	if raw, found := object["upload_choking_algorithm"]; found {
		err = json.Unmarshal(raw, &a.UploadChokingAlgorithm)
		if err != nil {
			return fmt.Errorf("error reading 'upload_choking_algorithm': %w", err)
		}
		delete(object, "upload_choking_algorithm")
	}

	if raw, found := object["upload_slots_behavior"]; found {
		err = json.Unmarshal(raw, &a.UploadSlotsBehavior)
		if err != nil {
			return fmt.Errorf("error reading 'upload_slots_behavior': %w", err)
		}
		delete(object, "upload_slots_behavior")
	}

	if raw, found := object["upnp"]; found {
		err = json.Unmarshal(raw, &a.Upnp)
		if err != nil {
			return fmt.Errorf("error reading 'upnp': %w", err)
		}
		delete(object, "upnp")
	}

	if raw, found := object["upnp_lease_duration"]; found {
		err = json.Unmarshal(raw, &a.UpnpLeaseDuration)
		if err != nil {
			return fmt.Errorf("error reading 'upnp_lease_duration': %w", err)
		}
		delete(object, "upnp_lease_duration")
	}

	if raw, found := object["use_https"]; found {
		err = json.Unmarshal(raw, &a.UseHttps)
		if err != nil {
			return fmt.Errorf("error reading 'use_https': %w", err)
		}
		delete(object, "use_https")
	}

	if raw, found := object["utp_tcp_mixed_mode"]; found {
		err = json.Unmarshal(raw, &a.UtpTcpMixedMode)
		if err != nil {
			return fmt.Errorf("error reading 'utp_tcp_mixed_mode': %w", err)
		}
		delete(object, "utp_tcp_mixed_mode")
	}

	if raw, found := object["web_ui_address"]; found {
		err = json.Unmarshal(raw, &a.WebUiAddress)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_address': %w", err)
		}
		delete(object, "web_ui_address")
	}

	if raw, found := object["web_ui_ban_duration"]; found {
		err = json.Unmarshal(raw, &a.WebUiBanDuration)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_ban_duration': %w", err)
		}
		delete(object, "web_ui_ban_duration")
	}

	if raw, found := object["web_ui_clickjacking_protection_enabled"]; found {
		err = json.Unmarshal(raw, &a.WebUiClickjackingProtectionEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_clickjacking_protection_enabled': %w", err)
		}
		delete(object, "web_ui_clickjacking_protection_enabled")
	}

	if raw, found := object["web_ui_csrf_protection_enabled"]; found {
		err = json.Unmarshal(raw, &a.WebUiCsrfProtectionEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_csrf_protection_enabled': %w", err)
		}
		delete(object, "web_ui_csrf_protection_enabled")
	}

	if raw, found := object["web_ui_custom_http_headers"]; found {
		err = json.Unmarshal(raw, &a.WebUiCustomHttpHeaders)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_custom_http_headers': %w", err)
		}
		delete(object, "web_ui_custom_http_headers")
	}

	if raw, found := object["web_ui_domain_list"]; found {
		err = json.Unmarshal(raw, &a.WebUiDomainList)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_domain_list': %w", err)
		}
		delete(object, "web_ui_domain_list")
	}

	if raw, found := object["web_ui_host_header_validation_enabled"]; found {
		err = json.Unmarshal(raw, &a.WebUiHostHeaderValidationEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_host_header_validation_enabled': %w", err)
		}
		delete(object, "web_ui_host_header_validation_enabled")
	}

	if raw, found := object["web_ui_https_cert_path"]; found {
		err = json.Unmarshal(raw, &a.WebUiHttpsCertPath)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_https_cert_path': %w", err)
		}
		delete(object, "web_ui_https_cert_path")
	}

	if raw, found := object["web_ui_https_key_path"]; found {
		err = json.Unmarshal(raw, &a.WebUiHttpsKeyPath)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_https_key_path': %w", err)
		}
		delete(object, "web_ui_https_key_path")
	}

	if raw, found := object["web_ui_max_auth_fail_count"]; found {
		err = json.Unmarshal(raw, &a.WebUiMaxAuthFailCount)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_max_auth_fail_count': %w", err)
		}
		delete(object, "web_ui_max_auth_fail_count")
	}

	if raw, found := object["web_ui_password"]; found {
		err = json.Unmarshal(raw, &a.WebUiPassword)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_password': %w", err)
		}
		delete(object, "web_ui_password")
	}

	if raw, found := object["web_ui_port"]; found {
		err = json.Unmarshal(raw, &a.WebUiPort)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_port': %w", err)
		}
		delete(object, "web_ui_port")
	}

	if raw, found := object["web_ui_secure_cookie_enabled"]; found {
		err = json.Unmarshal(raw, &a.WebUiSecureCookieEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_secure_cookie_enabled': %w", err)
		}
		delete(object, "web_ui_secure_cookie_enabled")
	}

	if raw, found := object["web_ui_session_timeout"]; found {
		err = json.Unmarshal(raw, &a.WebUiSessionTimeout)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_session_timeout': %w", err)
		}
		delete(object, "web_ui_session_timeout")
	}

	if raw, found := object["web_ui_upnp"]; found {
		err = json.Unmarshal(raw, &a.WebUiUpnp)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_upnp': %w", err)
		}
		delete(object, "web_ui_upnp")
	}

	if raw, found := object["web_ui_use_custom_http_headers_enabled"]; found {
		err = json.Unmarshal(raw, &a.WebUiUseCustomHttpHeadersEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_use_custom_http_headers_enabled': %w", err)
		}
		delete(object, "web_ui_use_custom_http_headers_enabled")
	}

	if raw, found := object["web_ui_username"]; found {
		err = json.Unmarshal(raw, &a.WebUiUsername)
		if err != nil {
			return fmt.Errorf("error reading 'web_ui_username': %w", err)
		}
		delete(object, "web_ui_username")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SetPreferences to handle AdditionalProperties
func (a SetPreferences) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AddTrackers != nil {
		object["add_trackers"], err = json.Marshal(a.AddTrackers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'add_trackers': %w", err)
		}
	}

	if a.AddTrackersEnabled != nil {
		object["add_trackers_enabled"], err = json.Marshal(a.AddTrackersEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'add_trackers_enabled': %w", err)
		}
	}

	if a.AltDlLimit != nil {
		object["alt_dl_limit"], err = json.Marshal(a.AltDlLimit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'alt_dl_limit': %w", err)
		}
	}

	if a.AltUpLimit != nil {
		object["alt_up_limit"], err = json.Marshal(a.AltUpLimit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'alt_up_limit': %w", err)
		}
	}

	if a.AlternativeWebuiEnabled != nil {
		object["alternative_webui_enabled"], err = json.Marshal(a.AlternativeWebuiEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'alternative_webui_enabled': %w", err)
		}
	}

	if a.AlternativeWebuiPath != nil {
		object["alternative_webui_path"], err = json.Marshal(a.AlternativeWebuiPath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'alternative_webui_path': %w", err)
		}
	}

	if a.AnnounceIp != nil {
		object["announce_ip"], err = json.Marshal(a.AnnounceIp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'announce_ip': %w", err)
		}
	}

	if a.AnnounceToAllTiers != nil {
		object["announce_to_all_tiers"], err = json.Marshal(a.AnnounceToAllTiers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'announce_to_all_tiers': %w", err)
		}
	}

	if a.AnnounceToAllTrackers != nil {
		object["announce_to_all_trackers"], err = json.Marshal(a.AnnounceToAllTrackers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'announce_to_all_trackers': %w", err)
		}
	}

	if a.AnonymousMode != nil {
		object["anonymous_mode"], err = json.Marshal(a.AnonymousMode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'anonymous_mode': %w", err)
		}
	}

	if a.AsyncIoThreads != nil {
		object["async_io_threads"], err = json.Marshal(a.AsyncIoThreads)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'async_io_threads': %w", err)
		}
	}

	if a.AutoDeleteMode != nil {
		object["auto_delete_mode"], err = json.Marshal(a.AutoDeleteMode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'auto_delete_mode': %w", err)
		}
	}

	if a.AutoTmmEnabled != nil {
		object["auto_tmm_enabled"], err = json.Marshal(a.AutoTmmEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'auto_tmm_enabled': %w", err)
		}
	}

	if a.AutorunEnabled != nil {
		object["autorun_enabled"], err = json.Marshal(a.AutorunEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'autorun_enabled': %w", err)
		}
	}

	if a.AutorunProgram != nil {
		object["autorun_program"], err = json.Marshal(a.AutorunProgram)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'autorun_program': %w", err)
		}
	}

	if a.BannedIPs != nil {
		object["banned_IPs"], err = json.Marshal(a.BannedIPs)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'banned_IPs': %w", err)
		}
	}

	if a.BittorrentProtocol != nil {
		object["bittorrent_protocol"], err = json.Marshal(a.BittorrentProtocol)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'bittorrent_protocol': %w", err)
		}
	}

	if a.BypassAuthSubnetWhitelist != nil {
		object["bypass_auth_subnet_whitelist"], err = json.Marshal(a.BypassAuthSubnetWhitelist)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'bypass_auth_subnet_whitelist': %w", err)
		}
	}

	if a.BypassAuthSubnetWhitelistEnabled != nil {
		object["bypass_auth_subnet_whitelist_enabled"], err = json.Marshal(a.BypassAuthSubnetWhitelistEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'bypass_auth_subnet_whitelist_enabled': %w", err)
		}
	}

	if a.BypassLocalAuth != nil {
		object["bypass_local_auth"], err = json.Marshal(a.BypassLocalAuth)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'bypass_local_auth': %w", err)
		}
	}

	if a.CategoryChangedTmmEnabled != nil {
		object["category_changed_tmm_enabled"], err = json.Marshal(a.CategoryChangedTmmEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'category_changed_tmm_enabled': %w", err)
		}
	}

	if a.CheckingMemoryUse != nil {
		object["checking_memory_use"], err = json.Marshal(a.CheckingMemoryUse)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'checking_memory_use': %w", err)
		}
	}

	if a.CreateSubfolderEnabled != nil {
		object["create_subfolder_enabled"], err = json.Marshal(a.CreateSubfolderEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'create_subfolder_enabled': %w", err)
		}
	}

	if a.CurrentInterfaceAddress != nil {
		object["current_interface_address"], err = json.Marshal(a.CurrentInterfaceAddress)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'current_interface_address': %w", err)
		}
	}

	if a.CurrentNetworkInterface != nil {
		object["current_network_interface"], err = json.Marshal(a.CurrentNetworkInterface)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'current_network_interface': %w", err)
		}
	}

	if a.Dht != nil {
		object["dht"], err = json.Marshal(a.Dht)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dht': %w", err)
		}
	}

	if a.DiskCache != nil {
		object["disk_cache"], err = json.Marshal(a.DiskCache)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'disk_cache': %w", err)
		}
	}

	if a.DiskCacheTtl != nil {
		object["disk_cache_ttl"], err = json.Marshal(a.DiskCacheTtl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'disk_cache_ttl': %w", err)
		}
	}

	if a.DlLimit != nil {
		object["dl_limit"], err = json.Marshal(a.DlLimit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dl_limit': %w", err)
		}
	}

	if a.DontCountSlowTorrents != nil {
		object["dont_count_slow_torrents"], err = json.Marshal(a.DontCountSlowTorrents)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dont_count_slow_torrents': %w", err)
		}
	}

	if a.DyndnsDomain != nil {
		object["dyndns_domain"], err = json.Marshal(a.DyndnsDomain)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dyndns_domain': %w", err)
		}
	}

	if a.DyndnsEnabled != nil {
		object["dyndns_enabled"], err = json.Marshal(a.DyndnsEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dyndns_enabled': %w", err)
		}
	}

	if a.DyndnsPassword != nil {
		object["dyndns_password"], err = json.Marshal(a.DyndnsPassword)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dyndns_password': %w", err)
		}
	}

	if a.DyndnsService != nil {
		object["dyndns_service"], err = json.Marshal(a.DyndnsService)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dyndns_service': %w", err)
		}
	}

	if a.DyndnsUsername != nil {
		object["dyndns_username"], err = json.Marshal(a.DyndnsUsername)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dyndns_username': %w", err)
		}
	}

	if a.EmbeddedTrackerPort != nil {
		object["embedded_tracker_port"], err = json.Marshal(a.EmbeddedTrackerPort)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'embedded_tracker_port': %w", err)
		}
	}

	if a.EnableCoalesceReadWrite != nil {
		object["enable_coalesce_read_write"], err = json.Marshal(a.EnableCoalesceReadWrite)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enable_coalesce_read_write': %w", err)
		}
	}

	if a.EnableEmbeddedTracker != nil {
		object["enable_embedded_tracker"], err = json.Marshal(a.EnableEmbeddedTracker)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enable_embedded_tracker': %w", err)
		}
	}

	if a.EnableMultiConnectionsFromSameIp != nil {
		object["enable_multi_connections_from_same_ip"], err = json.Marshal(a.EnableMultiConnectionsFromSameIp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enable_multi_connections_from_same_ip': %w", err)
		}
	}

	if a.EnableOsCache != nil {
		object["enable_os_cache"], err = json.Marshal(a.EnableOsCache)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enable_os_cache': %w", err)
		}
	}

	if a.EnablePieceExtentAffinity != nil {
		object["enable_piece_extent_affinity"], err = json.Marshal(a.EnablePieceExtentAffinity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enable_piece_extent_affinity': %w", err)
		}
	}

	if a.EnableUploadSuggestions != nil {
		object["enable_upload_suggestions"], err = json.Marshal(a.EnableUploadSuggestions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enable_upload_suggestions': %w", err)
		}
	}

	if a.Encryption != nil {
		object["encryption"], err = json.Marshal(a.Encryption)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'encryption': %w", err)
		}
	}

	if a.ExportDir != nil {
		object["export_dir"], err = json.Marshal(a.ExportDir)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'export_dir': %w", err)
		}
	}

	if a.ExportDirFin != nil {
		object["export_dir_fin"], err = json.Marshal(a.ExportDirFin)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'export_dir_fin': %w", err)
		}
	}

	if a.FilePoolSize != nil {
		object["file_pool_size"], err = json.Marshal(a.FilePoolSize)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'file_pool_size': %w", err)
		}
	}

	if a.IncompleteFilesExt != nil {
		object["incomplete_files_ext"], err = json.Marshal(a.IncompleteFilesExt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'incomplete_files_ext': %w", err)
		}
	}

	if a.IpFilterEnabled != nil {
		object["ip_filter_enabled"], err = json.Marshal(a.IpFilterEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ip_filter_enabled': %w", err)
		}
	}

	if a.IpFilterPath != nil {
		object["ip_filter_path"], err = json.Marshal(a.IpFilterPath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ip_filter_path': %w", err)
		}
	}

	if a.IpFilterTrackers != nil {
		object["ip_filter_trackers"], err = json.Marshal(a.IpFilterTrackers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ip_filter_trackers': %w", err)
		}
	}

	if a.LimitLanPeers != nil {
		object["limit_lan_peers"], err = json.Marshal(a.LimitLanPeers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'limit_lan_peers': %w", err)
		}
	}

	if a.LimitTcpOverhead != nil {
		object["limit_tcp_overhead"], err = json.Marshal(a.LimitTcpOverhead)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'limit_tcp_overhead': %w", err)
		}
	}

	if a.LimitUtpRate != nil {
		object["limit_utp_rate"], err = json.Marshal(a.LimitUtpRate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'limit_utp_rate': %w", err)
		}
	}

	if a.ListenPort != nil {
		object["listen_port"], err = json.Marshal(a.ListenPort)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'listen_port': %w", err)
		}
	}

	if a.Locale != nil {
		object["locale"], err = json.Marshal(a.Locale)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'locale': %w", err)
		}
	}

	if a.Lsd != nil {
		object["lsd"], err = json.Marshal(a.Lsd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'lsd': %w", err)
		}
	}

	if a.MailNotificationAuthEnabled != nil {
		object["mail_notification_auth_enabled"], err = json.Marshal(a.MailNotificationAuthEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mail_notification_auth_enabled': %w", err)
		}
	}

	if a.MailNotificationEmail != nil {
		object["mail_notification_email"], err = json.Marshal(a.MailNotificationEmail)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mail_notification_email': %w", err)
		}
	}

	if a.MailNotificationEnabled != nil {
		object["mail_notification_enabled"], err = json.Marshal(a.MailNotificationEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mail_notification_enabled': %w", err)
		}
	}

	if a.MailNotificationPassword != nil {
		object["mail_notification_password"], err = json.Marshal(a.MailNotificationPassword)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mail_notification_password': %w", err)
		}
	}

	if a.MailNotificationSender != nil {
		object["mail_notification_sender"], err = json.Marshal(a.MailNotificationSender)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mail_notification_sender': %w", err)
		}
	}

	if a.MailNotificationSmtp != nil {
		object["mail_notification_smtp"], err = json.Marshal(a.MailNotificationSmtp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mail_notification_smtp': %w", err)
		}
	}

	if a.MailNotificationSslEnabled != nil {
		object["mail_notification_ssl_enabled"], err = json.Marshal(a.MailNotificationSslEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mail_notification_ssl_enabled': %w", err)
		}
	}

	if a.MailNotificationUsername != nil {
		object["mail_notification_username"], err = json.Marshal(a.MailNotificationUsername)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mail_notification_username': %w", err)
		}
	}

	if a.MaxActiveDownloads != nil {
		object["max_active_downloads"], err = json.Marshal(a.MaxActiveDownloads)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_active_downloads': %w", err)
		}
	}

	if a.MaxActiveTorrents != nil {
		object["max_active_torrents"], err = json.Marshal(a.MaxActiveTorrents)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_active_torrents': %w", err)
		}
	}

	if a.MaxActiveUploads != nil {
		object["max_active_uploads"], err = json.Marshal(a.MaxActiveUploads)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_active_uploads': %w", err)
		}
	}

	if a.MaxConnec != nil {
		object["max_connec"], err = json.Marshal(a.MaxConnec)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_connec': %w", err)
		}
	}

	if a.MaxConnecPerTorrent != nil {
		object["max_connec_per_torrent"], err = json.Marshal(a.MaxConnecPerTorrent)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_connec_per_torrent': %w", err)
		}
	}

	if a.MaxRatio != nil {
		object["max_ratio"], err = json.Marshal(a.MaxRatio)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_ratio': %w", err)
		}
	}

	if a.MaxRatioAct != nil {
		object["max_ratio_act"], err = json.Marshal(a.MaxRatioAct)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_ratio_act': %w", err)
		}
	}

	if a.MaxRatioEnabled != nil {
		object["max_ratio_enabled"], err = json.Marshal(a.MaxRatioEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_ratio_enabled': %w", err)
		}
	}

	if a.MaxSeedingTime != nil {
		object["max_seeding_time"], err = json.Marshal(a.MaxSeedingTime)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_seeding_time': %w", err)
		}
	}

	if a.MaxSeedingTimeEnabled != nil {
		object["max_seeding_time_enabled"], err = json.Marshal(a.MaxSeedingTimeEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_seeding_time_enabled': %w", err)
		}
	}

	if a.MaxUploads != nil {
		object["max_uploads"], err = json.Marshal(a.MaxUploads)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_uploads': %w", err)
		}
	}

	if a.MaxUploadsPerTorrent != nil {
		object["max_uploads_per_torrent"], err = json.Marshal(a.MaxUploadsPerTorrent)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'max_uploads_per_torrent': %w", err)
		}
	}

	if a.OutgoingPortsMax != nil {
		object["outgoing_ports_max"], err = json.Marshal(a.OutgoingPortsMax)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'outgoing_ports_max': %w", err)
		}
	}

	if a.OutgoingPortsMin != nil {
		object["outgoing_ports_min"], err = json.Marshal(a.OutgoingPortsMin)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'outgoing_ports_min': %w", err)
		}
	}

	if a.Pex != nil {
		object["pex"], err = json.Marshal(a.Pex)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pex': %w", err)
		}
	}

	if a.PreallocateAll != nil {
		object["preallocate_all"], err = json.Marshal(a.PreallocateAll)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'preallocate_all': %w", err)
		}
	}

	if a.ProxyAuthEnabled != nil {
		object["proxy_auth_enabled"], err = json.Marshal(a.ProxyAuthEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_auth_enabled': %w", err)
		}
	}

	if a.ProxyIp != nil {
		object["proxy_ip"], err = json.Marshal(a.ProxyIp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_ip': %w", err)
		}
	}

	if a.ProxyPassword != nil {
		object["proxy_password"], err = json.Marshal(a.ProxyPassword)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_password': %w", err)
		}
	}

	if a.ProxyPeerConnections != nil {
		object["proxy_peer_connections"], err = json.Marshal(a.ProxyPeerConnections)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_peer_connections': %w", err)
		}
	}

	if a.ProxyPort != nil {
		object["proxy_port"], err = json.Marshal(a.ProxyPort)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_port': %w", err)
		}
	}

	if a.ProxyTorrentsOnly != nil {
		object["proxy_torrents_only"], err = json.Marshal(a.ProxyTorrentsOnly)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_torrents_only': %w", err)
		}
	}

	if a.ProxyType != nil {
		object["proxy_type"], err = json.Marshal(a.ProxyType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_type': %w", err)
		}
	}

	if a.ProxyUsername != nil {
		object["proxy_username"], err = json.Marshal(a.ProxyUsername)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_username': %w", err)
		}
	}

	if a.QueueingEnabled != nil {
		object["queueing_enabled"], err = json.Marshal(a.QueueingEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'queueing_enabled': %w", err)
		}
	}

	if a.RandomPort != nil {
		object["random_port"], err = json.Marshal(a.RandomPort)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'random_port': %w", err)
		}
	}

	if a.RecheckCompletedTorrents != nil {
		object["recheck_completed_torrents"], err = json.Marshal(a.RecheckCompletedTorrents)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'recheck_completed_torrents': %w", err)
		}
	}

	if a.ResolvePeerCountries != nil {
		object["resolve_peer_countries"], err = json.Marshal(a.ResolvePeerCountries)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'resolve_peer_countries': %w", err)
		}
	}

	if a.RssAutoDownloadingEnabled != nil {
		object["rss_auto_downloading_enabled"], err = json.Marshal(a.RssAutoDownloadingEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'rss_auto_downloading_enabled': %w", err)
		}
	}

	if a.RssDownloadRepackProperEpisodes != nil {
		object["rss_download_repack_proper_episodes"], err = json.Marshal(a.RssDownloadRepackProperEpisodes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'rss_download_repack_proper_episodes': %w", err)
		}
	}

	if a.RssMaxArticlesPerFeed != nil {
		object["rss_max_articles_per_feed"], err = json.Marshal(a.RssMaxArticlesPerFeed)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'rss_max_articles_per_feed': %w", err)
		}
	}

	if a.RssProcessingEnabled != nil {
		object["rss_processing_enabled"], err = json.Marshal(a.RssProcessingEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'rss_processing_enabled': %w", err)
		}
	}

	if a.RssRefreshInterval != nil {
		object["rss_refresh_interval"], err = json.Marshal(a.RssRefreshInterval)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'rss_refresh_interval': %w", err)
		}
	}

	if a.RssSmartEpisodeFilters != nil {
		object["rss_smart_episode_filters"], err = json.Marshal(a.RssSmartEpisodeFilters)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'rss_smart_episode_filters': %w", err)
		}
	}

	if a.SavePath != nil {
		object["save_path"], err = json.Marshal(a.SavePath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'save_path': %w", err)
		}
	}

	if a.SavePathChangedTmmEnabled != nil {
		object["save_path_changed_tmm_enabled"], err = json.Marshal(a.SavePathChangedTmmEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'save_path_changed_tmm_enabled': %w", err)
		}
	}

	if a.SaveResumeDataInterval != nil {
		object["save_resume_data_interval"], err = json.Marshal(a.SaveResumeDataInterval)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'save_resume_data_interval': %w", err)
		}
	}

	if a.ScanDirs != nil {
		object["scan_dirs"], err = json.Marshal(a.ScanDirs)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'scan_dirs': %w", err)
		}
	}

	if a.ScheduleFromHour != nil {
		object["schedule_from_hour"], err = json.Marshal(a.ScheduleFromHour)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'schedule_from_hour': %w", err)
		}
	}

	if a.ScheduleFromMin != nil {
		object["schedule_from_min"], err = json.Marshal(a.ScheduleFromMin)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'schedule_from_min': %w", err)
		}
	}

	if a.ScheduleToHour != nil {
		object["schedule_to_hour"], err = json.Marshal(a.ScheduleToHour)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'schedule_to_hour': %w", err)
		}
	}

	if a.ScheduleToMin != nil {
		object["schedule_to_min"], err = json.Marshal(a.ScheduleToMin)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'schedule_to_min': %w", err)
		}
	}

	if a.SchedulerDays != nil {
		object["scheduler_days"], err = json.Marshal(a.SchedulerDays)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'scheduler_days': %w", err)
		}
	}

	if a.SchedulerEnabled != nil {
		object["scheduler_enabled"], err = json.Marshal(a.SchedulerEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'scheduler_enabled': %w", err)
		}
	}

	if a.SendBufferLowWatermark != nil {
		object["send_buffer_low_watermark"], err = json.Marshal(a.SendBufferLowWatermark)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'send_buffer_low_watermark': %w", err)
		}
	}

	if a.SendBufferWatermark != nil {
		object["send_buffer_watermark"], err = json.Marshal(a.SendBufferWatermark)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'send_buffer_watermark': %w", err)
		}
	}

	if a.SendBufferWatermarkFactor != nil {
		object["send_buffer_watermark_factor"], err = json.Marshal(a.SendBufferWatermarkFactor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'send_buffer_watermark_factor': %w", err)
		}
	}

	if a.SlowTorrentDlRateThreshold != nil {
		object["slow_torrent_dl_rate_threshold"], err = json.Marshal(a.SlowTorrentDlRateThreshold)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'slow_torrent_dl_rate_threshold': %w", err)
		}
	}

	if a.SlowTorrentInactiveTimer != nil {
		object["slow_torrent_inactive_timer"], err = json.Marshal(a.SlowTorrentInactiveTimer)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'slow_torrent_inactive_timer': %w", err)
		}
	}

	if a.SlowTorrentUlRateThreshold != nil {
		object["slow_torrent_ul_rate_threshold"], err = json.Marshal(a.SlowTorrentUlRateThreshold)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'slow_torrent_ul_rate_threshold': %w", err)
		}
	}

	if a.SocketBacklogSize != nil {
		object["socket_backlog_size"], err = json.Marshal(a.SocketBacklogSize)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'socket_backlog_size': %w", err)
		}
	}

	if a.SslCert != nil {
		object["ssl_cert"], err = json.Marshal(a.SslCert)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ssl_cert': %w", err)
		}
	}

	if a.SslKey != nil {
		object["ssl_key"], err = json.Marshal(a.SslKey)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ssl_key': %w", err)
		}
	}

	if a.StartPausedEnabled != nil {
		object["start_paused_enabled"], err = json.Marshal(a.StartPausedEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'start_paused_enabled': %w", err)
		}
	}

	if a.StopTrackerTimeout != nil {
		object["stop_tracker_timeout"], err = json.Marshal(a.StopTrackerTimeout)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stop_tracker_timeout': %w", err)
		}
	}

	if a.TempPath != nil {
		object["temp_path"], err = json.Marshal(a.TempPath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'temp_path': %w", err)
		}
	}

	if a.TempPathEnabled != nil {
		object["temp_path_enabled"], err = json.Marshal(a.TempPathEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'temp_path_enabled': %w", err)
		}
	}

	if a.TorrentChangedTmmEnabled != nil {
		object["torrent_changed_tmm_enabled"], err = json.Marshal(a.TorrentChangedTmmEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'torrent_changed_tmm_enabled': %w", err)
		}
	}

	if a.UpLimit != nil {
		object["up_limit"], err = json.Marshal(a.UpLimit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'up_limit': %w", err)
		}
	}

	if a.UploadChokingAlgorithm != nil {
		object["upload_choking_algorithm"], err = json.Marshal(a.UploadChokingAlgorithm)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'upload_choking_algorithm': %w", err)
		}
	}

	if a.UploadSlotsBehavior != nil {
		object["upload_slots_behavior"], err = json.Marshal(a.UploadSlotsBehavior)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'upload_slots_behavior': %w", err)
		}
	}

	if a.Upnp != nil {
		object["upnp"], err = json.Marshal(a.Upnp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'upnp': %w", err)
		}
	}

	if a.UpnpLeaseDuration != nil {
		object["upnp_lease_duration"], err = json.Marshal(a.UpnpLeaseDuration)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'upnp_lease_duration': %w", err)
		}
	}

	if a.UseHttps != nil {
		object["use_https"], err = json.Marshal(a.UseHttps)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'use_https': %w", err)
		}
	}

	if a.UtpTcpMixedMode != nil {
		object["utp_tcp_mixed_mode"], err = json.Marshal(a.UtpTcpMixedMode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'utp_tcp_mixed_mode': %w", err)
		}
	}

	if a.WebUiAddress != nil {
		object["web_ui_address"], err = json.Marshal(a.WebUiAddress)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_address': %w", err)
		}
	}

	if a.WebUiBanDuration != nil {
		object["web_ui_ban_duration"], err = json.Marshal(a.WebUiBanDuration)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_ban_duration': %w", err)
		}
	}

	if a.WebUiClickjackingProtectionEnabled != nil {
		object["web_ui_clickjacking_protection_enabled"], err = json.Marshal(a.WebUiClickjackingProtectionEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_clickjacking_protection_enabled': %w", err)
		}
	}

	if a.WebUiCsrfProtectionEnabled != nil {
		object["web_ui_csrf_protection_enabled"], err = json.Marshal(a.WebUiCsrfProtectionEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_csrf_protection_enabled': %w", err)
		}
	}

	if a.WebUiCustomHttpHeaders != nil {
		object["web_ui_custom_http_headers"], err = json.Marshal(a.WebUiCustomHttpHeaders)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_custom_http_headers': %w", err)
		}
	}

	if a.WebUiDomainList != nil {
		object["web_ui_domain_list"], err = json.Marshal(a.WebUiDomainList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_domain_list': %w", err)
		}
	}

	if a.WebUiHostHeaderValidationEnabled != nil {
		object["web_ui_host_header_validation_enabled"], err = json.Marshal(a.WebUiHostHeaderValidationEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_host_header_validation_enabled': %w", err)
		}
	}

	if a.WebUiHttpsCertPath != nil {
		object["web_ui_https_cert_path"], err = json.Marshal(a.WebUiHttpsCertPath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_https_cert_path': %w", err)
		}
	}

	if a.WebUiHttpsKeyPath != nil {
		object["web_ui_https_key_path"], err = json.Marshal(a.WebUiHttpsKeyPath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_https_key_path': %w", err)
		}
	}

	if a.WebUiMaxAuthFailCount != nil {
		object["web_ui_max_auth_fail_count"], err = json.Marshal(a.WebUiMaxAuthFailCount)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_max_auth_fail_count': %w", err)
		}
	}

	if a.WebUiPassword != nil {
		object["web_ui_password"], err = json.Marshal(a.WebUiPassword)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_password': %w", err)
		}
	}

	if a.WebUiPort != nil {
		object["web_ui_port"], err = json.Marshal(a.WebUiPort)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_port': %w", err)
		}
	}

	if a.WebUiSecureCookieEnabled != nil {
		object["web_ui_secure_cookie_enabled"], err = json.Marshal(a.WebUiSecureCookieEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_secure_cookie_enabled': %w", err)
		}
	}

	if a.WebUiSessionTimeout != nil {
		object["web_ui_session_timeout"], err = json.Marshal(a.WebUiSessionTimeout)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_session_timeout': %w", err)
		}
	}

	if a.WebUiUpnp != nil {
		object["web_ui_upnp"], err = json.Marshal(a.WebUiUpnp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_upnp': %w", err)
		}
	}

	if a.WebUiUseCustomHttpHeadersEnabled != nil {
		object["web_ui_use_custom_http_headers_enabled"], err = json.Marshal(a.WebUiUseCustomHttpHeadersEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_use_custom_http_headers_enabled': %w", err)
		}
	}

	if a.WebUiUsername != nil {
		object["web_ui_username"], err = json.Marshal(a.WebUiUsername)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'web_ui_username': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsPreferencesScanDirs0 returns the union data inside the Preferences_ScanDirs_AdditionalProperties as a PreferencesScanDirs0
func (t Preferences_ScanDirs_AdditionalProperties) AsPreferencesScanDirs0() (PreferencesScanDirs0, error) {
	var body PreferencesScanDirs0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreferencesScanDirs0 overwrites any union data inside the Preferences_ScanDirs_AdditionalProperties as the provided PreferencesScanDirs0
func (t *Preferences_ScanDirs_AdditionalProperties) FromPreferencesScanDirs0(v PreferencesScanDirs0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreferencesScanDirs0 performs a merge with any union data inside the Preferences_ScanDirs_AdditionalProperties, using the provided PreferencesScanDirs0
func (t *Preferences_ScanDirs_AdditionalProperties) MergePreferencesScanDirs0(v PreferencesScanDirs0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsPreferencesScanDirs1 returns the union data inside the Preferences_ScanDirs_AdditionalProperties as a PreferencesScanDirs1
func (t Preferences_ScanDirs_AdditionalProperties) AsPreferencesScanDirs1() (PreferencesScanDirs1, error) {
	var body PreferencesScanDirs1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreferencesScanDirs1 overwrites any union data inside the Preferences_ScanDirs_AdditionalProperties as the provided PreferencesScanDirs1
func (t *Preferences_ScanDirs_AdditionalProperties) FromPreferencesScanDirs1(v PreferencesScanDirs1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreferencesScanDirs1 performs a merge with any union data inside the Preferences_ScanDirs_AdditionalProperties, using the provided PreferencesScanDirs1
func (t *Preferences_ScanDirs_AdditionalProperties) MergePreferencesScanDirs1(v PreferencesScanDirs1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Preferences_ScanDirs_AdditionalProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Preferences_ScanDirs_AdditionalProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSetPreferencesScanDirs0 returns the union data inside the SetPreferences_ScanDirs_AdditionalProperties as a SetPreferencesScanDirs0
func (t SetPreferences_ScanDirs_AdditionalProperties) AsSetPreferencesScanDirs0() (SetPreferencesScanDirs0, error) {
	var body SetPreferencesScanDirs0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetPreferencesScanDirs0 overwrites any union data inside the SetPreferences_ScanDirs_AdditionalProperties as the provided SetPreferencesScanDirs0
func (t *SetPreferences_ScanDirs_AdditionalProperties) FromSetPreferencesScanDirs0(v SetPreferencesScanDirs0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetPreferencesScanDirs0 performs a merge with any union data inside the SetPreferences_ScanDirs_AdditionalProperties, using the provided SetPreferencesScanDirs0
func (t *SetPreferences_ScanDirs_AdditionalProperties) MergeSetPreferencesScanDirs0(v SetPreferencesScanDirs0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSetPreferencesScanDirs1 returns the union data inside the SetPreferences_ScanDirs_AdditionalProperties as a SetPreferencesScanDirs1
func (t SetPreferences_ScanDirs_AdditionalProperties) AsSetPreferencesScanDirs1() (SetPreferencesScanDirs1, error) {
	var body SetPreferencesScanDirs1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSetPreferencesScanDirs1 overwrites any union data inside the SetPreferences_ScanDirs_AdditionalProperties as the provided SetPreferencesScanDirs1
func (t *SetPreferences_ScanDirs_AdditionalProperties) FromSetPreferencesScanDirs1(v SetPreferencesScanDirs1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSetPreferencesScanDirs1 performs a merge with any union data inside the SetPreferences_ScanDirs_AdditionalProperties, using the provided SetPreferencesScanDirs1
func (t *SetPreferences_ScanDirs_AdditionalProperties) MergeSetPreferencesScanDirs1(v SetPreferencesScanDirs1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SetPreferences_ScanDirs_AdditionalProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SetPreferences_ScanDirs_AdditionalProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AppBuildInfoGet request
	AppBuildInfoGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppDefaultSavePathGet request
	AppDefaultSavePathGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppPreferencesGet request
	AppPreferencesGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppSetPreferencesPostWithBody request with any body
	AppSetPreferencesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AppSetPreferencesPostWithFormdataBody(ctx context.Context, body AppSetPreferencesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppShutdownGet request
	AppShutdownGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppVersionGet request
	AppVersionGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppWebapiVersionGet request
	AppWebapiVersionGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthLoginPostWithBody request with any body
	AuthLoginPostWithBody(ctx context.Context, params *AuthLoginPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthLoginPostWithFormdataBody(ctx context.Context, params *AuthLoginPostParams, body AuthLoginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthLogoutPost request
	AuthLogoutPost(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogMainPostWithBody request with any body
	LogMainPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LogMainPostWithFormdataBody(ctx context.Context, body LogMainPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogPeersPostWithBody request with any body
	LogPeersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LogPeersPostWithFormdataBody(ctx context.Context, body LogPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RssAddFeedPostWithBody request with any body
	RssAddFeedPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RssAddFeedPostWithFormdataBody(ctx context.Context, body RssAddFeedPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RssAddFolderPostWithBody request with any body
	RssAddFolderPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RssAddFolderPostWithFormdataBody(ctx context.Context, body RssAddFolderPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RssItemsPostWithBody request with any body
	RssItemsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RssItemsPostWithFormdataBody(ctx context.Context, body RssItemsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RssMarkAsReadPostWithBody request with any body
	RssMarkAsReadPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RssMarkAsReadPostWithFormdataBody(ctx context.Context, body RssMarkAsReadPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RssMatchingArticlesPostWithBody request with any body
	RssMatchingArticlesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RssMatchingArticlesPostWithFormdataBody(ctx context.Context, body RssMatchingArticlesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RssMoveItemPostWithBody request with any body
	RssMoveItemPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RssMoveItemPostWithFormdataBody(ctx context.Context, body RssMoveItemPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RssRefreshItemPostWithBody request with any body
	RssRefreshItemPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RssRefreshItemPostWithFormdataBody(ctx context.Context, body RssRefreshItemPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RssRemoveItemPostWithBody request with any body
	RssRemoveItemPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RssRemoveItemPostWithFormdataBody(ctx context.Context, body RssRemoveItemPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RssRemoveRulePostWithBody request with any body
	RssRemoveRulePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RssRemoveRulePostWithFormdataBody(ctx context.Context, body RssRemoveRulePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RssRenameRulePostWithBody request with any body
	RssRenameRulePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RssRenameRulePostWithFormdataBody(ctx context.Context, body RssRenameRulePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RssRulesGet request
	RssRulesGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RssSetRulePostWithBody request with any body
	RssSetRulePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RssSetRulePostWithFormdataBody(ctx context.Context, body RssSetRulePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchDeletePostWithBody request with any body
	SearchDeletePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchDeletePostWithFormdataBody(ctx context.Context, body SearchDeletePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchEnablePluginPostWithBody request with any body
	SearchEnablePluginPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchEnablePluginPostWithFormdataBody(ctx context.Context, body SearchEnablePluginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchInstallPluginPostWithBody request with any body
	SearchInstallPluginPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchInstallPluginPostWithFormdataBody(ctx context.Context, body SearchInstallPluginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchPluginsGet request
	SearchPluginsGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchResultsPostWithBody request with any body
	SearchResultsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchResultsPostWithFormdataBody(ctx context.Context, body SearchResultsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchStartPostWithBody request with any body
	SearchStartPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchStartPostWithFormdataBody(ctx context.Context, body SearchStartPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchStatusPostWithBody request with any body
	SearchStatusPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchStatusPostWithFormdataBody(ctx context.Context, body SearchStatusPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchStopPostWithBody request with any body
	SearchStopPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchStopPostWithFormdataBody(ctx context.Context, body SearchStopPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchUninstallPluginPostWithBody request with any body
	SearchUninstallPluginPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchUninstallPluginPostWithFormdataBody(ctx context.Context, body SearchUninstallPluginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchUpdatePluginsPost request
	SearchUpdatePluginsPost(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncMaindataPostWithBody request with any body
	SyncMaindataPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncMaindataPostWithFormdataBody(ctx context.Context, body SyncMaindataPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncTorrentPeersPostWithBody request with any body
	SyncTorrentPeersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncTorrentPeersPostWithFormdataBody(ctx context.Context, body SyncTorrentPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsAddPostWithBody request with any body
	TorrentsAddPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsAddPeersPostWithBody request with any body
	TorrentsAddPeersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsAddPeersPostWithFormdataBody(ctx context.Context, body TorrentsAddPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsAddTagsPostWithBody request with any body
	TorrentsAddTagsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsAddTagsPostWithFormdataBody(ctx context.Context, body TorrentsAddTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsAddTrackersPostWithBody request with any body
	TorrentsAddTrackersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsAddTrackersPostWithFormdataBody(ctx context.Context, body TorrentsAddTrackersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsBottomPrioPostWithBody request with any body
	TorrentsBottomPrioPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsBottomPrioPostWithFormdataBody(ctx context.Context, body TorrentsBottomPrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsCategoriesGet request
	TorrentsCategoriesGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsCreateCategoryPostWithBody request with any body
	TorrentsCreateCategoryPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsCreateCategoryPostWithFormdataBody(ctx context.Context, body TorrentsCreateCategoryPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsCreateTagsPostWithBody request with any body
	TorrentsCreateTagsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsCreateTagsPostWithFormdataBody(ctx context.Context, body TorrentsCreateTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsDecreasePrioPostWithBody request with any body
	TorrentsDecreasePrioPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsDecreasePrioPostWithFormdataBody(ctx context.Context, body TorrentsDecreasePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsDeletePostWithBody request with any body
	TorrentsDeletePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsDeletePostWithFormdataBody(ctx context.Context, body TorrentsDeletePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsDeleteTagsPostWithBody request with any body
	TorrentsDeleteTagsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsDeleteTagsPostWithFormdataBody(ctx context.Context, body TorrentsDeleteTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsDownloadLimitPostWithBody request with any body
	TorrentsDownloadLimitPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsDownloadLimitPostWithFormdataBody(ctx context.Context, body TorrentsDownloadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsEditCategoryPostWithBody request with any body
	TorrentsEditCategoryPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsEditCategoryPostWithFormdataBody(ctx context.Context, body TorrentsEditCategoryPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsEditTrackerPostWithBody request with any body
	TorrentsEditTrackerPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsEditTrackerPostWithFormdataBody(ctx context.Context, body TorrentsEditTrackerPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsFilePrioPostWithBody request with any body
	TorrentsFilePrioPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsFilePrioPostWithFormdataBody(ctx context.Context, body TorrentsFilePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsFilesPostWithBody request with any body
	TorrentsFilesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsFilesPostWithFormdataBody(ctx context.Context, body TorrentsFilesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsIncreasePrioPostWithBody request with any body
	TorrentsIncreasePrioPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsIncreasePrioPostWithFormdataBody(ctx context.Context, body TorrentsIncreasePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsInfoGet request
	TorrentsInfoGet(ctx context.Context, params *TorrentsInfoGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsInfoPostWithBody request with any body
	TorrentsInfoPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsInfoPostWithFormdataBody(ctx context.Context, body TorrentsInfoPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsPausePostWithBody request with any body
	TorrentsPausePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsPausePostWithFormdataBody(ctx context.Context, body TorrentsPausePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsPieceHashesPostWithBody request with any body
	TorrentsPieceHashesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsPieceHashesPostWithFormdataBody(ctx context.Context, body TorrentsPieceHashesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsPieceStatesPostWithBody request with any body
	TorrentsPieceStatesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsPieceStatesPostWithFormdataBody(ctx context.Context, body TorrentsPieceStatesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsPropertiesPostWithBody request with any body
	TorrentsPropertiesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsPropertiesPostWithFormdataBody(ctx context.Context, body TorrentsPropertiesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsReannouncePostWithBody request with any body
	TorrentsReannouncePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsReannouncePostWithFormdataBody(ctx context.Context, body TorrentsReannouncePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsRecheckPostWithBody request with any body
	TorrentsRecheckPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsRecheckPostWithFormdataBody(ctx context.Context, body TorrentsRecheckPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsRemoveCategoriesPostWithBody request with any body
	TorrentsRemoveCategoriesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsRemoveCategoriesPostWithFormdataBody(ctx context.Context, body TorrentsRemoveCategoriesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsRemoveTagsPostWithBody request with any body
	TorrentsRemoveTagsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsRemoveTagsPostWithFormdataBody(ctx context.Context, body TorrentsRemoveTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsRemoveTrackersPostWithBody request with any body
	TorrentsRemoveTrackersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsRemoveTrackersPostWithFormdataBody(ctx context.Context, body TorrentsRemoveTrackersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsRenamePostWithBody request with any body
	TorrentsRenamePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsRenamePostWithFormdataBody(ctx context.Context, body TorrentsRenamePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsRenameFilePostWithBody request with any body
	TorrentsRenameFilePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsRenameFilePostWithFormdataBody(ctx context.Context, body TorrentsRenameFilePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsRenameFolderPostWithBody request with any body
	TorrentsRenameFolderPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsRenameFolderPostWithFormdataBody(ctx context.Context, body TorrentsRenameFolderPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsResumePostWithBody request with any body
	TorrentsResumePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsResumePostWithFormdataBody(ctx context.Context, body TorrentsResumePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsSetAutoManagementPostWithBody request with any body
	TorrentsSetAutoManagementPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsSetAutoManagementPostWithFormdataBody(ctx context.Context, body TorrentsSetAutoManagementPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsSetCategoryPostWithBody request with any body
	TorrentsSetCategoryPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsSetCategoryPostWithFormdataBody(ctx context.Context, body TorrentsSetCategoryPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsSetDownloadLimitPostWithBody request with any body
	TorrentsSetDownloadLimitPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsSetDownloadLimitPostWithFormdataBody(ctx context.Context, body TorrentsSetDownloadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsSetForceStartPostWithBody request with any body
	TorrentsSetForceStartPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsSetForceStartPostWithFormdataBody(ctx context.Context, body TorrentsSetForceStartPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsSetLocationPostWithBody request with any body
	TorrentsSetLocationPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsSetLocationPostWithFormdataBody(ctx context.Context, body TorrentsSetLocationPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsSetShareLimitsPostWithBody request with any body
	TorrentsSetShareLimitsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsSetShareLimitsPostWithFormdataBody(ctx context.Context, body TorrentsSetShareLimitsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsSetSuperSeedingPostWithBody request with any body
	TorrentsSetSuperSeedingPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsSetSuperSeedingPostWithFormdataBody(ctx context.Context, body TorrentsSetSuperSeedingPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsSetUploadLimitPostWithBody request with any body
	TorrentsSetUploadLimitPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsSetUploadLimitPostWithFormdataBody(ctx context.Context, body TorrentsSetUploadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsTagsGet request
	TorrentsTagsGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsToggleFirstLastPiecePrioPostWithBody request with any body
	TorrentsToggleFirstLastPiecePrioPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsToggleFirstLastPiecePrioPostWithFormdataBody(ctx context.Context, body TorrentsToggleFirstLastPiecePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsToggleSequentialDownloadPostWithBody request with any body
	TorrentsToggleSequentialDownloadPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsToggleSequentialDownloadPostWithFormdataBody(ctx context.Context, body TorrentsToggleSequentialDownloadPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsTopPrioPostWithBody request with any body
	TorrentsTopPrioPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsTopPrioPostWithFormdataBody(ctx context.Context, body TorrentsTopPrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsTrackersPostWithBody request with any body
	TorrentsTrackersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsTrackersPostWithFormdataBody(ctx context.Context, body TorrentsTrackersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentsUploadLimitPostWithBody request with any body
	TorrentsUploadLimitPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentsUploadLimitPostWithFormdataBody(ctx context.Context, body TorrentsUploadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TorrentWebseedsPostWithBody request with any body
	TorrentWebseedsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TorrentWebseedsPostWithFormdataBody(ctx context.Context, body TorrentWebseedsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransferBanPeersPostWithBody request with any body
	TransferBanPeersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TransferBanPeersPostWithFormdataBody(ctx context.Context, body TransferBanPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransferDownloadLimitGet request
	TransferDownloadLimitGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransferInfoGet request
	TransferInfoGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransferSetDownloadLimitPostWithBody request with any body
	TransferSetDownloadLimitPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TransferSetDownloadLimitPostWithFormdataBody(ctx context.Context, body TransferSetDownloadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransferSetUploadLimitPostWithBody request with any body
	TransferSetUploadLimitPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TransferSetUploadLimitPostWithFormdataBody(ctx context.Context, body TransferSetUploadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransferSpeedLimitsModeGet request
	TransferSpeedLimitsModeGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransferToggleSpeedLimitsModeGet request
	TransferToggleSpeedLimitsModeGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransferUploadLimitGet request
	TransferUploadLimitGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AppBuildInfoGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppBuildInfoGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppDefaultSavePathGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppDefaultSavePathGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppPreferencesGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppPreferencesGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppSetPreferencesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppSetPreferencesPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppSetPreferencesPostWithFormdataBody(ctx context.Context, body AppSetPreferencesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppSetPreferencesPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppShutdownGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppShutdownGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppVersionGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppVersionGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppWebapiVersionGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppWebapiVersionGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthLoginPostWithBody(ctx context.Context, params *AuthLoginPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthLoginPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthLoginPostWithFormdataBody(ctx context.Context, params *AuthLoginPostParams, body AuthLoginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthLoginPostRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthLogoutPost(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthLogoutPostRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogMainPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogMainPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogMainPostWithFormdataBody(ctx context.Context, body LogMainPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogMainPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogPeersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogPeersPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogPeersPostWithFormdataBody(ctx context.Context, body LogPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogPeersPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssAddFeedPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssAddFeedPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssAddFeedPostWithFormdataBody(ctx context.Context, body RssAddFeedPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssAddFeedPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssAddFolderPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssAddFolderPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssAddFolderPostWithFormdataBody(ctx context.Context, body RssAddFolderPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssAddFolderPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssItemsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssItemsPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssItemsPostWithFormdataBody(ctx context.Context, body RssItemsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssItemsPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssMarkAsReadPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssMarkAsReadPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssMarkAsReadPostWithFormdataBody(ctx context.Context, body RssMarkAsReadPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssMarkAsReadPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssMatchingArticlesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssMatchingArticlesPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssMatchingArticlesPostWithFormdataBody(ctx context.Context, body RssMatchingArticlesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssMatchingArticlesPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssMoveItemPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssMoveItemPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssMoveItemPostWithFormdataBody(ctx context.Context, body RssMoveItemPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssMoveItemPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssRefreshItemPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssRefreshItemPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssRefreshItemPostWithFormdataBody(ctx context.Context, body RssRefreshItemPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssRefreshItemPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssRemoveItemPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssRemoveItemPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssRemoveItemPostWithFormdataBody(ctx context.Context, body RssRemoveItemPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssRemoveItemPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssRemoveRulePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssRemoveRulePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssRemoveRulePostWithFormdataBody(ctx context.Context, body RssRemoveRulePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssRemoveRulePostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssRenameRulePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssRenameRulePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssRenameRulePostWithFormdataBody(ctx context.Context, body RssRenameRulePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssRenameRulePostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssRulesGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssRulesGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssSetRulePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssSetRulePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RssSetRulePostWithFormdataBody(ctx context.Context, body RssSetRulePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRssSetRulePostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDeletePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDeletePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDeletePostWithFormdataBody(ctx context.Context, body SearchDeletePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDeletePostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchEnablePluginPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchEnablePluginPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchEnablePluginPostWithFormdataBody(ctx context.Context, body SearchEnablePluginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchEnablePluginPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchInstallPluginPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchInstallPluginPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchInstallPluginPostWithFormdataBody(ctx context.Context, body SearchInstallPluginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchInstallPluginPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchPluginsGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchPluginsGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchResultsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchResultsPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchResultsPostWithFormdataBody(ctx context.Context, body SearchResultsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchResultsPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchStartPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchStartPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchStartPostWithFormdataBody(ctx context.Context, body SearchStartPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchStartPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchStatusPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchStatusPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchStatusPostWithFormdataBody(ctx context.Context, body SearchStatusPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchStatusPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchStopPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchStopPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchStopPostWithFormdataBody(ctx context.Context, body SearchStopPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchStopPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUninstallPluginPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUninstallPluginPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUninstallPluginPostWithFormdataBody(ctx context.Context, body SearchUninstallPluginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUninstallPluginPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUpdatePluginsPost(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUpdatePluginsPostRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncMaindataPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncMaindataPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncMaindataPostWithFormdataBody(ctx context.Context, body SyncMaindataPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncMaindataPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncTorrentPeersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncTorrentPeersPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncTorrentPeersPostWithFormdataBody(ctx context.Context, body SyncTorrentPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncTorrentPeersPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsAddPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsAddPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsAddPeersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsAddPeersPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsAddPeersPostWithFormdataBody(ctx context.Context, body TorrentsAddPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsAddPeersPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsAddTagsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsAddTagsPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsAddTagsPostWithFormdataBody(ctx context.Context, body TorrentsAddTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsAddTagsPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsAddTrackersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsAddTrackersPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsAddTrackersPostWithFormdataBody(ctx context.Context, body TorrentsAddTrackersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsAddTrackersPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsBottomPrioPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsBottomPrioPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsBottomPrioPostWithFormdataBody(ctx context.Context, body TorrentsBottomPrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsBottomPrioPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsCategoriesGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsCategoriesGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsCreateCategoryPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsCreateCategoryPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsCreateCategoryPostWithFormdataBody(ctx context.Context, body TorrentsCreateCategoryPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsCreateCategoryPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsCreateTagsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsCreateTagsPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsCreateTagsPostWithFormdataBody(ctx context.Context, body TorrentsCreateTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsCreateTagsPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsDecreasePrioPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsDecreasePrioPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsDecreasePrioPostWithFormdataBody(ctx context.Context, body TorrentsDecreasePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsDecreasePrioPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsDeletePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsDeletePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsDeletePostWithFormdataBody(ctx context.Context, body TorrentsDeletePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsDeletePostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsDeleteTagsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsDeleteTagsPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsDeleteTagsPostWithFormdataBody(ctx context.Context, body TorrentsDeleteTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsDeleteTagsPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsDownloadLimitPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsDownloadLimitPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsDownloadLimitPostWithFormdataBody(ctx context.Context, body TorrentsDownloadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsDownloadLimitPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsEditCategoryPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsEditCategoryPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsEditCategoryPostWithFormdataBody(ctx context.Context, body TorrentsEditCategoryPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsEditCategoryPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsEditTrackerPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsEditTrackerPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsEditTrackerPostWithFormdataBody(ctx context.Context, body TorrentsEditTrackerPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsEditTrackerPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsFilePrioPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsFilePrioPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsFilePrioPostWithFormdataBody(ctx context.Context, body TorrentsFilePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsFilePrioPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsFilesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsFilesPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsFilesPostWithFormdataBody(ctx context.Context, body TorrentsFilesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsFilesPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsIncreasePrioPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsIncreasePrioPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsIncreasePrioPostWithFormdataBody(ctx context.Context, body TorrentsIncreasePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsIncreasePrioPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsInfoGet(ctx context.Context, params *TorrentsInfoGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsInfoGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsInfoPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsInfoPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsInfoPostWithFormdataBody(ctx context.Context, body TorrentsInfoPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsInfoPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsPausePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsPausePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsPausePostWithFormdataBody(ctx context.Context, body TorrentsPausePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsPausePostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsPieceHashesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsPieceHashesPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsPieceHashesPostWithFormdataBody(ctx context.Context, body TorrentsPieceHashesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsPieceHashesPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsPieceStatesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsPieceStatesPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsPieceStatesPostWithFormdataBody(ctx context.Context, body TorrentsPieceStatesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsPieceStatesPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsPropertiesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsPropertiesPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsPropertiesPostWithFormdataBody(ctx context.Context, body TorrentsPropertiesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsPropertiesPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsReannouncePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsReannouncePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsReannouncePostWithFormdataBody(ctx context.Context, body TorrentsReannouncePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsReannouncePostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRecheckPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRecheckPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRecheckPostWithFormdataBody(ctx context.Context, body TorrentsRecheckPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRecheckPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRemoveCategoriesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRemoveCategoriesPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRemoveCategoriesPostWithFormdataBody(ctx context.Context, body TorrentsRemoveCategoriesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRemoveCategoriesPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRemoveTagsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRemoveTagsPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRemoveTagsPostWithFormdataBody(ctx context.Context, body TorrentsRemoveTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRemoveTagsPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRemoveTrackersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRemoveTrackersPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRemoveTrackersPostWithFormdataBody(ctx context.Context, body TorrentsRemoveTrackersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRemoveTrackersPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRenamePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRenamePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRenamePostWithFormdataBody(ctx context.Context, body TorrentsRenamePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRenamePostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRenameFilePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRenameFilePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRenameFilePostWithFormdataBody(ctx context.Context, body TorrentsRenameFilePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRenameFilePostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRenameFolderPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRenameFolderPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsRenameFolderPostWithFormdataBody(ctx context.Context, body TorrentsRenameFolderPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsRenameFolderPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsResumePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsResumePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsResumePostWithFormdataBody(ctx context.Context, body TorrentsResumePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsResumePostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetAutoManagementPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetAutoManagementPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetAutoManagementPostWithFormdataBody(ctx context.Context, body TorrentsSetAutoManagementPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetAutoManagementPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetCategoryPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetCategoryPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetCategoryPostWithFormdataBody(ctx context.Context, body TorrentsSetCategoryPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetCategoryPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetDownloadLimitPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetDownloadLimitPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetDownloadLimitPostWithFormdataBody(ctx context.Context, body TorrentsSetDownloadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetDownloadLimitPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetForceStartPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetForceStartPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetForceStartPostWithFormdataBody(ctx context.Context, body TorrentsSetForceStartPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetForceStartPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetLocationPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetLocationPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetLocationPostWithFormdataBody(ctx context.Context, body TorrentsSetLocationPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetLocationPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetShareLimitsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetShareLimitsPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetShareLimitsPostWithFormdataBody(ctx context.Context, body TorrentsSetShareLimitsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetShareLimitsPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetSuperSeedingPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetSuperSeedingPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetSuperSeedingPostWithFormdataBody(ctx context.Context, body TorrentsSetSuperSeedingPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetSuperSeedingPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetUploadLimitPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetUploadLimitPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsSetUploadLimitPostWithFormdataBody(ctx context.Context, body TorrentsSetUploadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsSetUploadLimitPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsTagsGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsTagsGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsToggleFirstLastPiecePrioPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsToggleFirstLastPiecePrioPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsToggleFirstLastPiecePrioPostWithFormdataBody(ctx context.Context, body TorrentsToggleFirstLastPiecePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsToggleFirstLastPiecePrioPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsToggleSequentialDownloadPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsToggleSequentialDownloadPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsToggleSequentialDownloadPostWithFormdataBody(ctx context.Context, body TorrentsToggleSequentialDownloadPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsToggleSequentialDownloadPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsTopPrioPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsTopPrioPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsTopPrioPostWithFormdataBody(ctx context.Context, body TorrentsTopPrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsTopPrioPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsTrackersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsTrackersPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsTrackersPostWithFormdataBody(ctx context.Context, body TorrentsTrackersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsTrackersPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsUploadLimitPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsUploadLimitPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentsUploadLimitPostWithFormdataBody(ctx context.Context, body TorrentsUploadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentsUploadLimitPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentWebseedsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentWebseedsPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TorrentWebseedsPostWithFormdataBody(ctx context.Context, body TorrentWebseedsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTorrentWebseedsPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferBanPeersPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferBanPeersPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferBanPeersPostWithFormdataBody(ctx context.Context, body TransferBanPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferBanPeersPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferDownloadLimitGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferDownloadLimitGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferInfoGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferInfoGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferSetDownloadLimitPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferSetDownloadLimitPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferSetDownloadLimitPostWithFormdataBody(ctx context.Context, body TransferSetDownloadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferSetDownloadLimitPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferSetUploadLimitPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferSetUploadLimitPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferSetUploadLimitPostWithFormdataBody(ctx context.Context, body TransferSetUploadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferSetUploadLimitPostRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferSpeedLimitsModeGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferSpeedLimitsModeGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferToggleSpeedLimitsModeGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferToggleSpeedLimitsModeGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferUploadLimitGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferUploadLimitGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAppBuildInfoGetRequest generates requests for AppBuildInfoGet
func NewAppBuildInfoGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/buildInfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppDefaultSavePathGetRequest generates requests for AppDefaultSavePathGet
func NewAppDefaultSavePathGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/defaultSavePath")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppPreferencesGetRequest generates requests for AppPreferencesGet
func NewAppPreferencesGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/preferences")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppSetPreferencesPostRequestWithFormdataBody calls the generic AppSetPreferencesPost builder with application/x-www-form-urlencoded body
func NewAppSetPreferencesPostRequestWithFormdataBody(server string, body AppSetPreferencesPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewAppSetPreferencesPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewAppSetPreferencesPostRequestWithBody generates requests for AppSetPreferencesPost with any type of body
func NewAppSetPreferencesPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/setPreferences")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAppShutdownGetRequest generates requests for AppShutdownGet
func NewAppShutdownGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/shutdown")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppVersionGetRequest generates requests for AppVersionGet
func NewAppVersionGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppWebapiVersionGetRequest generates requests for AppWebapiVersionGet
func NewAppWebapiVersionGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/webapiVersion")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthLoginPostRequestWithFormdataBody calls the generic AuthLoginPost builder with application/x-www-form-urlencoded body
func NewAuthLoginPostRequestWithFormdataBody(server string, params *AuthLoginPostParams, body AuthLoginPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewAuthLoginPostRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewAuthLoginPostRequestWithBody generates requests for AuthLoginPost with any type of body
func NewAuthLoginPostRequestWithBody(server string, params *AuthLoginPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Referer != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Referer", runtime.ParamLocationHeader, *params.Referer)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Referer", headerParam0)
		}

		if params.Origin != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Origin", runtime.ParamLocationHeader, *params.Origin)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Origin", headerParam1)
		}

	}

	return req, nil
}

// NewAuthLogoutPostRequest generates requests for AuthLogoutPost
func NewAuthLogoutPostRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogMainPostRequestWithFormdataBody calls the generic LogMainPost builder with application/x-www-form-urlencoded body
func NewLogMainPostRequestWithFormdataBody(server string, body LogMainPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewLogMainPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewLogMainPostRequestWithBody generates requests for LogMainPost with any type of body
func NewLogMainPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/log/main")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLogPeersPostRequestWithFormdataBody calls the generic LogPeersPost builder with application/x-www-form-urlencoded body
func NewLogPeersPostRequestWithFormdataBody(server string, body LogPeersPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewLogPeersPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewLogPeersPostRequestWithBody generates requests for LogPeersPost with any type of body
func NewLogPeersPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/log/peers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRssAddFeedPostRequestWithFormdataBody calls the generic RssAddFeedPost builder with application/x-www-form-urlencoded body
func NewRssAddFeedPostRequestWithFormdataBody(server string, body RssAddFeedPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewRssAddFeedPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewRssAddFeedPostRequestWithBody generates requests for RssAddFeedPost with any type of body
func NewRssAddFeedPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rss/addFeed")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRssAddFolderPostRequestWithFormdataBody calls the generic RssAddFolderPost builder with application/x-www-form-urlencoded body
func NewRssAddFolderPostRequestWithFormdataBody(server string, body RssAddFolderPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewRssAddFolderPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewRssAddFolderPostRequestWithBody generates requests for RssAddFolderPost with any type of body
func NewRssAddFolderPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rss/addFolder")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRssItemsPostRequestWithFormdataBody calls the generic RssItemsPost builder with application/x-www-form-urlencoded body
func NewRssItemsPostRequestWithFormdataBody(server string, body RssItemsPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewRssItemsPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewRssItemsPostRequestWithBody generates requests for RssItemsPost with any type of body
func NewRssItemsPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rss/items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRssMarkAsReadPostRequestWithFormdataBody calls the generic RssMarkAsReadPost builder with application/x-www-form-urlencoded body
func NewRssMarkAsReadPostRequestWithFormdataBody(server string, body RssMarkAsReadPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewRssMarkAsReadPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewRssMarkAsReadPostRequestWithBody generates requests for RssMarkAsReadPost with any type of body
func NewRssMarkAsReadPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rss/markAsRead")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRssMatchingArticlesPostRequestWithFormdataBody calls the generic RssMatchingArticlesPost builder with application/x-www-form-urlencoded body
func NewRssMatchingArticlesPostRequestWithFormdataBody(server string, body RssMatchingArticlesPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewRssMatchingArticlesPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewRssMatchingArticlesPostRequestWithBody generates requests for RssMatchingArticlesPost with any type of body
func NewRssMatchingArticlesPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rss/matchingArticles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRssMoveItemPostRequestWithFormdataBody calls the generic RssMoveItemPost builder with application/x-www-form-urlencoded body
func NewRssMoveItemPostRequestWithFormdataBody(server string, body RssMoveItemPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewRssMoveItemPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewRssMoveItemPostRequestWithBody generates requests for RssMoveItemPost with any type of body
func NewRssMoveItemPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rss/moveItem")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRssRefreshItemPostRequestWithFormdataBody calls the generic RssRefreshItemPost builder with application/x-www-form-urlencoded body
func NewRssRefreshItemPostRequestWithFormdataBody(server string, body RssRefreshItemPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewRssRefreshItemPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewRssRefreshItemPostRequestWithBody generates requests for RssRefreshItemPost with any type of body
func NewRssRefreshItemPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rss/refreshItem")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRssRemoveItemPostRequestWithFormdataBody calls the generic RssRemoveItemPost builder with application/x-www-form-urlencoded body
func NewRssRemoveItemPostRequestWithFormdataBody(server string, body RssRemoveItemPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewRssRemoveItemPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewRssRemoveItemPostRequestWithBody generates requests for RssRemoveItemPost with any type of body
func NewRssRemoveItemPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rss/removeItem")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRssRemoveRulePostRequestWithFormdataBody calls the generic RssRemoveRulePost builder with application/x-www-form-urlencoded body
func NewRssRemoveRulePostRequestWithFormdataBody(server string, body RssRemoveRulePostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewRssRemoveRulePostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewRssRemoveRulePostRequestWithBody generates requests for RssRemoveRulePost with any type of body
func NewRssRemoveRulePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rss/removeRule")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRssRenameRulePostRequestWithFormdataBody calls the generic RssRenameRulePost builder with application/x-www-form-urlencoded body
func NewRssRenameRulePostRequestWithFormdataBody(server string, body RssRenameRulePostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewRssRenameRulePostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewRssRenameRulePostRequestWithBody generates requests for RssRenameRulePost with any type of body
func NewRssRenameRulePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rss/renameRule")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRssRulesGetRequest generates requests for RssRulesGet
func NewRssRulesGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rss/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRssSetRulePostRequestWithFormdataBody calls the generic RssSetRulePost builder with application/x-www-form-urlencoded body
func NewRssSetRulePostRequestWithFormdataBody(server string, body RssSetRulePostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewRssSetRulePostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewRssSetRulePostRequestWithBody generates requests for RssSetRulePost with any type of body
func NewRssSetRulePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rss/setRule")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchDeletePostRequestWithFormdataBody calls the generic SearchDeletePost builder with application/x-www-form-urlencoded body
func NewSearchDeletePostRequestWithFormdataBody(server string, body SearchDeletePostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSearchDeletePostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewSearchDeletePostRequestWithBody generates requests for SearchDeletePost with any type of body
func NewSearchDeletePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchEnablePluginPostRequestWithFormdataBody calls the generic SearchEnablePluginPost builder with application/x-www-form-urlencoded body
func NewSearchEnablePluginPostRequestWithFormdataBody(server string, body SearchEnablePluginPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSearchEnablePluginPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewSearchEnablePluginPostRequestWithBody generates requests for SearchEnablePluginPost with any type of body
func NewSearchEnablePluginPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/enablePlugin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchInstallPluginPostRequestWithFormdataBody calls the generic SearchInstallPluginPost builder with application/x-www-form-urlencoded body
func NewSearchInstallPluginPostRequestWithFormdataBody(server string, body SearchInstallPluginPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSearchInstallPluginPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewSearchInstallPluginPostRequestWithBody generates requests for SearchInstallPluginPost with any type of body
func NewSearchInstallPluginPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/installPlugin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchPluginsGetRequest generates requests for SearchPluginsGet
func NewSearchPluginsGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/plugins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchResultsPostRequestWithFormdataBody calls the generic SearchResultsPost builder with application/x-www-form-urlencoded body
func NewSearchResultsPostRequestWithFormdataBody(server string, body SearchResultsPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSearchResultsPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewSearchResultsPostRequestWithBody generates requests for SearchResultsPost with any type of body
func NewSearchResultsPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/results")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchStartPostRequestWithFormdataBody calls the generic SearchStartPost builder with application/x-www-form-urlencoded body
func NewSearchStartPostRequestWithFormdataBody(server string, body SearchStartPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSearchStartPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewSearchStartPostRequestWithBody generates requests for SearchStartPost with any type of body
func NewSearchStartPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchStatusPostRequestWithFormdataBody calls the generic SearchStatusPost builder with application/x-www-form-urlencoded body
func NewSearchStatusPostRequestWithFormdataBody(server string, body SearchStatusPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSearchStatusPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewSearchStatusPostRequestWithBody generates requests for SearchStatusPost with any type of body
func NewSearchStatusPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchStopPostRequestWithFormdataBody calls the generic SearchStopPost builder with application/x-www-form-urlencoded body
func NewSearchStopPostRequestWithFormdataBody(server string, body SearchStopPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSearchStopPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewSearchStopPostRequestWithBody generates requests for SearchStopPost with any type of body
func NewSearchStopPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/stop")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchUninstallPluginPostRequestWithFormdataBody calls the generic SearchUninstallPluginPost builder with application/x-www-form-urlencoded body
func NewSearchUninstallPluginPostRequestWithFormdataBody(server string, body SearchUninstallPluginPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSearchUninstallPluginPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewSearchUninstallPluginPostRequestWithBody generates requests for SearchUninstallPluginPost with any type of body
func NewSearchUninstallPluginPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/uninstallPlugin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchUpdatePluginsPostRequest generates requests for SearchUpdatePluginsPost
func NewSearchUpdatePluginsPostRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/updatePlugins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSyncMaindataPostRequestWithFormdataBody calls the generic SyncMaindataPost builder with application/x-www-form-urlencoded body
func NewSyncMaindataPostRequestWithFormdataBody(server string, body SyncMaindataPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSyncMaindataPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewSyncMaindataPostRequestWithBody generates requests for SyncMaindataPost with any type of body
func NewSyncMaindataPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync/maindata")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSyncTorrentPeersPostRequestWithFormdataBody calls the generic SyncTorrentPeersPost builder with application/x-www-form-urlencoded body
func NewSyncTorrentPeersPostRequestWithFormdataBody(server string, body SyncTorrentPeersPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewSyncTorrentPeersPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewSyncTorrentPeersPostRequestWithBody generates requests for SyncTorrentPeersPost with any type of body
func NewSyncTorrentPeersPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync/torrentPeers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsAddPostRequestWithBody generates requests for TorrentsAddPost with any type of body
func NewTorrentsAddPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/add")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsAddPeersPostRequestWithFormdataBody calls the generic TorrentsAddPeersPost builder with application/x-www-form-urlencoded body
func NewTorrentsAddPeersPostRequestWithFormdataBody(server string, body TorrentsAddPeersPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsAddPeersPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsAddPeersPostRequestWithBody generates requests for TorrentsAddPeersPost with any type of body
func NewTorrentsAddPeersPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/addPeers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsAddTagsPostRequestWithFormdataBody calls the generic TorrentsAddTagsPost builder with application/x-www-form-urlencoded body
func NewTorrentsAddTagsPostRequestWithFormdataBody(server string, body TorrentsAddTagsPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsAddTagsPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsAddTagsPostRequestWithBody generates requests for TorrentsAddTagsPost with any type of body
func NewTorrentsAddTagsPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/addTags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsAddTrackersPostRequestWithFormdataBody calls the generic TorrentsAddTrackersPost builder with application/x-www-form-urlencoded body
func NewTorrentsAddTrackersPostRequestWithFormdataBody(server string, body TorrentsAddTrackersPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsAddTrackersPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsAddTrackersPostRequestWithBody generates requests for TorrentsAddTrackersPost with any type of body
func NewTorrentsAddTrackersPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/addTrackers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsBottomPrioPostRequestWithFormdataBody calls the generic TorrentsBottomPrioPost builder with application/x-www-form-urlencoded body
func NewTorrentsBottomPrioPostRequestWithFormdataBody(server string, body TorrentsBottomPrioPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsBottomPrioPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsBottomPrioPostRequestWithBody generates requests for TorrentsBottomPrioPost with any type of body
func NewTorrentsBottomPrioPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/bottomPrio")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsCategoriesGetRequest generates requests for TorrentsCategoriesGet
func NewTorrentsCategoriesGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTorrentsCreateCategoryPostRequestWithFormdataBody calls the generic TorrentsCreateCategoryPost builder with application/x-www-form-urlencoded body
func NewTorrentsCreateCategoryPostRequestWithFormdataBody(server string, body TorrentsCreateCategoryPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsCreateCategoryPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsCreateCategoryPostRequestWithBody generates requests for TorrentsCreateCategoryPost with any type of body
func NewTorrentsCreateCategoryPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/createCategory")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsCreateTagsPostRequestWithFormdataBody calls the generic TorrentsCreateTagsPost builder with application/x-www-form-urlencoded body
func NewTorrentsCreateTagsPostRequestWithFormdataBody(server string, body TorrentsCreateTagsPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsCreateTagsPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsCreateTagsPostRequestWithBody generates requests for TorrentsCreateTagsPost with any type of body
func NewTorrentsCreateTagsPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/createTags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsDecreasePrioPostRequestWithFormdataBody calls the generic TorrentsDecreasePrioPost builder with application/x-www-form-urlencoded body
func NewTorrentsDecreasePrioPostRequestWithFormdataBody(server string, body TorrentsDecreasePrioPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsDecreasePrioPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsDecreasePrioPostRequestWithBody generates requests for TorrentsDecreasePrioPost with any type of body
func NewTorrentsDecreasePrioPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/decreasePrio")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsDeletePostRequestWithFormdataBody calls the generic TorrentsDeletePost builder with application/x-www-form-urlencoded body
func NewTorrentsDeletePostRequestWithFormdataBody(server string, body TorrentsDeletePostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsDeletePostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsDeletePostRequestWithBody generates requests for TorrentsDeletePost with any type of body
func NewTorrentsDeletePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsDeleteTagsPostRequestWithFormdataBody calls the generic TorrentsDeleteTagsPost builder with application/x-www-form-urlencoded body
func NewTorrentsDeleteTagsPostRequestWithFormdataBody(server string, body TorrentsDeleteTagsPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsDeleteTagsPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsDeleteTagsPostRequestWithBody generates requests for TorrentsDeleteTagsPost with any type of body
func NewTorrentsDeleteTagsPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/deleteTags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsDownloadLimitPostRequestWithFormdataBody calls the generic TorrentsDownloadLimitPost builder with application/x-www-form-urlencoded body
func NewTorrentsDownloadLimitPostRequestWithFormdataBody(server string, body TorrentsDownloadLimitPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsDownloadLimitPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsDownloadLimitPostRequestWithBody generates requests for TorrentsDownloadLimitPost with any type of body
func NewTorrentsDownloadLimitPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/downloadLimit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsEditCategoryPostRequestWithFormdataBody calls the generic TorrentsEditCategoryPost builder with application/x-www-form-urlencoded body
func NewTorrentsEditCategoryPostRequestWithFormdataBody(server string, body TorrentsEditCategoryPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsEditCategoryPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsEditCategoryPostRequestWithBody generates requests for TorrentsEditCategoryPost with any type of body
func NewTorrentsEditCategoryPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/editCategory")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsEditTrackerPostRequestWithFormdataBody calls the generic TorrentsEditTrackerPost builder with application/x-www-form-urlencoded body
func NewTorrentsEditTrackerPostRequestWithFormdataBody(server string, body TorrentsEditTrackerPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsEditTrackerPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsEditTrackerPostRequestWithBody generates requests for TorrentsEditTrackerPost with any type of body
func NewTorrentsEditTrackerPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/editTracker")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsFilePrioPostRequestWithFormdataBody calls the generic TorrentsFilePrioPost builder with application/x-www-form-urlencoded body
func NewTorrentsFilePrioPostRequestWithFormdataBody(server string, body TorrentsFilePrioPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsFilePrioPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsFilePrioPostRequestWithBody generates requests for TorrentsFilePrioPost with any type of body
func NewTorrentsFilePrioPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/filePrio")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsFilesPostRequestWithFormdataBody calls the generic TorrentsFilesPost builder with application/x-www-form-urlencoded body
func NewTorrentsFilesPostRequestWithFormdataBody(server string, body TorrentsFilesPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsFilesPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsFilesPostRequestWithBody generates requests for TorrentsFilesPost with any type of body
func NewTorrentsFilesPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsIncreasePrioPostRequestWithFormdataBody calls the generic TorrentsIncreasePrioPost builder with application/x-www-form-urlencoded body
func NewTorrentsIncreasePrioPostRequestWithFormdataBody(server string, body TorrentsIncreasePrioPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsIncreasePrioPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsIncreasePrioPostRequestWithBody generates requests for TorrentsIncreasePrioPost with any type of body
func NewTorrentsIncreasePrioPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/increasePrio")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsInfoGetRequest generates requests for TorrentsInfoGet
func NewTorrentsInfoGetRequest(server string, params *TorrentsInfoGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Category != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category", runtime.ParamLocationQuery, *params.Category); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reverse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reverse", runtime.ParamLocationQuery, *params.Reverse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Hashes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hashes", runtime.ParamLocationQuery, *params.Hashes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTorrentsInfoPostRequestWithFormdataBody calls the generic TorrentsInfoPost builder with application/x-www-form-urlencoded body
func NewTorrentsInfoPostRequestWithFormdataBody(server string, body TorrentsInfoPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsInfoPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsInfoPostRequestWithBody generates requests for TorrentsInfoPost with any type of body
func NewTorrentsInfoPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsPausePostRequestWithFormdataBody calls the generic TorrentsPausePost builder with application/x-www-form-urlencoded body
func NewTorrentsPausePostRequestWithFormdataBody(server string, body TorrentsPausePostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsPausePostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsPausePostRequestWithBody generates requests for TorrentsPausePost with any type of body
func NewTorrentsPausePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/pause")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsPieceHashesPostRequestWithFormdataBody calls the generic TorrentsPieceHashesPost builder with application/x-www-form-urlencoded body
func NewTorrentsPieceHashesPostRequestWithFormdataBody(server string, body TorrentsPieceHashesPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsPieceHashesPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsPieceHashesPostRequestWithBody generates requests for TorrentsPieceHashesPost with any type of body
func NewTorrentsPieceHashesPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/pieceHashes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsPieceStatesPostRequestWithFormdataBody calls the generic TorrentsPieceStatesPost builder with application/x-www-form-urlencoded body
func NewTorrentsPieceStatesPostRequestWithFormdataBody(server string, body TorrentsPieceStatesPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsPieceStatesPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsPieceStatesPostRequestWithBody generates requests for TorrentsPieceStatesPost with any type of body
func NewTorrentsPieceStatesPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/pieceStates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsPropertiesPostRequestWithFormdataBody calls the generic TorrentsPropertiesPost builder with application/x-www-form-urlencoded body
func NewTorrentsPropertiesPostRequestWithFormdataBody(server string, body TorrentsPropertiesPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsPropertiesPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsPropertiesPostRequestWithBody generates requests for TorrentsPropertiesPost with any type of body
func NewTorrentsPropertiesPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/properties")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsReannouncePostRequestWithFormdataBody calls the generic TorrentsReannouncePost builder with application/x-www-form-urlencoded body
func NewTorrentsReannouncePostRequestWithFormdataBody(server string, body TorrentsReannouncePostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsReannouncePostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsReannouncePostRequestWithBody generates requests for TorrentsReannouncePost with any type of body
func NewTorrentsReannouncePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/reannounce")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsRecheckPostRequestWithFormdataBody calls the generic TorrentsRecheckPost builder with application/x-www-form-urlencoded body
func NewTorrentsRecheckPostRequestWithFormdataBody(server string, body TorrentsRecheckPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsRecheckPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsRecheckPostRequestWithBody generates requests for TorrentsRecheckPost with any type of body
func NewTorrentsRecheckPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/recheck")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsRemoveCategoriesPostRequestWithFormdataBody calls the generic TorrentsRemoveCategoriesPost builder with application/x-www-form-urlencoded body
func NewTorrentsRemoveCategoriesPostRequestWithFormdataBody(server string, body TorrentsRemoveCategoriesPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsRemoveCategoriesPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsRemoveCategoriesPostRequestWithBody generates requests for TorrentsRemoveCategoriesPost with any type of body
func NewTorrentsRemoveCategoriesPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/removeCategories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsRemoveTagsPostRequestWithFormdataBody calls the generic TorrentsRemoveTagsPost builder with application/x-www-form-urlencoded body
func NewTorrentsRemoveTagsPostRequestWithFormdataBody(server string, body TorrentsRemoveTagsPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsRemoveTagsPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsRemoveTagsPostRequestWithBody generates requests for TorrentsRemoveTagsPost with any type of body
func NewTorrentsRemoveTagsPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/removeTags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsRemoveTrackersPostRequestWithFormdataBody calls the generic TorrentsRemoveTrackersPost builder with application/x-www-form-urlencoded body
func NewTorrentsRemoveTrackersPostRequestWithFormdataBody(server string, body TorrentsRemoveTrackersPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsRemoveTrackersPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsRemoveTrackersPostRequestWithBody generates requests for TorrentsRemoveTrackersPost with any type of body
func NewTorrentsRemoveTrackersPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/removeTrackers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsRenamePostRequestWithFormdataBody calls the generic TorrentsRenamePost builder with application/x-www-form-urlencoded body
func NewTorrentsRenamePostRequestWithFormdataBody(server string, body TorrentsRenamePostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsRenamePostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsRenamePostRequestWithBody generates requests for TorrentsRenamePost with any type of body
func NewTorrentsRenamePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/rename")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsRenameFilePostRequestWithFormdataBody calls the generic TorrentsRenameFilePost builder with application/x-www-form-urlencoded body
func NewTorrentsRenameFilePostRequestWithFormdataBody(server string, body TorrentsRenameFilePostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsRenameFilePostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsRenameFilePostRequestWithBody generates requests for TorrentsRenameFilePost with any type of body
func NewTorrentsRenameFilePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/renameFile")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsRenameFolderPostRequestWithFormdataBody calls the generic TorrentsRenameFolderPost builder with application/x-www-form-urlencoded body
func NewTorrentsRenameFolderPostRequestWithFormdataBody(server string, body TorrentsRenameFolderPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsRenameFolderPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsRenameFolderPostRequestWithBody generates requests for TorrentsRenameFolderPost with any type of body
func NewTorrentsRenameFolderPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/renameFolder")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsResumePostRequestWithFormdataBody calls the generic TorrentsResumePost builder with application/x-www-form-urlencoded body
func NewTorrentsResumePostRequestWithFormdataBody(server string, body TorrentsResumePostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsResumePostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsResumePostRequestWithBody generates requests for TorrentsResumePost with any type of body
func NewTorrentsResumePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/resume")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsSetAutoManagementPostRequestWithFormdataBody calls the generic TorrentsSetAutoManagementPost builder with application/x-www-form-urlencoded body
func NewTorrentsSetAutoManagementPostRequestWithFormdataBody(server string, body TorrentsSetAutoManagementPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsSetAutoManagementPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsSetAutoManagementPostRequestWithBody generates requests for TorrentsSetAutoManagementPost with any type of body
func NewTorrentsSetAutoManagementPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/setAutoManagement")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsSetCategoryPostRequestWithFormdataBody calls the generic TorrentsSetCategoryPost builder with application/x-www-form-urlencoded body
func NewTorrentsSetCategoryPostRequestWithFormdataBody(server string, body TorrentsSetCategoryPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsSetCategoryPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsSetCategoryPostRequestWithBody generates requests for TorrentsSetCategoryPost with any type of body
func NewTorrentsSetCategoryPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/setCategory")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsSetDownloadLimitPostRequestWithFormdataBody calls the generic TorrentsSetDownloadLimitPost builder with application/x-www-form-urlencoded body
func NewTorrentsSetDownloadLimitPostRequestWithFormdataBody(server string, body TorrentsSetDownloadLimitPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsSetDownloadLimitPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsSetDownloadLimitPostRequestWithBody generates requests for TorrentsSetDownloadLimitPost with any type of body
func NewTorrentsSetDownloadLimitPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/setDownloadLimit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsSetForceStartPostRequestWithFormdataBody calls the generic TorrentsSetForceStartPost builder with application/x-www-form-urlencoded body
func NewTorrentsSetForceStartPostRequestWithFormdataBody(server string, body TorrentsSetForceStartPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsSetForceStartPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsSetForceStartPostRequestWithBody generates requests for TorrentsSetForceStartPost with any type of body
func NewTorrentsSetForceStartPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/setForceStart")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsSetLocationPostRequestWithFormdataBody calls the generic TorrentsSetLocationPost builder with application/x-www-form-urlencoded body
func NewTorrentsSetLocationPostRequestWithFormdataBody(server string, body TorrentsSetLocationPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsSetLocationPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsSetLocationPostRequestWithBody generates requests for TorrentsSetLocationPost with any type of body
func NewTorrentsSetLocationPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/setLocation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsSetShareLimitsPostRequestWithFormdataBody calls the generic TorrentsSetShareLimitsPost builder with application/x-www-form-urlencoded body
func NewTorrentsSetShareLimitsPostRequestWithFormdataBody(server string, body TorrentsSetShareLimitsPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsSetShareLimitsPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsSetShareLimitsPostRequestWithBody generates requests for TorrentsSetShareLimitsPost with any type of body
func NewTorrentsSetShareLimitsPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/setShareLimits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsSetSuperSeedingPostRequestWithFormdataBody calls the generic TorrentsSetSuperSeedingPost builder with application/x-www-form-urlencoded body
func NewTorrentsSetSuperSeedingPostRequestWithFormdataBody(server string, body TorrentsSetSuperSeedingPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsSetSuperSeedingPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsSetSuperSeedingPostRequestWithBody generates requests for TorrentsSetSuperSeedingPost with any type of body
func NewTorrentsSetSuperSeedingPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/setSuperSeeding")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsSetUploadLimitPostRequestWithFormdataBody calls the generic TorrentsSetUploadLimitPost builder with application/x-www-form-urlencoded body
func NewTorrentsSetUploadLimitPostRequestWithFormdataBody(server string, body TorrentsSetUploadLimitPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsSetUploadLimitPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsSetUploadLimitPostRequestWithBody generates requests for TorrentsSetUploadLimitPost with any type of body
func NewTorrentsSetUploadLimitPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/setUploadLimit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsTagsGetRequest generates requests for TorrentsTagsGet
func NewTorrentsTagsGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTorrentsToggleFirstLastPiecePrioPostRequestWithFormdataBody calls the generic TorrentsToggleFirstLastPiecePrioPost builder with application/x-www-form-urlencoded body
func NewTorrentsToggleFirstLastPiecePrioPostRequestWithFormdataBody(server string, body TorrentsToggleFirstLastPiecePrioPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsToggleFirstLastPiecePrioPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsToggleFirstLastPiecePrioPostRequestWithBody generates requests for TorrentsToggleFirstLastPiecePrioPost with any type of body
func NewTorrentsToggleFirstLastPiecePrioPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/toggleFirstLastPiecePrio")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsToggleSequentialDownloadPostRequestWithFormdataBody calls the generic TorrentsToggleSequentialDownloadPost builder with application/x-www-form-urlencoded body
func NewTorrentsToggleSequentialDownloadPostRequestWithFormdataBody(server string, body TorrentsToggleSequentialDownloadPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsToggleSequentialDownloadPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsToggleSequentialDownloadPostRequestWithBody generates requests for TorrentsToggleSequentialDownloadPost with any type of body
func NewTorrentsToggleSequentialDownloadPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/toggleSequentialDownload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsTopPrioPostRequestWithFormdataBody calls the generic TorrentsTopPrioPost builder with application/x-www-form-urlencoded body
func NewTorrentsTopPrioPostRequestWithFormdataBody(server string, body TorrentsTopPrioPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsTopPrioPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsTopPrioPostRequestWithBody generates requests for TorrentsTopPrioPost with any type of body
func NewTorrentsTopPrioPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/topPrio")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsTrackersPostRequestWithFormdataBody calls the generic TorrentsTrackersPost builder with application/x-www-form-urlencoded body
func NewTorrentsTrackersPostRequestWithFormdataBody(server string, body TorrentsTrackersPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsTrackersPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsTrackersPostRequestWithBody generates requests for TorrentsTrackersPost with any type of body
func NewTorrentsTrackersPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/trackers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentsUploadLimitPostRequestWithFormdataBody calls the generic TorrentsUploadLimitPost builder with application/x-www-form-urlencoded body
func NewTorrentsUploadLimitPostRequestWithFormdataBody(server string, body TorrentsUploadLimitPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentsUploadLimitPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentsUploadLimitPostRequestWithBody generates requests for TorrentsUploadLimitPost with any type of body
func NewTorrentsUploadLimitPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/uploadLimit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTorrentWebseedsPostRequestWithFormdataBody calls the generic TorrentWebseedsPost builder with application/x-www-form-urlencoded body
func NewTorrentWebseedsPostRequestWithFormdataBody(server string, body TorrentWebseedsPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTorrentWebseedsPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTorrentWebseedsPostRequestWithBody generates requests for TorrentWebseedsPost with any type of body
func NewTorrentWebseedsPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/torrents/webseeds")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTransferBanPeersPostRequestWithFormdataBody calls the generic TransferBanPeersPost builder with application/x-www-form-urlencoded body
func NewTransferBanPeersPostRequestWithFormdataBody(server string, body TransferBanPeersPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTransferBanPeersPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTransferBanPeersPostRequestWithBody generates requests for TransferBanPeersPost with any type of body
func NewTransferBanPeersPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transfer/banPeers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTransferDownloadLimitGetRequest generates requests for TransferDownloadLimitGet
func NewTransferDownloadLimitGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transfer/downloadLimit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTransferInfoGetRequest generates requests for TransferInfoGet
func NewTransferInfoGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transfer/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTransferSetDownloadLimitPostRequestWithFormdataBody calls the generic TransferSetDownloadLimitPost builder with application/x-www-form-urlencoded body
func NewTransferSetDownloadLimitPostRequestWithFormdataBody(server string, body TransferSetDownloadLimitPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTransferSetDownloadLimitPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTransferSetDownloadLimitPostRequestWithBody generates requests for TransferSetDownloadLimitPost with any type of body
func NewTransferSetDownloadLimitPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transfer/setDownloadLimit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTransferSetUploadLimitPostRequestWithFormdataBody calls the generic TransferSetUploadLimitPost builder with application/x-www-form-urlencoded body
func NewTransferSetUploadLimitPostRequestWithFormdataBody(server string, body TransferSetUploadLimitPostFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTransferSetUploadLimitPostRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTransferSetUploadLimitPostRequestWithBody generates requests for TransferSetUploadLimitPost with any type of body
func NewTransferSetUploadLimitPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transfer/setUploadLimit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTransferSpeedLimitsModeGetRequest generates requests for TransferSpeedLimitsModeGet
func NewTransferSpeedLimitsModeGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transfer/speedLimitsMode")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTransferToggleSpeedLimitsModeGetRequest generates requests for TransferToggleSpeedLimitsModeGet
func NewTransferToggleSpeedLimitsModeGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transfer/toggleSpeedLimitsMode")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTransferUploadLimitGetRequest generates requests for TransferUploadLimitGet
func NewTransferUploadLimitGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transfer/uploadLimit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AppBuildInfoGetWithResponse request
	AppBuildInfoGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppBuildInfoGetResponse, error)

	// AppDefaultSavePathGetWithResponse request
	AppDefaultSavePathGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppDefaultSavePathGetResponse, error)

	// AppPreferencesGetWithResponse request
	AppPreferencesGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppPreferencesGetResponse, error)

	// AppSetPreferencesPostWithBodyWithResponse request with any body
	AppSetPreferencesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppSetPreferencesPostResponse, error)

	AppSetPreferencesPostWithFormdataBodyWithResponse(ctx context.Context, body AppSetPreferencesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*AppSetPreferencesPostResponse, error)

	// AppShutdownGetWithResponse request
	AppShutdownGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppShutdownGetResponse, error)

	// AppVersionGetWithResponse request
	AppVersionGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppVersionGetResponse, error)

	// AppWebapiVersionGetWithResponse request
	AppWebapiVersionGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppWebapiVersionGetResponse, error)

	// AuthLoginPostWithBodyWithResponse request with any body
	AuthLoginPostWithBodyWithResponse(ctx context.Context, params *AuthLoginPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthLoginPostResponse, error)

	AuthLoginPostWithFormdataBodyWithResponse(ctx context.Context, params *AuthLoginPostParams, body AuthLoginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*AuthLoginPostResponse, error)

	// AuthLogoutPostWithResponse request
	AuthLogoutPostWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AuthLogoutPostResponse, error)

	// LogMainPostWithBodyWithResponse request with any body
	LogMainPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LogMainPostResponse, error)

	LogMainPostWithFormdataBodyWithResponse(ctx context.Context, body LogMainPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*LogMainPostResponse, error)

	// LogPeersPostWithBodyWithResponse request with any body
	LogPeersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LogPeersPostResponse, error)

	LogPeersPostWithFormdataBodyWithResponse(ctx context.Context, body LogPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*LogPeersPostResponse, error)

	// RssAddFeedPostWithBodyWithResponse request with any body
	RssAddFeedPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssAddFeedPostResponse, error)

	RssAddFeedPostWithFormdataBodyWithResponse(ctx context.Context, body RssAddFeedPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssAddFeedPostResponse, error)

	// RssAddFolderPostWithBodyWithResponse request with any body
	RssAddFolderPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssAddFolderPostResponse, error)

	RssAddFolderPostWithFormdataBodyWithResponse(ctx context.Context, body RssAddFolderPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssAddFolderPostResponse, error)

	// RssItemsPostWithBodyWithResponse request with any body
	RssItemsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssItemsPostResponse, error)

	RssItemsPostWithFormdataBodyWithResponse(ctx context.Context, body RssItemsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssItemsPostResponse, error)

	// RssMarkAsReadPostWithBodyWithResponse request with any body
	RssMarkAsReadPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssMarkAsReadPostResponse, error)

	RssMarkAsReadPostWithFormdataBodyWithResponse(ctx context.Context, body RssMarkAsReadPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssMarkAsReadPostResponse, error)

	// RssMatchingArticlesPostWithBodyWithResponse request with any body
	RssMatchingArticlesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssMatchingArticlesPostResponse, error)

	RssMatchingArticlesPostWithFormdataBodyWithResponse(ctx context.Context, body RssMatchingArticlesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssMatchingArticlesPostResponse, error)

	// RssMoveItemPostWithBodyWithResponse request with any body
	RssMoveItemPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssMoveItemPostResponse, error)

	RssMoveItemPostWithFormdataBodyWithResponse(ctx context.Context, body RssMoveItemPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssMoveItemPostResponse, error)

	// RssRefreshItemPostWithBodyWithResponse request with any body
	RssRefreshItemPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssRefreshItemPostResponse, error)

	RssRefreshItemPostWithFormdataBodyWithResponse(ctx context.Context, body RssRefreshItemPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssRefreshItemPostResponse, error)

	// RssRemoveItemPostWithBodyWithResponse request with any body
	RssRemoveItemPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssRemoveItemPostResponse, error)

	RssRemoveItemPostWithFormdataBodyWithResponse(ctx context.Context, body RssRemoveItemPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssRemoveItemPostResponse, error)

	// RssRemoveRulePostWithBodyWithResponse request with any body
	RssRemoveRulePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssRemoveRulePostResponse, error)

	RssRemoveRulePostWithFormdataBodyWithResponse(ctx context.Context, body RssRemoveRulePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssRemoveRulePostResponse, error)

	// RssRenameRulePostWithBodyWithResponse request with any body
	RssRenameRulePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssRenameRulePostResponse, error)

	RssRenameRulePostWithFormdataBodyWithResponse(ctx context.Context, body RssRenameRulePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssRenameRulePostResponse, error)

	// RssRulesGetWithResponse request
	RssRulesGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RssRulesGetResponse, error)

	// RssSetRulePostWithBodyWithResponse request with any body
	RssSetRulePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssSetRulePostResponse, error)

	RssSetRulePostWithFormdataBodyWithResponse(ctx context.Context, body RssSetRulePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssSetRulePostResponse, error)

	// SearchDeletePostWithBodyWithResponse request with any body
	SearchDeletePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDeletePostResponse, error)

	SearchDeletePostWithFormdataBodyWithResponse(ctx context.Context, body SearchDeletePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchDeletePostResponse, error)

	// SearchEnablePluginPostWithBodyWithResponse request with any body
	SearchEnablePluginPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchEnablePluginPostResponse, error)

	SearchEnablePluginPostWithFormdataBodyWithResponse(ctx context.Context, body SearchEnablePluginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchEnablePluginPostResponse, error)

	// SearchInstallPluginPostWithBodyWithResponse request with any body
	SearchInstallPluginPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchInstallPluginPostResponse, error)

	SearchInstallPluginPostWithFormdataBodyWithResponse(ctx context.Context, body SearchInstallPluginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchInstallPluginPostResponse, error)

	// SearchPluginsGetWithResponse request
	SearchPluginsGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SearchPluginsGetResponse, error)

	// SearchResultsPostWithBodyWithResponse request with any body
	SearchResultsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchResultsPostResponse, error)

	SearchResultsPostWithFormdataBodyWithResponse(ctx context.Context, body SearchResultsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchResultsPostResponse, error)

	// SearchStartPostWithBodyWithResponse request with any body
	SearchStartPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchStartPostResponse, error)

	SearchStartPostWithFormdataBodyWithResponse(ctx context.Context, body SearchStartPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchStartPostResponse, error)

	// SearchStatusPostWithBodyWithResponse request with any body
	SearchStatusPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchStatusPostResponse, error)

	SearchStatusPostWithFormdataBodyWithResponse(ctx context.Context, body SearchStatusPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchStatusPostResponse, error)

	// SearchStopPostWithBodyWithResponse request with any body
	SearchStopPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchStopPostResponse, error)

	SearchStopPostWithFormdataBodyWithResponse(ctx context.Context, body SearchStopPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchStopPostResponse, error)

	// SearchUninstallPluginPostWithBodyWithResponse request with any body
	SearchUninstallPluginPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUninstallPluginPostResponse, error)

	SearchUninstallPluginPostWithFormdataBodyWithResponse(ctx context.Context, body SearchUninstallPluginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchUninstallPluginPostResponse, error)

	// SearchUpdatePluginsPostWithResponse request
	SearchUpdatePluginsPostWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SearchUpdatePluginsPostResponse, error)

	// SyncMaindataPostWithBodyWithResponse request with any body
	SyncMaindataPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncMaindataPostResponse, error)

	SyncMaindataPostWithFormdataBodyWithResponse(ctx context.Context, body SyncMaindataPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SyncMaindataPostResponse, error)

	// SyncTorrentPeersPostWithBodyWithResponse request with any body
	SyncTorrentPeersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncTorrentPeersPostResponse, error)

	SyncTorrentPeersPostWithFormdataBodyWithResponse(ctx context.Context, body SyncTorrentPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SyncTorrentPeersPostResponse, error)

	// TorrentsAddPostWithBodyWithResponse request with any body
	TorrentsAddPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsAddPostResponse, error)

	// TorrentsAddPeersPostWithBodyWithResponse request with any body
	TorrentsAddPeersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsAddPeersPostResponse, error)

	TorrentsAddPeersPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsAddPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsAddPeersPostResponse, error)

	// TorrentsAddTagsPostWithBodyWithResponse request with any body
	TorrentsAddTagsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsAddTagsPostResponse, error)

	TorrentsAddTagsPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsAddTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsAddTagsPostResponse, error)

	// TorrentsAddTrackersPostWithBodyWithResponse request with any body
	TorrentsAddTrackersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsAddTrackersPostResponse, error)

	TorrentsAddTrackersPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsAddTrackersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsAddTrackersPostResponse, error)

	// TorrentsBottomPrioPostWithBodyWithResponse request with any body
	TorrentsBottomPrioPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsBottomPrioPostResponse, error)

	TorrentsBottomPrioPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsBottomPrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsBottomPrioPostResponse, error)

	// TorrentsCategoriesGetWithResponse request
	TorrentsCategoriesGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TorrentsCategoriesGetResponse, error)

	// TorrentsCreateCategoryPostWithBodyWithResponse request with any body
	TorrentsCreateCategoryPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsCreateCategoryPostResponse, error)

	TorrentsCreateCategoryPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsCreateCategoryPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsCreateCategoryPostResponse, error)

	// TorrentsCreateTagsPostWithBodyWithResponse request with any body
	TorrentsCreateTagsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsCreateTagsPostResponse, error)

	TorrentsCreateTagsPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsCreateTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsCreateTagsPostResponse, error)

	// TorrentsDecreasePrioPostWithBodyWithResponse request with any body
	TorrentsDecreasePrioPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsDecreasePrioPostResponse, error)

	TorrentsDecreasePrioPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsDecreasePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsDecreasePrioPostResponse, error)

	// TorrentsDeletePostWithBodyWithResponse request with any body
	TorrentsDeletePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsDeletePostResponse, error)

	TorrentsDeletePostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsDeletePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsDeletePostResponse, error)

	// TorrentsDeleteTagsPostWithBodyWithResponse request with any body
	TorrentsDeleteTagsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsDeleteTagsPostResponse, error)

	TorrentsDeleteTagsPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsDeleteTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsDeleteTagsPostResponse, error)

	// TorrentsDownloadLimitPostWithBodyWithResponse request with any body
	TorrentsDownloadLimitPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsDownloadLimitPostResponse, error)

	TorrentsDownloadLimitPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsDownloadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsDownloadLimitPostResponse, error)

	// TorrentsEditCategoryPostWithBodyWithResponse request with any body
	TorrentsEditCategoryPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsEditCategoryPostResponse, error)

	TorrentsEditCategoryPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsEditCategoryPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsEditCategoryPostResponse, error)

	// TorrentsEditTrackerPostWithBodyWithResponse request with any body
	TorrentsEditTrackerPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsEditTrackerPostResponse, error)

	TorrentsEditTrackerPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsEditTrackerPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsEditTrackerPostResponse, error)

	// TorrentsFilePrioPostWithBodyWithResponse request with any body
	TorrentsFilePrioPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsFilePrioPostResponse, error)

	TorrentsFilePrioPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsFilePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsFilePrioPostResponse, error)

	// TorrentsFilesPostWithBodyWithResponse request with any body
	TorrentsFilesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsFilesPostResponse, error)

	TorrentsFilesPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsFilesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsFilesPostResponse, error)

	// TorrentsIncreasePrioPostWithBodyWithResponse request with any body
	TorrentsIncreasePrioPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsIncreasePrioPostResponse, error)

	TorrentsIncreasePrioPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsIncreasePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsIncreasePrioPostResponse, error)

	// TorrentsInfoGetWithResponse request
	TorrentsInfoGetWithResponse(ctx context.Context, params *TorrentsInfoGetParams, reqEditors ...RequestEditorFn) (*TorrentsInfoGetResponse, error)

	// TorrentsInfoPostWithBodyWithResponse request with any body
	TorrentsInfoPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsInfoPostResponse, error)

	TorrentsInfoPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsInfoPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsInfoPostResponse, error)

	// TorrentsPausePostWithBodyWithResponse request with any body
	TorrentsPausePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsPausePostResponse, error)

	TorrentsPausePostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsPausePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsPausePostResponse, error)

	// TorrentsPieceHashesPostWithBodyWithResponse request with any body
	TorrentsPieceHashesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsPieceHashesPostResponse, error)

	TorrentsPieceHashesPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsPieceHashesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsPieceHashesPostResponse, error)

	// TorrentsPieceStatesPostWithBodyWithResponse request with any body
	TorrentsPieceStatesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsPieceStatesPostResponse, error)

	TorrentsPieceStatesPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsPieceStatesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsPieceStatesPostResponse, error)

	// TorrentsPropertiesPostWithBodyWithResponse request with any body
	TorrentsPropertiesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsPropertiesPostResponse, error)

	TorrentsPropertiesPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsPropertiesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsPropertiesPostResponse, error)

	// TorrentsReannouncePostWithBodyWithResponse request with any body
	TorrentsReannouncePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsReannouncePostResponse, error)

	TorrentsReannouncePostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsReannouncePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsReannouncePostResponse, error)

	// TorrentsRecheckPostWithBodyWithResponse request with any body
	TorrentsRecheckPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRecheckPostResponse, error)

	TorrentsRecheckPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRecheckPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRecheckPostResponse, error)

	// TorrentsRemoveCategoriesPostWithBodyWithResponse request with any body
	TorrentsRemoveCategoriesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRemoveCategoriesPostResponse, error)

	TorrentsRemoveCategoriesPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRemoveCategoriesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRemoveCategoriesPostResponse, error)

	// TorrentsRemoveTagsPostWithBodyWithResponse request with any body
	TorrentsRemoveTagsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRemoveTagsPostResponse, error)

	TorrentsRemoveTagsPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRemoveTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRemoveTagsPostResponse, error)

	// TorrentsRemoveTrackersPostWithBodyWithResponse request with any body
	TorrentsRemoveTrackersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRemoveTrackersPostResponse, error)

	TorrentsRemoveTrackersPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRemoveTrackersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRemoveTrackersPostResponse, error)

	// TorrentsRenamePostWithBodyWithResponse request with any body
	TorrentsRenamePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRenamePostResponse, error)

	TorrentsRenamePostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRenamePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRenamePostResponse, error)

	// TorrentsRenameFilePostWithBodyWithResponse request with any body
	TorrentsRenameFilePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRenameFilePostResponse, error)

	TorrentsRenameFilePostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRenameFilePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRenameFilePostResponse, error)

	// TorrentsRenameFolderPostWithBodyWithResponse request with any body
	TorrentsRenameFolderPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRenameFolderPostResponse, error)

	TorrentsRenameFolderPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRenameFolderPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRenameFolderPostResponse, error)

	// TorrentsResumePostWithBodyWithResponse request with any body
	TorrentsResumePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsResumePostResponse, error)

	TorrentsResumePostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsResumePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsResumePostResponse, error)

	// TorrentsSetAutoManagementPostWithBodyWithResponse request with any body
	TorrentsSetAutoManagementPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetAutoManagementPostResponse, error)

	TorrentsSetAutoManagementPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetAutoManagementPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetAutoManagementPostResponse, error)

	// TorrentsSetCategoryPostWithBodyWithResponse request with any body
	TorrentsSetCategoryPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetCategoryPostResponse, error)

	TorrentsSetCategoryPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetCategoryPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetCategoryPostResponse, error)

	// TorrentsSetDownloadLimitPostWithBodyWithResponse request with any body
	TorrentsSetDownloadLimitPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetDownloadLimitPostResponse, error)

	TorrentsSetDownloadLimitPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetDownloadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetDownloadLimitPostResponse, error)

	// TorrentsSetForceStartPostWithBodyWithResponse request with any body
	TorrentsSetForceStartPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetForceStartPostResponse, error)

	TorrentsSetForceStartPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetForceStartPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetForceStartPostResponse, error)

	// TorrentsSetLocationPostWithBodyWithResponse request with any body
	TorrentsSetLocationPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetLocationPostResponse, error)

	TorrentsSetLocationPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetLocationPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetLocationPostResponse, error)

	// TorrentsSetShareLimitsPostWithBodyWithResponse request with any body
	TorrentsSetShareLimitsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetShareLimitsPostResponse, error)

	TorrentsSetShareLimitsPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetShareLimitsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetShareLimitsPostResponse, error)

	// TorrentsSetSuperSeedingPostWithBodyWithResponse request with any body
	TorrentsSetSuperSeedingPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetSuperSeedingPostResponse, error)

	TorrentsSetSuperSeedingPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetSuperSeedingPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetSuperSeedingPostResponse, error)

	// TorrentsSetUploadLimitPostWithBodyWithResponse request with any body
	TorrentsSetUploadLimitPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetUploadLimitPostResponse, error)

	TorrentsSetUploadLimitPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetUploadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetUploadLimitPostResponse, error)

	// TorrentsTagsGetWithResponse request
	TorrentsTagsGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TorrentsTagsGetResponse, error)

	// TorrentsToggleFirstLastPiecePrioPostWithBodyWithResponse request with any body
	TorrentsToggleFirstLastPiecePrioPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsToggleFirstLastPiecePrioPostResponse, error)

	TorrentsToggleFirstLastPiecePrioPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsToggleFirstLastPiecePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsToggleFirstLastPiecePrioPostResponse, error)

	// TorrentsToggleSequentialDownloadPostWithBodyWithResponse request with any body
	TorrentsToggleSequentialDownloadPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsToggleSequentialDownloadPostResponse, error)

	TorrentsToggleSequentialDownloadPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsToggleSequentialDownloadPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsToggleSequentialDownloadPostResponse, error)

	// TorrentsTopPrioPostWithBodyWithResponse request with any body
	TorrentsTopPrioPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsTopPrioPostResponse, error)

	TorrentsTopPrioPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsTopPrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsTopPrioPostResponse, error)

	// TorrentsTrackersPostWithBodyWithResponse request with any body
	TorrentsTrackersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsTrackersPostResponse, error)

	TorrentsTrackersPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsTrackersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsTrackersPostResponse, error)

	// TorrentsUploadLimitPostWithBodyWithResponse request with any body
	TorrentsUploadLimitPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsUploadLimitPostResponse, error)

	TorrentsUploadLimitPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsUploadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsUploadLimitPostResponse, error)

	// TorrentWebseedsPostWithBodyWithResponse request with any body
	TorrentWebseedsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentWebseedsPostResponse, error)

	TorrentWebseedsPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentWebseedsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentWebseedsPostResponse, error)

	// TransferBanPeersPostWithBodyWithResponse request with any body
	TransferBanPeersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransferBanPeersPostResponse, error)

	TransferBanPeersPostWithFormdataBodyWithResponse(ctx context.Context, body TransferBanPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TransferBanPeersPostResponse, error)

	// TransferDownloadLimitGetWithResponse request
	TransferDownloadLimitGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TransferDownloadLimitGetResponse, error)

	// TransferInfoGetWithResponse request
	TransferInfoGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TransferInfoGetResponse, error)

	// TransferSetDownloadLimitPostWithBodyWithResponse request with any body
	TransferSetDownloadLimitPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransferSetDownloadLimitPostResponse, error)

	TransferSetDownloadLimitPostWithFormdataBodyWithResponse(ctx context.Context, body TransferSetDownloadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TransferSetDownloadLimitPostResponse, error)

	// TransferSetUploadLimitPostWithBodyWithResponse request with any body
	TransferSetUploadLimitPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransferSetUploadLimitPostResponse, error)

	TransferSetUploadLimitPostWithFormdataBodyWithResponse(ctx context.Context, body TransferSetUploadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TransferSetUploadLimitPostResponse, error)

	// TransferSpeedLimitsModeGetWithResponse request
	TransferSpeedLimitsModeGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TransferSpeedLimitsModeGetResponse, error)

	// TransferToggleSpeedLimitsModeGetWithResponse request
	TransferToggleSpeedLimitsModeGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TransferToggleSpeedLimitsModeGetResponse, error)

	// TransferUploadLimitGetWithResponse request
	TransferUploadLimitGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TransferUploadLimitGetResponse, error)
}

type AppBuildInfoGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildInfo
}

// Status returns HTTPResponse.Status
func (r AppBuildInfoGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppBuildInfoGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppDefaultSavePathGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AppDefaultSavePathGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppDefaultSavePathGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppPreferencesGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Preferences
}

// Status returns HTTPResponse.Status
func (r AppPreferencesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppPreferencesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppSetPreferencesPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AppSetPreferencesPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppSetPreferencesPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppShutdownGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AppShutdownGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppShutdownGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppVersionGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AppVersionGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppVersionGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppWebapiVersionGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AppWebapiVersionGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppWebapiVersionGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthLoginPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AuthLoginPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthLoginPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthLogoutPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AuthLogoutPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthLogoutPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogMainPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MainLog
}

// Status returns HTTPResponse.Status
func (r LogMainPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogMainPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogPeersPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PeersLog
}

// Status returns HTTPResponse.Status
func (r LogPeersPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogPeersPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RssAddFeedPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RssAddFeedPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RssAddFeedPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RssAddFolderPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RssAddFolderPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RssAddFolderPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RssItemsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r RssItemsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RssItemsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RssMarkAsReadPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RssMarkAsReadPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RssMarkAsReadPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RssMatchingArticlesPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string][]string
}

// Status returns HTTPResponse.Status
func (r RssMatchingArticlesPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RssMatchingArticlesPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RssMoveItemPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RssMoveItemPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RssMoveItemPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RssRefreshItemPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RssRefreshItemPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RssRefreshItemPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RssRemoveItemPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RssRemoveItemPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RssRemoveItemPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RssRemoveRulePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RssRemoveRulePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RssRemoveRulePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RssRenameRulePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RssRenameRulePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RssRenameRulePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RssRulesGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]RssRuleDef
}

// Status returns HTTPResponse.Status
func (r RssRulesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RssRulesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RssSetRulePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RssSetRulePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RssSetRulePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchDeletePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchDeletePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchDeletePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchEnablePluginPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchEnablePluginPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchEnablePluginPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchInstallPluginPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchInstallPluginPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchInstallPluginPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchPluginsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SearchPlugin
}

// Status returns HTTPResponse.Status
func (r SearchPluginsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchPluginsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchResultsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchResults
}

// Status returns HTTPResponse.Status
func (r SearchResultsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchResultsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchStartPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchJob
}

// Status returns HTTPResponse.Status
func (r SearchStartPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchStartPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchStatusPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SearchJobStatus
}

// Status returns HTTPResponse.Status
func (r SearchStatusPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchStatusPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchStopPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchStopPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchStopPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchUninstallPluginPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchUninstallPluginPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchUninstallPluginPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchUpdatePluginsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SearchUpdatePluginsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchUpdatePluginsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncMaindataPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MainData
}

// Status returns HTTPResponse.Status
func (r SyncMaindataPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncMaindataPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncTorrentPeersPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TorrentPeers
}

// Status returns HTTPResponse.Status
func (r SyncTorrentPeersPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncTorrentPeersPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsAddPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsAddPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsAddPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsAddPeersPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsAddPeersPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsAddPeersPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsAddTagsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsAddTagsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsAddTagsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsAddTrackersPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsAddTrackersPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsAddTrackersPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsBottomPrioPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsBottomPrioPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsBottomPrioPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsCategoriesGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]TorrentsCategory
}

// Status returns HTTPResponse.Status
func (r TorrentsCategoriesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsCategoriesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsCreateCategoryPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsCreateCategoryPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsCreateCategoryPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsCreateTagsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsCreateTagsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsCreateTagsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsDecreasePrioPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsDecreasePrioPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsDecreasePrioPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsDeletePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsDeletePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsDeletePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsDeleteTagsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsDeleteTagsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsDeleteTagsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsDownloadLimitPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TorrentsLimit
}

// Status returns HTTPResponse.Status
func (r TorrentsDownloadLimitPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsDownloadLimitPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsEditCategoryPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsEditCategoryPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsEditCategoryPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsEditTrackerPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsEditTrackerPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsEditTrackerPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsFilePrioPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsFilePrioPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsFilePrioPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsFilesPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TorrentsFiles
}

// Status returns HTTPResponse.Status
func (r TorrentsFilesPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsFilesPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsIncreasePrioPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsIncreasePrioPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsIncreasePrioPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsInfoGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TorrentInfo
}

// Status returns HTTPResponse.Status
func (r TorrentsInfoGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsInfoGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsInfoPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TorrentInfo
}

// Status returns HTTPResponse.Status
func (r TorrentsInfoPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsInfoPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsPausePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsPausePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsPausePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsPieceHashesPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r TorrentsPieceHashesPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsPieceHashesPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsPieceStatesPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]int32
}

// Status returns HTTPResponse.Status
func (r TorrentsPieceStatesPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsPieceStatesPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsPropertiesPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TorrentsProperties
}

// Status returns HTTPResponse.Status
func (r TorrentsPropertiesPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsPropertiesPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsReannouncePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsReannouncePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsReannouncePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsRecheckPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsRecheckPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsRecheckPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsRemoveCategoriesPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsRemoveCategoriesPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsRemoveCategoriesPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsRemoveTagsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsRemoveTagsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsRemoveTagsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsRemoveTrackersPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsRemoveTrackersPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsRemoveTrackersPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsRenamePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsRenamePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsRenamePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsRenameFilePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsRenameFilePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsRenameFilePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsRenameFolderPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsRenameFolderPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsRenameFolderPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsResumePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsResumePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsResumePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsSetAutoManagementPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsSetAutoManagementPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsSetAutoManagementPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsSetCategoryPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsSetCategoryPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsSetCategoryPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsSetDownloadLimitPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsSetDownloadLimitPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsSetDownloadLimitPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsSetForceStartPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsSetForceStartPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsSetForceStartPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsSetLocationPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsSetLocationPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsSetLocationPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsSetShareLimitsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsSetShareLimitsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsSetShareLimitsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsSetSuperSeedingPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsSetSuperSeedingPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsSetSuperSeedingPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsSetUploadLimitPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsSetUploadLimitPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsSetUploadLimitPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsTagsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r TorrentsTagsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsTagsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsToggleFirstLastPiecePrioPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsToggleFirstLastPiecePrioPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsToggleFirstLastPiecePrioPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsToggleSequentialDownloadPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsToggleSequentialDownloadPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsToggleSequentialDownloadPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsTopPrioPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TorrentsTopPrioPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsTopPrioPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsTrackersPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TorrentsTrackers
}

// Status returns HTTPResponse.Status
func (r TorrentsTrackersPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsTrackersPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentsUploadLimitPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TorrentsLimit
}

// Status returns HTTPResponse.Status
func (r TorrentsUploadLimitPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentsUploadLimitPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TorrentWebseedsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TorrentsWebseeds
}

// Status returns HTTPResponse.Status
func (r TorrentWebseedsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TorrentWebseedsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransferBanPeersPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TransferBanPeersPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransferBanPeersPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransferDownloadLimitGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TransferDownloadLimitGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransferDownloadLimitGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransferInfoGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransferInfo
}

// Status returns HTTPResponse.Status
func (r TransferInfoGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransferInfoGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransferSetDownloadLimitPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TransferSetDownloadLimitPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransferSetDownloadLimitPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransferSetUploadLimitPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TransferSetUploadLimitPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransferSetUploadLimitPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransferSpeedLimitsModeGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TransferSpeedLimitsModeGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransferSpeedLimitsModeGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransferToggleSpeedLimitsModeGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TransferToggleSpeedLimitsModeGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransferToggleSpeedLimitsModeGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransferUploadLimitGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TransferUploadLimitGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransferUploadLimitGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AppBuildInfoGetWithResponse request returning *AppBuildInfoGetResponse
func (c *ClientWithResponses) AppBuildInfoGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppBuildInfoGetResponse, error) {
	rsp, err := c.AppBuildInfoGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppBuildInfoGetResponse(rsp)
}

// AppDefaultSavePathGetWithResponse request returning *AppDefaultSavePathGetResponse
func (c *ClientWithResponses) AppDefaultSavePathGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppDefaultSavePathGetResponse, error) {
	rsp, err := c.AppDefaultSavePathGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppDefaultSavePathGetResponse(rsp)
}

// AppPreferencesGetWithResponse request returning *AppPreferencesGetResponse
func (c *ClientWithResponses) AppPreferencesGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppPreferencesGetResponse, error) {
	rsp, err := c.AppPreferencesGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppPreferencesGetResponse(rsp)
}

// AppSetPreferencesPostWithBodyWithResponse request with arbitrary body returning *AppSetPreferencesPostResponse
func (c *ClientWithResponses) AppSetPreferencesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppSetPreferencesPostResponse, error) {
	rsp, err := c.AppSetPreferencesPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppSetPreferencesPostResponse(rsp)
}

func (c *ClientWithResponses) AppSetPreferencesPostWithFormdataBodyWithResponse(ctx context.Context, body AppSetPreferencesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*AppSetPreferencesPostResponse, error) {
	rsp, err := c.AppSetPreferencesPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppSetPreferencesPostResponse(rsp)
}

// AppShutdownGetWithResponse request returning *AppShutdownGetResponse
func (c *ClientWithResponses) AppShutdownGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppShutdownGetResponse, error) {
	rsp, err := c.AppShutdownGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppShutdownGetResponse(rsp)
}

// AppVersionGetWithResponse request returning *AppVersionGetResponse
func (c *ClientWithResponses) AppVersionGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppVersionGetResponse, error) {
	rsp, err := c.AppVersionGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppVersionGetResponse(rsp)
}

// AppWebapiVersionGetWithResponse request returning *AppWebapiVersionGetResponse
func (c *ClientWithResponses) AppWebapiVersionGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppWebapiVersionGetResponse, error) {
	rsp, err := c.AppWebapiVersionGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppWebapiVersionGetResponse(rsp)
}

// AuthLoginPostWithBodyWithResponse request with arbitrary body returning *AuthLoginPostResponse
func (c *ClientWithResponses) AuthLoginPostWithBodyWithResponse(ctx context.Context, params *AuthLoginPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthLoginPostResponse, error) {
	rsp, err := c.AuthLoginPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthLoginPostResponse(rsp)
}

func (c *ClientWithResponses) AuthLoginPostWithFormdataBodyWithResponse(ctx context.Context, params *AuthLoginPostParams, body AuthLoginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*AuthLoginPostResponse, error) {
	rsp, err := c.AuthLoginPostWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthLoginPostResponse(rsp)
}

// AuthLogoutPostWithResponse request returning *AuthLogoutPostResponse
func (c *ClientWithResponses) AuthLogoutPostWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AuthLogoutPostResponse, error) {
	rsp, err := c.AuthLogoutPost(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthLogoutPostResponse(rsp)
}

// LogMainPostWithBodyWithResponse request with arbitrary body returning *LogMainPostResponse
func (c *ClientWithResponses) LogMainPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LogMainPostResponse, error) {
	rsp, err := c.LogMainPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogMainPostResponse(rsp)
}

func (c *ClientWithResponses) LogMainPostWithFormdataBodyWithResponse(ctx context.Context, body LogMainPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*LogMainPostResponse, error) {
	rsp, err := c.LogMainPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogMainPostResponse(rsp)
}

// LogPeersPostWithBodyWithResponse request with arbitrary body returning *LogPeersPostResponse
func (c *ClientWithResponses) LogPeersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LogPeersPostResponse, error) {
	rsp, err := c.LogPeersPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogPeersPostResponse(rsp)
}

func (c *ClientWithResponses) LogPeersPostWithFormdataBodyWithResponse(ctx context.Context, body LogPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*LogPeersPostResponse, error) {
	rsp, err := c.LogPeersPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogPeersPostResponse(rsp)
}

// RssAddFeedPostWithBodyWithResponse request with arbitrary body returning *RssAddFeedPostResponse
func (c *ClientWithResponses) RssAddFeedPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssAddFeedPostResponse, error) {
	rsp, err := c.RssAddFeedPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssAddFeedPostResponse(rsp)
}

func (c *ClientWithResponses) RssAddFeedPostWithFormdataBodyWithResponse(ctx context.Context, body RssAddFeedPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssAddFeedPostResponse, error) {
	rsp, err := c.RssAddFeedPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssAddFeedPostResponse(rsp)
}

// RssAddFolderPostWithBodyWithResponse request with arbitrary body returning *RssAddFolderPostResponse
func (c *ClientWithResponses) RssAddFolderPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssAddFolderPostResponse, error) {
	rsp, err := c.RssAddFolderPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssAddFolderPostResponse(rsp)
}

func (c *ClientWithResponses) RssAddFolderPostWithFormdataBodyWithResponse(ctx context.Context, body RssAddFolderPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssAddFolderPostResponse, error) {
	rsp, err := c.RssAddFolderPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssAddFolderPostResponse(rsp)
}

// RssItemsPostWithBodyWithResponse request with arbitrary body returning *RssItemsPostResponse
func (c *ClientWithResponses) RssItemsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssItemsPostResponse, error) {
	rsp, err := c.RssItemsPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssItemsPostResponse(rsp)
}

func (c *ClientWithResponses) RssItemsPostWithFormdataBodyWithResponse(ctx context.Context, body RssItemsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssItemsPostResponse, error) {
	rsp, err := c.RssItemsPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssItemsPostResponse(rsp)
}

// RssMarkAsReadPostWithBodyWithResponse request with arbitrary body returning *RssMarkAsReadPostResponse
func (c *ClientWithResponses) RssMarkAsReadPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssMarkAsReadPostResponse, error) {
	rsp, err := c.RssMarkAsReadPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssMarkAsReadPostResponse(rsp)
}

func (c *ClientWithResponses) RssMarkAsReadPostWithFormdataBodyWithResponse(ctx context.Context, body RssMarkAsReadPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssMarkAsReadPostResponse, error) {
	rsp, err := c.RssMarkAsReadPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssMarkAsReadPostResponse(rsp)
}

// RssMatchingArticlesPostWithBodyWithResponse request with arbitrary body returning *RssMatchingArticlesPostResponse
func (c *ClientWithResponses) RssMatchingArticlesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssMatchingArticlesPostResponse, error) {
	rsp, err := c.RssMatchingArticlesPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssMatchingArticlesPostResponse(rsp)
}

func (c *ClientWithResponses) RssMatchingArticlesPostWithFormdataBodyWithResponse(ctx context.Context, body RssMatchingArticlesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssMatchingArticlesPostResponse, error) {
	rsp, err := c.RssMatchingArticlesPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssMatchingArticlesPostResponse(rsp)
}

// RssMoveItemPostWithBodyWithResponse request with arbitrary body returning *RssMoveItemPostResponse
func (c *ClientWithResponses) RssMoveItemPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssMoveItemPostResponse, error) {
	rsp, err := c.RssMoveItemPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssMoveItemPostResponse(rsp)
}

func (c *ClientWithResponses) RssMoveItemPostWithFormdataBodyWithResponse(ctx context.Context, body RssMoveItemPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssMoveItemPostResponse, error) {
	rsp, err := c.RssMoveItemPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssMoveItemPostResponse(rsp)
}

// RssRefreshItemPostWithBodyWithResponse request with arbitrary body returning *RssRefreshItemPostResponse
func (c *ClientWithResponses) RssRefreshItemPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssRefreshItemPostResponse, error) {
	rsp, err := c.RssRefreshItemPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssRefreshItemPostResponse(rsp)
}

func (c *ClientWithResponses) RssRefreshItemPostWithFormdataBodyWithResponse(ctx context.Context, body RssRefreshItemPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssRefreshItemPostResponse, error) {
	rsp, err := c.RssRefreshItemPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssRefreshItemPostResponse(rsp)
}

// RssRemoveItemPostWithBodyWithResponse request with arbitrary body returning *RssRemoveItemPostResponse
func (c *ClientWithResponses) RssRemoveItemPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssRemoveItemPostResponse, error) {
	rsp, err := c.RssRemoveItemPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssRemoveItemPostResponse(rsp)
}

func (c *ClientWithResponses) RssRemoveItemPostWithFormdataBodyWithResponse(ctx context.Context, body RssRemoveItemPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssRemoveItemPostResponse, error) {
	rsp, err := c.RssRemoveItemPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssRemoveItemPostResponse(rsp)
}

// RssRemoveRulePostWithBodyWithResponse request with arbitrary body returning *RssRemoveRulePostResponse
func (c *ClientWithResponses) RssRemoveRulePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssRemoveRulePostResponse, error) {
	rsp, err := c.RssRemoveRulePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssRemoveRulePostResponse(rsp)
}

func (c *ClientWithResponses) RssRemoveRulePostWithFormdataBodyWithResponse(ctx context.Context, body RssRemoveRulePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssRemoveRulePostResponse, error) {
	rsp, err := c.RssRemoveRulePostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssRemoveRulePostResponse(rsp)
}

// RssRenameRulePostWithBodyWithResponse request with arbitrary body returning *RssRenameRulePostResponse
func (c *ClientWithResponses) RssRenameRulePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssRenameRulePostResponse, error) {
	rsp, err := c.RssRenameRulePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssRenameRulePostResponse(rsp)
}

func (c *ClientWithResponses) RssRenameRulePostWithFormdataBodyWithResponse(ctx context.Context, body RssRenameRulePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssRenameRulePostResponse, error) {
	rsp, err := c.RssRenameRulePostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssRenameRulePostResponse(rsp)
}

// RssRulesGetWithResponse request returning *RssRulesGetResponse
func (c *ClientWithResponses) RssRulesGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RssRulesGetResponse, error) {
	rsp, err := c.RssRulesGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssRulesGetResponse(rsp)
}

// RssSetRulePostWithBodyWithResponse request with arbitrary body returning *RssSetRulePostResponse
func (c *ClientWithResponses) RssSetRulePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RssSetRulePostResponse, error) {
	rsp, err := c.RssSetRulePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssSetRulePostResponse(rsp)
}

func (c *ClientWithResponses) RssSetRulePostWithFormdataBodyWithResponse(ctx context.Context, body RssSetRulePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*RssSetRulePostResponse, error) {
	rsp, err := c.RssSetRulePostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRssSetRulePostResponse(rsp)
}

// SearchDeletePostWithBodyWithResponse request with arbitrary body returning *SearchDeletePostResponse
func (c *ClientWithResponses) SearchDeletePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDeletePostResponse, error) {
	rsp, err := c.SearchDeletePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDeletePostResponse(rsp)
}

func (c *ClientWithResponses) SearchDeletePostWithFormdataBodyWithResponse(ctx context.Context, body SearchDeletePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchDeletePostResponse, error) {
	rsp, err := c.SearchDeletePostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDeletePostResponse(rsp)
}

// SearchEnablePluginPostWithBodyWithResponse request with arbitrary body returning *SearchEnablePluginPostResponse
func (c *ClientWithResponses) SearchEnablePluginPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchEnablePluginPostResponse, error) {
	rsp, err := c.SearchEnablePluginPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchEnablePluginPostResponse(rsp)
}

func (c *ClientWithResponses) SearchEnablePluginPostWithFormdataBodyWithResponse(ctx context.Context, body SearchEnablePluginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchEnablePluginPostResponse, error) {
	rsp, err := c.SearchEnablePluginPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchEnablePluginPostResponse(rsp)
}

// SearchInstallPluginPostWithBodyWithResponse request with arbitrary body returning *SearchInstallPluginPostResponse
func (c *ClientWithResponses) SearchInstallPluginPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchInstallPluginPostResponse, error) {
	rsp, err := c.SearchInstallPluginPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchInstallPluginPostResponse(rsp)
}

func (c *ClientWithResponses) SearchInstallPluginPostWithFormdataBodyWithResponse(ctx context.Context, body SearchInstallPluginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchInstallPluginPostResponse, error) {
	rsp, err := c.SearchInstallPluginPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchInstallPluginPostResponse(rsp)
}

// SearchPluginsGetWithResponse request returning *SearchPluginsGetResponse
func (c *ClientWithResponses) SearchPluginsGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SearchPluginsGetResponse, error) {
	rsp, err := c.SearchPluginsGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchPluginsGetResponse(rsp)
}

// SearchResultsPostWithBodyWithResponse request with arbitrary body returning *SearchResultsPostResponse
func (c *ClientWithResponses) SearchResultsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchResultsPostResponse, error) {
	rsp, err := c.SearchResultsPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchResultsPostResponse(rsp)
}

func (c *ClientWithResponses) SearchResultsPostWithFormdataBodyWithResponse(ctx context.Context, body SearchResultsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchResultsPostResponse, error) {
	rsp, err := c.SearchResultsPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchResultsPostResponse(rsp)
}

// SearchStartPostWithBodyWithResponse request with arbitrary body returning *SearchStartPostResponse
func (c *ClientWithResponses) SearchStartPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchStartPostResponse, error) {
	rsp, err := c.SearchStartPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchStartPostResponse(rsp)
}

func (c *ClientWithResponses) SearchStartPostWithFormdataBodyWithResponse(ctx context.Context, body SearchStartPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchStartPostResponse, error) {
	rsp, err := c.SearchStartPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchStartPostResponse(rsp)
}

// SearchStatusPostWithBodyWithResponse request with arbitrary body returning *SearchStatusPostResponse
func (c *ClientWithResponses) SearchStatusPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchStatusPostResponse, error) {
	rsp, err := c.SearchStatusPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchStatusPostResponse(rsp)
}

func (c *ClientWithResponses) SearchStatusPostWithFormdataBodyWithResponse(ctx context.Context, body SearchStatusPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchStatusPostResponse, error) {
	rsp, err := c.SearchStatusPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchStatusPostResponse(rsp)
}

// SearchStopPostWithBodyWithResponse request with arbitrary body returning *SearchStopPostResponse
func (c *ClientWithResponses) SearchStopPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchStopPostResponse, error) {
	rsp, err := c.SearchStopPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchStopPostResponse(rsp)
}

func (c *ClientWithResponses) SearchStopPostWithFormdataBodyWithResponse(ctx context.Context, body SearchStopPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchStopPostResponse, error) {
	rsp, err := c.SearchStopPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchStopPostResponse(rsp)
}

// SearchUninstallPluginPostWithBodyWithResponse request with arbitrary body returning *SearchUninstallPluginPostResponse
func (c *ClientWithResponses) SearchUninstallPluginPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUninstallPluginPostResponse, error) {
	rsp, err := c.SearchUninstallPluginPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUninstallPluginPostResponse(rsp)
}

func (c *ClientWithResponses) SearchUninstallPluginPostWithFormdataBodyWithResponse(ctx context.Context, body SearchUninstallPluginPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SearchUninstallPluginPostResponse, error) {
	rsp, err := c.SearchUninstallPluginPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUninstallPluginPostResponse(rsp)
}

// SearchUpdatePluginsPostWithResponse request returning *SearchUpdatePluginsPostResponse
func (c *ClientWithResponses) SearchUpdatePluginsPostWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SearchUpdatePluginsPostResponse, error) {
	rsp, err := c.SearchUpdatePluginsPost(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUpdatePluginsPostResponse(rsp)
}

// SyncMaindataPostWithBodyWithResponse request with arbitrary body returning *SyncMaindataPostResponse
func (c *ClientWithResponses) SyncMaindataPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncMaindataPostResponse, error) {
	rsp, err := c.SyncMaindataPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncMaindataPostResponse(rsp)
}

func (c *ClientWithResponses) SyncMaindataPostWithFormdataBodyWithResponse(ctx context.Context, body SyncMaindataPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SyncMaindataPostResponse, error) {
	rsp, err := c.SyncMaindataPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncMaindataPostResponse(rsp)
}

// SyncTorrentPeersPostWithBodyWithResponse request with arbitrary body returning *SyncTorrentPeersPostResponse
func (c *ClientWithResponses) SyncTorrentPeersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncTorrentPeersPostResponse, error) {
	rsp, err := c.SyncTorrentPeersPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncTorrentPeersPostResponse(rsp)
}

func (c *ClientWithResponses) SyncTorrentPeersPostWithFormdataBodyWithResponse(ctx context.Context, body SyncTorrentPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*SyncTorrentPeersPostResponse, error) {
	rsp, err := c.SyncTorrentPeersPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncTorrentPeersPostResponse(rsp)
}

// TorrentsAddPostWithBodyWithResponse request with arbitrary body returning *TorrentsAddPostResponse
func (c *ClientWithResponses) TorrentsAddPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsAddPostResponse, error) {
	rsp, err := c.TorrentsAddPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsAddPostResponse(rsp)
}

// TorrentsAddPeersPostWithBodyWithResponse request with arbitrary body returning *TorrentsAddPeersPostResponse
func (c *ClientWithResponses) TorrentsAddPeersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsAddPeersPostResponse, error) {
	rsp, err := c.TorrentsAddPeersPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsAddPeersPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsAddPeersPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsAddPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsAddPeersPostResponse, error) {
	rsp, err := c.TorrentsAddPeersPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsAddPeersPostResponse(rsp)
}

// TorrentsAddTagsPostWithBodyWithResponse request with arbitrary body returning *TorrentsAddTagsPostResponse
func (c *ClientWithResponses) TorrentsAddTagsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsAddTagsPostResponse, error) {
	rsp, err := c.TorrentsAddTagsPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsAddTagsPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsAddTagsPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsAddTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsAddTagsPostResponse, error) {
	rsp, err := c.TorrentsAddTagsPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsAddTagsPostResponse(rsp)
}

// TorrentsAddTrackersPostWithBodyWithResponse request with arbitrary body returning *TorrentsAddTrackersPostResponse
func (c *ClientWithResponses) TorrentsAddTrackersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsAddTrackersPostResponse, error) {
	rsp, err := c.TorrentsAddTrackersPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsAddTrackersPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsAddTrackersPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsAddTrackersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsAddTrackersPostResponse, error) {
	rsp, err := c.TorrentsAddTrackersPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsAddTrackersPostResponse(rsp)
}

// TorrentsBottomPrioPostWithBodyWithResponse request with arbitrary body returning *TorrentsBottomPrioPostResponse
func (c *ClientWithResponses) TorrentsBottomPrioPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsBottomPrioPostResponse, error) {
	rsp, err := c.TorrentsBottomPrioPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsBottomPrioPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsBottomPrioPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsBottomPrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsBottomPrioPostResponse, error) {
	rsp, err := c.TorrentsBottomPrioPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsBottomPrioPostResponse(rsp)
}

// TorrentsCategoriesGetWithResponse request returning *TorrentsCategoriesGetResponse
func (c *ClientWithResponses) TorrentsCategoriesGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TorrentsCategoriesGetResponse, error) {
	rsp, err := c.TorrentsCategoriesGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsCategoriesGetResponse(rsp)
}

// TorrentsCreateCategoryPostWithBodyWithResponse request with arbitrary body returning *TorrentsCreateCategoryPostResponse
func (c *ClientWithResponses) TorrentsCreateCategoryPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsCreateCategoryPostResponse, error) {
	rsp, err := c.TorrentsCreateCategoryPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsCreateCategoryPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsCreateCategoryPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsCreateCategoryPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsCreateCategoryPostResponse, error) {
	rsp, err := c.TorrentsCreateCategoryPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsCreateCategoryPostResponse(rsp)
}

// TorrentsCreateTagsPostWithBodyWithResponse request with arbitrary body returning *TorrentsCreateTagsPostResponse
func (c *ClientWithResponses) TorrentsCreateTagsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsCreateTagsPostResponse, error) {
	rsp, err := c.TorrentsCreateTagsPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsCreateTagsPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsCreateTagsPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsCreateTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsCreateTagsPostResponse, error) {
	rsp, err := c.TorrentsCreateTagsPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsCreateTagsPostResponse(rsp)
}

// TorrentsDecreasePrioPostWithBodyWithResponse request with arbitrary body returning *TorrentsDecreasePrioPostResponse
func (c *ClientWithResponses) TorrentsDecreasePrioPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsDecreasePrioPostResponse, error) {
	rsp, err := c.TorrentsDecreasePrioPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsDecreasePrioPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsDecreasePrioPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsDecreasePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsDecreasePrioPostResponse, error) {
	rsp, err := c.TorrentsDecreasePrioPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsDecreasePrioPostResponse(rsp)
}

// TorrentsDeletePostWithBodyWithResponse request with arbitrary body returning *TorrentsDeletePostResponse
func (c *ClientWithResponses) TorrentsDeletePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsDeletePostResponse, error) {
	rsp, err := c.TorrentsDeletePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsDeletePostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsDeletePostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsDeletePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsDeletePostResponse, error) {
	rsp, err := c.TorrentsDeletePostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsDeletePostResponse(rsp)
}

// TorrentsDeleteTagsPostWithBodyWithResponse request with arbitrary body returning *TorrentsDeleteTagsPostResponse
func (c *ClientWithResponses) TorrentsDeleteTagsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsDeleteTagsPostResponse, error) {
	rsp, err := c.TorrentsDeleteTagsPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsDeleteTagsPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsDeleteTagsPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsDeleteTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsDeleteTagsPostResponse, error) {
	rsp, err := c.TorrentsDeleteTagsPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsDeleteTagsPostResponse(rsp)
}

// TorrentsDownloadLimitPostWithBodyWithResponse request with arbitrary body returning *TorrentsDownloadLimitPostResponse
func (c *ClientWithResponses) TorrentsDownloadLimitPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsDownloadLimitPostResponse, error) {
	rsp, err := c.TorrentsDownloadLimitPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsDownloadLimitPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsDownloadLimitPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsDownloadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsDownloadLimitPostResponse, error) {
	rsp, err := c.TorrentsDownloadLimitPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsDownloadLimitPostResponse(rsp)
}

// TorrentsEditCategoryPostWithBodyWithResponse request with arbitrary body returning *TorrentsEditCategoryPostResponse
func (c *ClientWithResponses) TorrentsEditCategoryPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsEditCategoryPostResponse, error) {
	rsp, err := c.TorrentsEditCategoryPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsEditCategoryPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsEditCategoryPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsEditCategoryPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsEditCategoryPostResponse, error) {
	rsp, err := c.TorrentsEditCategoryPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsEditCategoryPostResponse(rsp)
}

// TorrentsEditTrackerPostWithBodyWithResponse request with arbitrary body returning *TorrentsEditTrackerPostResponse
func (c *ClientWithResponses) TorrentsEditTrackerPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsEditTrackerPostResponse, error) {
	rsp, err := c.TorrentsEditTrackerPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsEditTrackerPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsEditTrackerPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsEditTrackerPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsEditTrackerPostResponse, error) {
	rsp, err := c.TorrentsEditTrackerPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsEditTrackerPostResponse(rsp)
}

// TorrentsFilePrioPostWithBodyWithResponse request with arbitrary body returning *TorrentsFilePrioPostResponse
func (c *ClientWithResponses) TorrentsFilePrioPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsFilePrioPostResponse, error) {
	rsp, err := c.TorrentsFilePrioPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsFilePrioPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsFilePrioPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsFilePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsFilePrioPostResponse, error) {
	rsp, err := c.TorrentsFilePrioPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsFilePrioPostResponse(rsp)
}

// TorrentsFilesPostWithBodyWithResponse request with arbitrary body returning *TorrentsFilesPostResponse
func (c *ClientWithResponses) TorrentsFilesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsFilesPostResponse, error) {
	rsp, err := c.TorrentsFilesPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsFilesPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsFilesPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsFilesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsFilesPostResponse, error) {
	rsp, err := c.TorrentsFilesPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsFilesPostResponse(rsp)
}

// TorrentsIncreasePrioPostWithBodyWithResponse request with arbitrary body returning *TorrentsIncreasePrioPostResponse
func (c *ClientWithResponses) TorrentsIncreasePrioPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsIncreasePrioPostResponse, error) {
	rsp, err := c.TorrentsIncreasePrioPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsIncreasePrioPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsIncreasePrioPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsIncreasePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsIncreasePrioPostResponse, error) {
	rsp, err := c.TorrentsIncreasePrioPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsIncreasePrioPostResponse(rsp)
}

// TorrentsInfoGetWithResponse request returning *TorrentsInfoGetResponse
func (c *ClientWithResponses) TorrentsInfoGetWithResponse(ctx context.Context, params *TorrentsInfoGetParams, reqEditors ...RequestEditorFn) (*TorrentsInfoGetResponse, error) {
	rsp, err := c.TorrentsInfoGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsInfoGetResponse(rsp)
}

// TorrentsInfoPostWithBodyWithResponse request with arbitrary body returning *TorrentsInfoPostResponse
func (c *ClientWithResponses) TorrentsInfoPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsInfoPostResponse, error) {
	rsp, err := c.TorrentsInfoPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsInfoPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsInfoPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsInfoPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsInfoPostResponse, error) {
	rsp, err := c.TorrentsInfoPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsInfoPostResponse(rsp)
}

// TorrentsPausePostWithBodyWithResponse request with arbitrary body returning *TorrentsPausePostResponse
func (c *ClientWithResponses) TorrentsPausePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsPausePostResponse, error) {
	rsp, err := c.TorrentsPausePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsPausePostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsPausePostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsPausePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsPausePostResponse, error) {
	rsp, err := c.TorrentsPausePostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsPausePostResponse(rsp)
}

// TorrentsPieceHashesPostWithBodyWithResponse request with arbitrary body returning *TorrentsPieceHashesPostResponse
func (c *ClientWithResponses) TorrentsPieceHashesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsPieceHashesPostResponse, error) {
	rsp, err := c.TorrentsPieceHashesPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsPieceHashesPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsPieceHashesPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsPieceHashesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsPieceHashesPostResponse, error) {
	rsp, err := c.TorrentsPieceHashesPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsPieceHashesPostResponse(rsp)
}

// TorrentsPieceStatesPostWithBodyWithResponse request with arbitrary body returning *TorrentsPieceStatesPostResponse
func (c *ClientWithResponses) TorrentsPieceStatesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsPieceStatesPostResponse, error) {
	rsp, err := c.TorrentsPieceStatesPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsPieceStatesPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsPieceStatesPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsPieceStatesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsPieceStatesPostResponse, error) {
	rsp, err := c.TorrentsPieceStatesPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsPieceStatesPostResponse(rsp)
}

// TorrentsPropertiesPostWithBodyWithResponse request with arbitrary body returning *TorrentsPropertiesPostResponse
func (c *ClientWithResponses) TorrentsPropertiesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsPropertiesPostResponse, error) {
	rsp, err := c.TorrentsPropertiesPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsPropertiesPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsPropertiesPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsPropertiesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsPropertiesPostResponse, error) {
	rsp, err := c.TorrentsPropertiesPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsPropertiesPostResponse(rsp)
}

// TorrentsReannouncePostWithBodyWithResponse request with arbitrary body returning *TorrentsReannouncePostResponse
func (c *ClientWithResponses) TorrentsReannouncePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsReannouncePostResponse, error) {
	rsp, err := c.TorrentsReannouncePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsReannouncePostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsReannouncePostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsReannouncePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsReannouncePostResponse, error) {
	rsp, err := c.TorrentsReannouncePostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsReannouncePostResponse(rsp)
}

// TorrentsRecheckPostWithBodyWithResponse request with arbitrary body returning *TorrentsRecheckPostResponse
func (c *ClientWithResponses) TorrentsRecheckPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRecheckPostResponse, error) {
	rsp, err := c.TorrentsRecheckPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRecheckPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsRecheckPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRecheckPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRecheckPostResponse, error) {
	rsp, err := c.TorrentsRecheckPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRecheckPostResponse(rsp)
}

// TorrentsRemoveCategoriesPostWithBodyWithResponse request with arbitrary body returning *TorrentsRemoveCategoriesPostResponse
func (c *ClientWithResponses) TorrentsRemoveCategoriesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRemoveCategoriesPostResponse, error) {
	rsp, err := c.TorrentsRemoveCategoriesPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRemoveCategoriesPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsRemoveCategoriesPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRemoveCategoriesPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRemoveCategoriesPostResponse, error) {
	rsp, err := c.TorrentsRemoveCategoriesPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRemoveCategoriesPostResponse(rsp)
}

// TorrentsRemoveTagsPostWithBodyWithResponse request with arbitrary body returning *TorrentsRemoveTagsPostResponse
func (c *ClientWithResponses) TorrentsRemoveTagsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRemoveTagsPostResponse, error) {
	rsp, err := c.TorrentsRemoveTagsPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRemoveTagsPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsRemoveTagsPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRemoveTagsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRemoveTagsPostResponse, error) {
	rsp, err := c.TorrentsRemoveTagsPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRemoveTagsPostResponse(rsp)
}

// TorrentsRemoveTrackersPostWithBodyWithResponse request with arbitrary body returning *TorrentsRemoveTrackersPostResponse
func (c *ClientWithResponses) TorrentsRemoveTrackersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRemoveTrackersPostResponse, error) {
	rsp, err := c.TorrentsRemoveTrackersPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRemoveTrackersPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsRemoveTrackersPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRemoveTrackersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRemoveTrackersPostResponse, error) {
	rsp, err := c.TorrentsRemoveTrackersPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRemoveTrackersPostResponse(rsp)
}

// TorrentsRenamePostWithBodyWithResponse request with arbitrary body returning *TorrentsRenamePostResponse
func (c *ClientWithResponses) TorrentsRenamePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRenamePostResponse, error) {
	rsp, err := c.TorrentsRenamePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRenamePostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsRenamePostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRenamePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRenamePostResponse, error) {
	rsp, err := c.TorrentsRenamePostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRenamePostResponse(rsp)
}

// TorrentsRenameFilePostWithBodyWithResponse request with arbitrary body returning *TorrentsRenameFilePostResponse
func (c *ClientWithResponses) TorrentsRenameFilePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRenameFilePostResponse, error) {
	rsp, err := c.TorrentsRenameFilePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRenameFilePostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsRenameFilePostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRenameFilePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRenameFilePostResponse, error) {
	rsp, err := c.TorrentsRenameFilePostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRenameFilePostResponse(rsp)
}

// TorrentsRenameFolderPostWithBodyWithResponse request with arbitrary body returning *TorrentsRenameFolderPostResponse
func (c *ClientWithResponses) TorrentsRenameFolderPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsRenameFolderPostResponse, error) {
	rsp, err := c.TorrentsRenameFolderPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRenameFolderPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsRenameFolderPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsRenameFolderPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsRenameFolderPostResponse, error) {
	rsp, err := c.TorrentsRenameFolderPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsRenameFolderPostResponse(rsp)
}

// TorrentsResumePostWithBodyWithResponse request with arbitrary body returning *TorrentsResumePostResponse
func (c *ClientWithResponses) TorrentsResumePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsResumePostResponse, error) {
	rsp, err := c.TorrentsResumePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsResumePostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsResumePostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsResumePostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsResumePostResponse, error) {
	rsp, err := c.TorrentsResumePostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsResumePostResponse(rsp)
}

// TorrentsSetAutoManagementPostWithBodyWithResponse request with arbitrary body returning *TorrentsSetAutoManagementPostResponse
func (c *ClientWithResponses) TorrentsSetAutoManagementPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetAutoManagementPostResponse, error) {
	rsp, err := c.TorrentsSetAutoManagementPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetAutoManagementPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsSetAutoManagementPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetAutoManagementPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetAutoManagementPostResponse, error) {
	rsp, err := c.TorrentsSetAutoManagementPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetAutoManagementPostResponse(rsp)
}

// TorrentsSetCategoryPostWithBodyWithResponse request with arbitrary body returning *TorrentsSetCategoryPostResponse
func (c *ClientWithResponses) TorrentsSetCategoryPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetCategoryPostResponse, error) {
	rsp, err := c.TorrentsSetCategoryPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetCategoryPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsSetCategoryPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetCategoryPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetCategoryPostResponse, error) {
	rsp, err := c.TorrentsSetCategoryPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetCategoryPostResponse(rsp)
}

// TorrentsSetDownloadLimitPostWithBodyWithResponse request with arbitrary body returning *TorrentsSetDownloadLimitPostResponse
func (c *ClientWithResponses) TorrentsSetDownloadLimitPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetDownloadLimitPostResponse, error) {
	rsp, err := c.TorrentsSetDownloadLimitPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetDownloadLimitPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsSetDownloadLimitPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetDownloadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetDownloadLimitPostResponse, error) {
	rsp, err := c.TorrentsSetDownloadLimitPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetDownloadLimitPostResponse(rsp)
}

// TorrentsSetForceStartPostWithBodyWithResponse request with arbitrary body returning *TorrentsSetForceStartPostResponse
func (c *ClientWithResponses) TorrentsSetForceStartPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetForceStartPostResponse, error) {
	rsp, err := c.TorrentsSetForceStartPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetForceStartPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsSetForceStartPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetForceStartPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetForceStartPostResponse, error) {
	rsp, err := c.TorrentsSetForceStartPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetForceStartPostResponse(rsp)
}

// TorrentsSetLocationPostWithBodyWithResponse request with arbitrary body returning *TorrentsSetLocationPostResponse
func (c *ClientWithResponses) TorrentsSetLocationPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetLocationPostResponse, error) {
	rsp, err := c.TorrentsSetLocationPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetLocationPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsSetLocationPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetLocationPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetLocationPostResponse, error) {
	rsp, err := c.TorrentsSetLocationPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetLocationPostResponse(rsp)
}

// TorrentsSetShareLimitsPostWithBodyWithResponse request with arbitrary body returning *TorrentsSetShareLimitsPostResponse
func (c *ClientWithResponses) TorrentsSetShareLimitsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetShareLimitsPostResponse, error) {
	rsp, err := c.TorrentsSetShareLimitsPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetShareLimitsPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsSetShareLimitsPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetShareLimitsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetShareLimitsPostResponse, error) {
	rsp, err := c.TorrentsSetShareLimitsPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetShareLimitsPostResponse(rsp)
}

// TorrentsSetSuperSeedingPostWithBodyWithResponse request with arbitrary body returning *TorrentsSetSuperSeedingPostResponse
func (c *ClientWithResponses) TorrentsSetSuperSeedingPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetSuperSeedingPostResponse, error) {
	rsp, err := c.TorrentsSetSuperSeedingPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetSuperSeedingPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsSetSuperSeedingPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetSuperSeedingPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetSuperSeedingPostResponse, error) {
	rsp, err := c.TorrentsSetSuperSeedingPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetSuperSeedingPostResponse(rsp)
}

// TorrentsSetUploadLimitPostWithBodyWithResponse request with arbitrary body returning *TorrentsSetUploadLimitPostResponse
func (c *ClientWithResponses) TorrentsSetUploadLimitPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsSetUploadLimitPostResponse, error) {
	rsp, err := c.TorrentsSetUploadLimitPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetUploadLimitPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsSetUploadLimitPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsSetUploadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsSetUploadLimitPostResponse, error) {
	rsp, err := c.TorrentsSetUploadLimitPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsSetUploadLimitPostResponse(rsp)
}

// TorrentsTagsGetWithResponse request returning *TorrentsTagsGetResponse
func (c *ClientWithResponses) TorrentsTagsGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TorrentsTagsGetResponse, error) {
	rsp, err := c.TorrentsTagsGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsTagsGetResponse(rsp)
}

// TorrentsToggleFirstLastPiecePrioPostWithBodyWithResponse request with arbitrary body returning *TorrentsToggleFirstLastPiecePrioPostResponse
func (c *ClientWithResponses) TorrentsToggleFirstLastPiecePrioPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsToggleFirstLastPiecePrioPostResponse, error) {
	rsp, err := c.TorrentsToggleFirstLastPiecePrioPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsToggleFirstLastPiecePrioPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsToggleFirstLastPiecePrioPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsToggleFirstLastPiecePrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsToggleFirstLastPiecePrioPostResponse, error) {
	rsp, err := c.TorrentsToggleFirstLastPiecePrioPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsToggleFirstLastPiecePrioPostResponse(rsp)
}

// TorrentsToggleSequentialDownloadPostWithBodyWithResponse request with arbitrary body returning *TorrentsToggleSequentialDownloadPostResponse
func (c *ClientWithResponses) TorrentsToggleSequentialDownloadPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsToggleSequentialDownloadPostResponse, error) {
	rsp, err := c.TorrentsToggleSequentialDownloadPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsToggleSequentialDownloadPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsToggleSequentialDownloadPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsToggleSequentialDownloadPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsToggleSequentialDownloadPostResponse, error) {
	rsp, err := c.TorrentsToggleSequentialDownloadPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsToggleSequentialDownloadPostResponse(rsp)
}

// TorrentsTopPrioPostWithBodyWithResponse request with arbitrary body returning *TorrentsTopPrioPostResponse
func (c *ClientWithResponses) TorrentsTopPrioPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsTopPrioPostResponse, error) {
	rsp, err := c.TorrentsTopPrioPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsTopPrioPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsTopPrioPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsTopPrioPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsTopPrioPostResponse, error) {
	rsp, err := c.TorrentsTopPrioPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsTopPrioPostResponse(rsp)
}

// TorrentsTrackersPostWithBodyWithResponse request with arbitrary body returning *TorrentsTrackersPostResponse
func (c *ClientWithResponses) TorrentsTrackersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsTrackersPostResponse, error) {
	rsp, err := c.TorrentsTrackersPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsTrackersPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsTrackersPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsTrackersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsTrackersPostResponse, error) {
	rsp, err := c.TorrentsTrackersPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsTrackersPostResponse(rsp)
}

// TorrentsUploadLimitPostWithBodyWithResponse request with arbitrary body returning *TorrentsUploadLimitPostResponse
func (c *ClientWithResponses) TorrentsUploadLimitPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentsUploadLimitPostResponse, error) {
	rsp, err := c.TorrentsUploadLimitPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsUploadLimitPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentsUploadLimitPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentsUploadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentsUploadLimitPostResponse, error) {
	rsp, err := c.TorrentsUploadLimitPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentsUploadLimitPostResponse(rsp)
}

// TorrentWebseedsPostWithBodyWithResponse request with arbitrary body returning *TorrentWebseedsPostResponse
func (c *ClientWithResponses) TorrentWebseedsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TorrentWebseedsPostResponse, error) {
	rsp, err := c.TorrentWebseedsPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentWebseedsPostResponse(rsp)
}

func (c *ClientWithResponses) TorrentWebseedsPostWithFormdataBodyWithResponse(ctx context.Context, body TorrentWebseedsPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TorrentWebseedsPostResponse, error) {
	rsp, err := c.TorrentWebseedsPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTorrentWebseedsPostResponse(rsp)
}

// TransferBanPeersPostWithBodyWithResponse request with arbitrary body returning *TransferBanPeersPostResponse
func (c *ClientWithResponses) TransferBanPeersPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransferBanPeersPostResponse, error) {
	rsp, err := c.TransferBanPeersPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferBanPeersPostResponse(rsp)
}

func (c *ClientWithResponses) TransferBanPeersPostWithFormdataBodyWithResponse(ctx context.Context, body TransferBanPeersPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TransferBanPeersPostResponse, error) {
	rsp, err := c.TransferBanPeersPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferBanPeersPostResponse(rsp)
}

// TransferDownloadLimitGetWithResponse request returning *TransferDownloadLimitGetResponse
func (c *ClientWithResponses) TransferDownloadLimitGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TransferDownloadLimitGetResponse, error) {
	rsp, err := c.TransferDownloadLimitGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferDownloadLimitGetResponse(rsp)
}

// TransferInfoGetWithResponse request returning *TransferInfoGetResponse
func (c *ClientWithResponses) TransferInfoGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TransferInfoGetResponse, error) {
	rsp, err := c.TransferInfoGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferInfoGetResponse(rsp)
}

// TransferSetDownloadLimitPostWithBodyWithResponse request with arbitrary body returning *TransferSetDownloadLimitPostResponse
func (c *ClientWithResponses) TransferSetDownloadLimitPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransferSetDownloadLimitPostResponse, error) {
	rsp, err := c.TransferSetDownloadLimitPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferSetDownloadLimitPostResponse(rsp)
}

func (c *ClientWithResponses) TransferSetDownloadLimitPostWithFormdataBodyWithResponse(ctx context.Context, body TransferSetDownloadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TransferSetDownloadLimitPostResponse, error) {
	rsp, err := c.TransferSetDownloadLimitPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferSetDownloadLimitPostResponse(rsp)
}

// TransferSetUploadLimitPostWithBodyWithResponse request with arbitrary body returning *TransferSetUploadLimitPostResponse
func (c *ClientWithResponses) TransferSetUploadLimitPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransferSetUploadLimitPostResponse, error) {
	rsp, err := c.TransferSetUploadLimitPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferSetUploadLimitPostResponse(rsp)
}

func (c *ClientWithResponses) TransferSetUploadLimitPostWithFormdataBodyWithResponse(ctx context.Context, body TransferSetUploadLimitPostFormdataRequestBody, reqEditors ...RequestEditorFn) (*TransferSetUploadLimitPostResponse, error) {
	rsp, err := c.TransferSetUploadLimitPostWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferSetUploadLimitPostResponse(rsp)
}

// TransferSpeedLimitsModeGetWithResponse request returning *TransferSpeedLimitsModeGetResponse
func (c *ClientWithResponses) TransferSpeedLimitsModeGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TransferSpeedLimitsModeGetResponse, error) {
	rsp, err := c.TransferSpeedLimitsModeGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferSpeedLimitsModeGetResponse(rsp)
}

// TransferToggleSpeedLimitsModeGetWithResponse request returning *TransferToggleSpeedLimitsModeGetResponse
func (c *ClientWithResponses) TransferToggleSpeedLimitsModeGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TransferToggleSpeedLimitsModeGetResponse, error) {
	rsp, err := c.TransferToggleSpeedLimitsModeGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferToggleSpeedLimitsModeGetResponse(rsp)
}

// TransferUploadLimitGetWithResponse request returning *TransferUploadLimitGetResponse
func (c *ClientWithResponses) TransferUploadLimitGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TransferUploadLimitGetResponse, error) {
	rsp, err := c.TransferUploadLimitGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferUploadLimitGetResponse(rsp)
}

// ParseAppBuildInfoGetResponse parses an HTTP response from a AppBuildInfoGetWithResponse call
func ParseAppBuildInfoGetResponse(rsp *http.Response) (*AppBuildInfoGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppBuildInfoGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAppDefaultSavePathGetResponse parses an HTTP response from a AppDefaultSavePathGetWithResponse call
func ParseAppDefaultSavePathGetResponse(rsp *http.Response) (*AppDefaultSavePathGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppDefaultSavePathGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAppPreferencesGetResponse parses an HTTP response from a AppPreferencesGetWithResponse call
func ParseAppPreferencesGetResponse(rsp *http.Response) (*AppPreferencesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppPreferencesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Preferences
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAppSetPreferencesPostResponse parses an HTTP response from a AppSetPreferencesPostWithResponse call
func ParseAppSetPreferencesPostResponse(rsp *http.Response) (*AppSetPreferencesPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppSetPreferencesPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAppShutdownGetResponse parses an HTTP response from a AppShutdownGetWithResponse call
func ParseAppShutdownGetResponse(rsp *http.Response) (*AppShutdownGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppShutdownGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAppVersionGetResponse parses an HTTP response from a AppVersionGetWithResponse call
func ParseAppVersionGetResponse(rsp *http.Response) (*AppVersionGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppVersionGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAppWebapiVersionGetResponse parses an HTTP response from a AppWebapiVersionGetWithResponse call
func ParseAppWebapiVersionGetResponse(rsp *http.Response) (*AppWebapiVersionGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppWebapiVersionGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAuthLoginPostResponse parses an HTTP response from a AuthLoginPostWithResponse call
func ParseAuthLoginPostResponse(rsp *http.Response) (*AuthLoginPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthLoginPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAuthLogoutPostResponse parses an HTTP response from a AuthLogoutPostWithResponse call
func ParseAuthLogoutPostResponse(rsp *http.Response) (*AuthLogoutPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthLogoutPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLogMainPostResponse parses an HTTP response from a LogMainPostWithResponse call
func ParseLogMainPostResponse(rsp *http.Response) (*LogMainPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogMainPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MainLog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLogPeersPostResponse parses an HTTP response from a LogPeersPostWithResponse call
func ParseLogPeersPostResponse(rsp *http.Response) (*LogPeersPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogPeersPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PeersLog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRssAddFeedPostResponse parses an HTTP response from a RssAddFeedPostWithResponse call
func ParseRssAddFeedPostResponse(rsp *http.Response) (*RssAddFeedPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RssAddFeedPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRssAddFolderPostResponse parses an HTTP response from a RssAddFolderPostWithResponse call
func ParseRssAddFolderPostResponse(rsp *http.Response) (*RssAddFolderPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RssAddFolderPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRssItemsPostResponse parses an HTTP response from a RssItemsPostWithResponse call
func ParseRssItemsPostResponse(rsp *http.Response) (*RssItemsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RssItemsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRssMarkAsReadPostResponse parses an HTTP response from a RssMarkAsReadPostWithResponse call
func ParseRssMarkAsReadPostResponse(rsp *http.Response) (*RssMarkAsReadPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RssMarkAsReadPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRssMatchingArticlesPostResponse parses an HTTP response from a RssMatchingArticlesPostWithResponse call
func ParseRssMatchingArticlesPostResponse(rsp *http.Response) (*RssMatchingArticlesPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RssMatchingArticlesPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string][]string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRssMoveItemPostResponse parses an HTTP response from a RssMoveItemPostWithResponse call
func ParseRssMoveItemPostResponse(rsp *http.Response) (*RssMoveItemPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RssMoveItemPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRssRefreshItemPostResponse parses an HTTP response from a RssRefreshItemPostWithResponse call
func ParseRssRefreshItemPostResponse(rsp *http.Response) (*RssRefreshItemPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RssRefreshItemPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRssRemoveItemPostResponse parses an HTTP response from a RssRemoveItemPostWithResponse call
func ParseRssRemoveItemPostResponse(rsp *http.Response) (*RssRemoveItemPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RssRemoveItemPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRssRemoveRulePostResponse parses an HTTP response from a RssRemoveRulePostWithResponse call
func ParseRssRemoveRulePostResponse(rsp *http.Response) (*RssRemoveRulePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RssRemoveRulePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRssRenameRulePostResponse parses an HTTP response from a RssRenameRulePostWithResponse call
func ParseRssRenameRulePostResponse(rsp *http.Response) (*RssRenameRulePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RssRenameRulePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRssRulesGetResponse parses an HTTP response from a RssRulesGetWithResponse call
func ParseRssRulesGetResponse(rsp *http.Response) (*RssRulesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RssRulesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]RssRuleDef
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRssSetRulePostResponse parses an HTTP response from a RssSetRulePostWithResponse call
func ParseRssSetRulePostResponse(rsp *http.Response) (*RssSetRulePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RssSetRulePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchDeletePostResponse parses an HTTP response from a SearchDeletePostWithResponse call
func ParseSearchDeletePostResponse(rsp *http.Response) (*SearchDeletePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchDeletePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchEnablePluginPostResponse parses an HTTP response from a SearchEnablePluginPostWithResponse call
func ParseSearchEnablePluginPostResponse(rsp *http.Response) (*SearchEnablePluginPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchEnablePluginPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchInstallPluginPostResponse parses an HTTP response from a SearchInstallPluginPostWithResponse call
func ParseSearchInstallPluginPostResponse(rsp *http.Response) (*SearchInstallPluginPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchInstallPluginPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchPluginsGetResponse parses an HTTP response from a SearchPluginsGetWithResponse call
func ParseSearchPluginsGetResponse(rsp *http.Response) (*SearchPluginsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchPluginsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SearchPlugin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchResultsPostResponse parses an HTTP response from a SearchResultsPostWithResponse call
func ParseSearchResultsPostResponse(rsp *http.Response) (*SearchResultsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchResultsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchStartPostResponse parses an HTTP response from a SearchStartPostWithResponse call
func ParseSearchStartPostResponse(rsp *http.Response) (*SearchStartPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchStartPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchStatusPostResponse parses an HTTP response from a SearchStatusPostWithResponse call
func ParseSearchStatusPostResponse(rsp *http.Response) (*SearchStatusPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchStatusPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SearchJobStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchStopPostResponse parses an HTTP response from a SearchStopPostWithResponse call
func ParseSearchStopPostResponse(rsp *http.Response) (*SearchStopPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchStopPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchUninstallPluginPostResponse parses an HTTP response from a SearchUninstallPluginPostWithResponse call
func ParseSearchUninstallPluginPostResponse(rsp *http.Response) (*SearchUninstallPluginPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchUninstallPluginPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchUpdatePluginsPostResponse parses an HTTP response from a SearchUpdatePluginsPostWithResponse call
func ParseSearchUpdatePluginsPostResponse(rsp *http.Response) (*SearchUpdatePluginsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchUpdatePluginsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSyncMaindataPostResponse parses an HTTP response from a SyncMaindataPostWithResponse call
func ParseSyncMaindataPostResponse(rsp *http.Response) (*SyncMaindataPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncMaindataPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MainData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSyncTorrentPeersPostResponse parses an HTTP response from a SyncTorrentPeersPostWithResponse call
func ParseSyncTorrentPeersPostResponse(rsp *http.Response) (*SyncTorrentPeersPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncTorrentPeersPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TorrentPeers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTorrentsAddPostResponse parses an HTTP response from a TorrentsAddPostWithResponse call
func ParseTorrentsAddPostResponse(rsp *http.Response) (*TorrentsAddPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsAddPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsAddPeersPostResponse parses an HTTP response from a TorrentsAddPeersPostWithResponse call
func ParseTorrentsAddPeersPostResponse(rsp *http.Response) (*TorrentsAddPeersPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsAddPeersPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsAddTagsPostResponse parses an HTTP response from a TorrentsAddTagsPostWithResponse call
func ParseTorrentsAddTagsPostResponse(rsp *http.Response) (*TorrentsAddTagsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsAddTagsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsAddTrackersPostResponse parses an HTTP response from a TorrentsAddTrackersPostWithResponse call
func ParseTorrentsAddTrackersPostResponse(rsp *http.Response) (*TorrentsAddTrackersPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsAddTrackersPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsBottomPrioPostResponse parses an HTTP response from a TorrentsBottomPrioPostWithResponse call
func ParseTorrentsBottomPrioPostResponse(rsp *http.Response) (*TorrentsBottomPrioPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsBottomPrioPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsCategoriesGetResponse parses an HTTP response from a TorrentsCategoriesGetWithResponse call
func ParseTorrentsCategoriesGetResponse(rsp *http.Response) (*TorrentsCategoriesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsCategoriesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]TorrentsCategory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTorrentsCreateCategoryPostResponse parses an HTTP response from a TorrentsCreateCategoryPostWithResponse call
func ParseTorrentsCreateCategoryPostResponse(rsp *http.Response) (*TorrentsCreateCategoryPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsCreateCategoryPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsCreateTagsPostResponse parses an HTTP response from a TorrentsCreateTagsPostWithResponse call
func ParseTorrentsCreateTagsPostResponse(rsp *http.Response) (*TorrentsCreateTagsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsCreateTagsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsDecreasePrioPostResponse parses an HTTP response from a TorrentsDecreasePrioPostWithResponse call
func ParseTorrentsDecreasePrioPostResponse(rsp *http.Response) (*TorrentsDecreasePrioPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsDecreasePrioPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsDeletePostResponse parses an HTTP response from a TorrentsDeletePostWithResponse call
func ParseTorrentsDeletePostResponse(rsp *http.Response) (*TorrentsDeletePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsDeletePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsDeleteTagsPostResponse parses an HTTP response from a TorrentsDeleteTagsPostWithResponse call
func ParseTorrentsDeleteTagsPostResponse(rsp *http.Response) (*TorrentsDeleteTagsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsDeleteTagsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsDownloadLimitPostResponse parses an HTTP response from a TorrentsDownloadLimitPostWithResponse call
func ParseTorrentsDownloadLimitPostResponse(rsp *http.Response) (*TorrentsDownloadLimitPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsDownloadLimitPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TorrentsLimit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTorrentsEditCategoryPostResponse parses an HTTP response from a TorrentsEditCategoryPostWithResponse call
func ParseTorrentsEditCategoryPostResponse(rsp *http.Response) (*TorrentsEditCategoryPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsEditCategoryPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsEditTrackerPostResponse parses an HTTP response from a TorrentsEditTrackerPostWithResponse call
func ParseTorrentsEditTrackerPostResponse(rsp *http.Response) (*TorrentsEditTrackerPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsEditTrackerPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsFilePrioPostResponse parses an HTTP response from a TorrentsFilePrioPostWithResponse call
func ParseTorrentsFilePrioPostResponse(rsp *http.Response) (*TorrentsFilePrioPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsFilePrioPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsFilesPostResponse parses an HTTP response from a TorrentsFilesPostWithResponse call
func ParseTorrentsFilesPostResponse(rsp *http.Response) (*TorrentsFilesPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsFilesPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TorrentsFiles
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTorrentsIncreasePrioPostResponse parses an HTTP response from a TorrentsIncreasePrioPostWithResponse call
func ParseTorrentsIncreasePrioPostResponse(rsp *http.Response) (*TorrentsIncreasePrioPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsIncreasePrioPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsInfoGetResponse parses an HTTP response from a TorrentsInfoGetWithResponse call
func ParseTorrentsInfoGetResponse(rsp *http.Response) (*TorrentsInfoGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsInfoGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TorrentInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTorrentsInfoPostResponse parses an HTTP response from a TorrentsInfoPostWithResponse call
func ParseTorrentsInfoPostResponse(rsp *http.Response) (*TorrentsInfoPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsInfoPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TorrentInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTorrentsPausePostResponse parses an HTTP response from a TorrentsPausePostWithResponse call
func ParseTorrentsPausePostResponse(rsp *http.Response) (*TorrentsPausePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsPausePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsPieceHashesPostResponse parses an HTTP response from a TorrentsPieceHashesPostWithResponse call
func ParseTorrentsPieceHashesPostResponse(rsp *http.Response) (*TorrentsPieceHashesPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsPieceHashesPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTorrentsPieceStatesPostResponse parses an HTTP response from a TorrentsPieceStatesPostWithResponse call
func ParseTorrentsPieceStatesPostResponse(rsp *http.Response) (*TorrentsPieceStatesPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsPieceStatesPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []int32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTorrentsPropertiesPostResponse parses an HTTP response from a TorrentsPropertiesPostWithResponse call
func ParseTorrentsPropertiesPostResponse(rsp *http.Response) (*TorrentsPropertiesPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsPropertiesPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TorrentsProperties
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTorrentsReannouncePostResponse parses an HTTP response from a TorrentsReannouncePostWithResponse call
func ParseTorrentsReannouncePostResponse(rsp *http.Response) (*TorrentsReannouncePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsReannouncePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsRecheckPostResponse parses an HTTP response from a TorrentsRecheckPostWithResponse call
func ParseTorrentsRecheckPostResponse(rsp *http.Response) (*TorrentsRecheckPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsRecheckPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsRemoveCategoriesPostResponse parses an HTTP response from a TorrentsRemoveCategoriesPostWithResponse call
func ParseTorrentsRemoveCategoriesPostResponse(rsp *http.Response) (*TorrentsRemoveCategoriesPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsRemoveCategoriesPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsRemoveTagsPostResponse parses an HTTP response from a TorrentsRemoveTagsPostWithResponse call
func ParseTorrentsRemoveTagsPostResponse(rsp *http.Response) (*TorrentsRemoveTagsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsRemoveTagsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsRemoveTrackersPostResponse parses an HTTP response from a TorrentsRemoveTrackersPostWithResponse call
func ParseTorrentsRemoveTrackersPostResponse(rsp *http.Response) (*TorrentsRemoveTrackersPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsRemoveTrackersPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsRenamePostResponse parses an HTTP response from a TorrentsRenamePostWithResponse call
func ParseTorrentsRenamePostResponse(rsp *http.Response) (*TorrentsRenamePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsRenamePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsRenameFilePostResponse parses an HTTP response from a TorrentsRenameFilePostWithResponse call
func ParseTorrentsRenameFilePostResponse(rsp *http.Response) (*TorrentsRenameFilePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsRenameFilePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsRenameFolderPostResponse parses an HTTP response from a TorrentsRenameFolderPostWithResponse call
func ParseTorrentsRenameFolderPostResponse(rsp *http.Response) (*TorrentsRenameFolderPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsRenameFolderPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsResumePostResponse parses an HTTP response from a TorrentsResumePostWithResponse call
func ParseTorrentsResumePostResponse(rsp *http.Response) (*TorrentsResumePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsResumePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsSetAutoManagementPostResponse parses an HTTP response from a TorrentsSetAutoManagementPostWithResponse call
func ParseTorrentsSetAutoManagementPostResponse(rsp *http.Response) (*TorrentsSetAutoManagementPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsSetAutoManagementPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsSetCategoryPostResponse parses an HTTP response from a TorrentsSetCategoryPostWithResponse call
func ParseTorrentsSetCategoryPostResponse(rsp *http.Response) (*TorrentsSetCategoryPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsSetCategoryPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsSetDownloadLimitPostResponse parses an HTTP response from a TorrentsSetDownloadLimitPostWithResponse call
func ParseTorrentsSetDownloadLimitPostResponse(rsp *http.Response) (*TorrentsSetDownloadLimitPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsSetDownloadLimitPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsSetForceStartPostResponse parses an HTTP response from a TorrentsSetForceStartPostWithResponse call
func ParseTorrentsSetForceStartPostResponse(rsp *http.Response) (*TorrentsSetForceStartPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsSetForceStartPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsSetLocationPostResponse parses an HTTP response from a TorrentsSetLocationPostWithResponse call
func ParseTorrentsSetLocationPostResponse(rsp *http.Response) (*TorrentsSetLocationPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsSetLocationPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsSetShareLimitsPostResponse parses an HTTP response from a TorrentsSetShareLimitsPostWithResponse call
func ParseTorrentsSetShareLimitsPostResponse(rsp *http.Response) (*TorrentsSetShareLimitsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsSetShareLimitsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsSetSuperSeedingPostResponse parses an HTTP response from a TorrentsSetSuperSeedingPostWithResponse call
func ParseTorrentsSetSuperSeedingPostResponse(rsp *http.Response) (*TorrentsSetSuperSeedingPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsSetSuperSeedingPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsSetUploadLimitPostResponse parses an HTTP response from a TorrentsSetUploadLimitPostWithResponse call
func ParseTorrentsSetUploadLimitPostResponse(rsp *http.Response) (*TorrentsSetUploadLimitPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsSetUploadLimitPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsTagsGetResponse parses an HTTP response from a TorrentsTagsGetWithResponse call
func ParseTorrentsTagsGetResponse(rsp *http.Response) (*TorrentsTagsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsTagsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTorrentsToggleFirstLastPiecePrioPostResponse parses an HTTP response from a TorrentsToggleFirstLastPiecePrioPostWithResponse call
func ParseTorrentsToggleFirstLastPiecePrioPostResponse(rsp *http.Response) (*TorrentsToggleFirstLastPiecePrioPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsToggleFirstLastPiecePrioPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsToggleSequentialDownloadPostResponse parses an HTTP response from a TorrentsToggleSequentialDownloadPostWithResponse call
func ParseTorrentsToggleSequentialDownloadPostResponse(rsp *http.Response) (*TorrentsToggleSequentialDownloadPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsToggleSequentialDownloadPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsTopPrioPostResponse parses an HTTP response from a TorrentsTopPrioPostWithResponse call
func ParseTorrentsTopPrioPostResponse(rsp *http.Response) (*TorrentsTopPrioPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsTopPrioPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTorrentsTrackersPostResponse parses an HTTP response from a TorrentsTrackersPostWithResponse call
func ParseTorrentsTrackersPostResponse(rsp *http.Response) (*TorrentsTrackersPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsTrackersPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TorrentsTrackers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTorrentsUploadLimitPostResponse parses an HTTP response from a TorrentsUploadLimitPostWithResponse call
func ParseTorrentsUploadLimitPostResponse(rsp *http.Response) (*TorrentsUploadLimitPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentsUploadLimitPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TorrentsLimit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTorrentWebseedsPostResponse parses an HTTP response from a TorrentWebseedsPostWithResponse call
func ParseTorrentWebseedsPostResponse(rsp *http.Response) (*TorrentWebseedsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TorrentWebseedsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TorrentsWebseeds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTransferBanPeersPostResponse parses an HTTP response from a TransferBanPeersPostWithResponse call
func ParseTransferBanPeersPostResponse(rsp *http.Response) (*TransferBanPeersPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransferBanPeersPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTransferDownloadLimitGetResponse parses an HTTP response from a TransferDownloadLimitGetWithResponse call
func ParseTransferDownloadLimitGetResponse(rsp *http.Response) (*TransferDownloadLimitGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransferDownloadLimitGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTransferInfoGetResponse parses an HTTP response from a TransferInfoGetWithResponse call
func ParseTransferInfoGetResponse(rsp *http.Response) (*TransferInfoGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransferInfoGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransferInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTransferSetDownloadLimitPostResponse parses an HTTP response from a TransferSetDownloadLimitPostWithResponse call
func ParseTransferSetDownloadLimitPostResponse(rsp *http.Response) (*TransferSetDownloadLimitPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransferSetDownloadLimitPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTransferSetUploadLimitPostResponse parses an HTTP response from a TransferSetUploadLimitPostWithResponse call
func ParseTransferSetUploadLimitPostResponse(rsp *http.Response) (*TransferSetUploadLimitPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransferSetUploadLimitPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTransferSpeedLimitsModeGetResponse parses an HTTP response from a TransferSpeedLimitsModeGetWithResponse call
func ParseTransferSpeedLimitsModeGetResponse(rsp *http.Response) (*TransferSpeedLimitsModeGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransferSpeedLimitsModeGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTransferToggleSpeedLimitsModeGetResponse parses an HTTP response from a TransferToggleSpeedLimitsModeGetWithResponse call
func ParseTransferToggleSpeedLimitsModeGetResponse(rsp *http.Response) (*TransferToggleSpeedLimitsModeGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransferToggleSpeedLimitsModeGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTransferUploadLimitGetResponse parses an HTTP response from a TransferUploadLimitGetWithResponse call
func ParseTransferUploadLimitGetResponse(rsp *http.Response) (*TransferUploadLimitGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransferUploadLimitGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get build info
	// (GET /app/buildInfo)
	AppBuildInfoGet(ctx echo.Context) error
	// Get default save path
	// (GET /app/defaultSavePath)
	AppDefaultSavePathGet(ctx echo.Context) error
	// Get application preferences
	// (GET /app/preferences)
	AppPreferencesGet(ctx echo.Context) error
	// Set application preferences
	// (POST /app/setPreferences)
	AppSetPreferencesPost(ctx echo.Context) error
	// Shutdown application
	// (GET /app/shutdown)
	AppShutdownGet(ctx echo.Context) error
	// Get application version
	// (GET /app/version)
	AppVersionGet(ctx echo.Context) error
	// Get API version
	// (GET /app/webapiVersion)
	AppWebapiVersionGet(ctx echo.Context) error
	// Login
	// (POST /auth/login)
	AuthLoginPost(ctx echo.Context, params AuthLoginPostParams) error
	// Logout
	// (POST /auth/logout)
	AuthLogoutPost(ctx echo.Context) error
	// Get log
	// (POST /log/main)
	LogMainPost(ctx echo.Context) error
	// Get peer log
	// (POST /log/peers)
	LogPeersPost(ctx echo.Context) error
	// Add feed
	// (POST /rss/addFeed)
	RssAddFeedPost(ctx echo.Context) error
	// Add folder
	// (POST /rss/addFolder)
	RssAddFolderPost(ctx echo.Context) error
	// Get all items
	// (POST /rss/items)
	RssItemsPost(ctx echo.Context) error
	// Mark as read
	// (POST /rss/markAsRead)
	RssMarkAsReadPost(ctx echo.Context) error
	// Get all articles matching a rule
	// (POST /rss/matchingArticles)
	RssMatchingArticlesPost(ctx echo.Context) error
	// Move item
	// (POST /rss/moveItem)
	RssMoveItemPost(ctx echo.Context) error
	// Refresh item
	// (POST /rss/refreshItem)
	RssRefreshItemPost(ctx echo.Context) error
	// Remove item
	// (POST /rss/removeItem)
	RssRemoveItemPost(ctx echo.Context) error
	// Remove auto-downloading rule
	// (POST /rss/removeRule)
	RssRemoveRulePost(ctx echo.Context) error
	// Rename auto-downloading rule
	// (POST /rss/renameRule)
	RssRenameRulePost(ctx echo.Context) error
	// Get all auto-downloading rules
	// (GET /rss/rules)
	RssRulesGet(ctx echo.Context) error
	// Set auto-downloading rule
	// (POST /rss/setRule)
	RssSetRulePost(ctx echo.Context) error
	// Delete search
	// (POST /search/delete)
	SearchDeletePost(ctx echo.Context) error
	// Enable search plugin
	// (POST /search/enablePlugin)
	SearchEnablePluginPost(ctx echo.Context) error
	// Install search plugin
	// (POST /search/installPlugin)
	SearchInstallPluginPost(ctx echo.Context) error
	// Get search plugins
	// (GET /search/plugins)
	SearchPluginsGet(ctx echo.Context) error
	// Get search results
	// (POST /search/results)
	SearchResultsPost(ctx echo.Context) error
	// Start search
	// (POST /search/start)
	SearchStartPost(ctx echo.Context) error
	// Get search status
	// (POST /search/status)
	SearchStatusPost(ctx echo.Context) error
	// Stop search
	// (POST /search/stop)
	SearchStopPost(ctx echo.Context) error
	// Uninstall search plugin
	// (POST /search/uninstallPlugin)
	SearchUninstallPluginPost(ctx echo.Context) error
	// Update search plugins
	// (POST /search/updatePlugins)
	SearchUpdatePluginsPost(ctx echo.Context) error
	// Get main data
	// (POST /sync/maindata)
	SyncMaindataPost(ctx echo.Context) error
	// Get torrent peers data
	// (POST /sync/torrentPeers)
	SyncTorrentPeersPost(ctx echo.Context) error
	// Add new torrent
	// (POST /torrents/add)
	TorrentsAddPost(ctx echo.Context) error
	// Add peers
	// (POST /torrents/addPeers)
	TorrentsAddPeersPost(ctx echo.Context) error
	// Add torrent tags
	// (POST /torrents/addTags)
	TorrentsAddTagsPost(ctx echo.Context) error
	// Add trackers to torrent
	// (POST /torrents/addTrackers)
	TorrentsAddTrackersPost(ctx echo.Context) error
	// Minimal torrent priority
	// (POST /torrents/bottomPrio)
	TorrentsBottomPrioPost(ctx echo.Context) error
	// Get all categories
	// (GET /torrents/categories)
	TorrentsCategoriesGet(ctx echo.Context) error
	// Add new category
	// (POST /torrents/createCategory)
	TorrentsCreateCategoryPost(ctx echo.Context) error
	// Create tags
	// (POST /torrents/createTags)
	TorrentsCreateTagsPost(ctx echo.Context) error
	// Decrease torrent priority
	// (POST /torrents/decreasePrio)
	TorrentsDecreasePrioPost(ctx echo.Context) error
	// Delete torrents
	// (POST /torrents/delete)
	TorrentsDeletePost(ctx echo.Context) error
	// Delete tags
	// (POST /torrents/deleteTags)
	TorrentsDeleteTagsPost(ctx echo.Context) error
	// Get torrent download limit
	// (POST /torrents/downloadLimit)
	TorrentsDownloadLimitPost(ctx echo.Context) error
	// Edit category
	// (POST /torrents/editCategory)
	TorrentsEditCategoryPost(ctx echo.Context) error
	// Edit trackers
	// (POST /torrents/editTracker)
	TorrentsEditTrackerPost(ctx echo.Context) error
	// Set file priority
	// (POST /torrents/filePrio)
	TorrentsFilePrioPost(ctx echo.Context) error
	// Get torrent contents
	// (POST /torrents/files)
	TorrentsFilesPost(ctx echo.Context) error
	// Increase torrent priority
	// (POST /torrents/increasePrio)
	TorrentsIncreasePrioPost(ctx echo.Context) error
	// Get torrent list
	// (GET /torrents/info)
	TorrentsInfoGet(ctx echo.Context, params TorrentsInfoGetParams) error
	// Get torrent list
	// (POST /torrents/info)
	TorrentsInfoPost(ctx echo.Context) error
	// Pause torrents
	// (POST /torrents/pause)
	TorrentsPausePost(ctx echo.Context) error
	// Get torrent pieces' hashes
	// (POST /torrents/pieceHashes)
	TorrentsPieceHashesPost(ctx echo.Context) error
	// Get torrent pieces' states
	// (POST /torrents/pieceStates)
	TorrentsPieceStatesPost(ctx echo.Context) error
	// Get torrent generic properties
	// (POST /torrents/properties)
	TorrentsPropertiesPost(ctx echo.Context) error
	// Reannounce torrents
	// (POST /torrents/reannounce)
	TorrentsReannouncePost(ctx echo.Context) error
	// Recheck torrents
	// (POST /torrents/recheck)
	TorrentsRecheckPost(ctx echo.Context) error
	// Remove categories
	// (POST /torrents/removeCategories)
	TorrentsRemoveCategoriesPost(ctx echo.Context) error
	// Remove torrent tags
	// (POST /torrents/removeTags)
	TorrentsRemoveTagsPost(ctx echo.Context) error
	// Remove trackers
	// (POST /torrents/removeTrackers)
	TorrentsRemoveTrackersPost(ctx echo.Context) error
	// Set torrent name
	// (POST /torrents/rename)
	TorrentsRenamePost(ctx echo.Context) error
	// Rename file
	// (POST /torrents/renameFile)
	TorrentsRenameFilePost(ctx echo.Context) error
	// Rename folder
	// (POST /torrents/renameFolder)
	TorrentsRenameFolderPost(ctx echo.Context) error
	// Resume torrents
	// (POST /torrents/resume)
	TorrentsResumePost(ctx echo.Context) error
	// Set automatic torrent management
	// (POST /torrents/setAutoManagement)
	TorrentsSetAutoManagementPost(ctx echo.Context) error
	// Set torrent category
	// (POST /torrents/setCategory)
	TorrentsSetCategoryPost(ctx echo.Context) error
	// Set torrent download limit
	// (POST /torrents/setDownloadLimit)
	TorrentsSetDownloadLimitPost(ctx echo.Context) error
	// Set force start
	// (POST /torrents/setForceStart)
	TorrentsSetForceStartPost(ctx echo.Context) error
	// Set torrent location
	// (POST /torrents/setLocation)
	TorrentsSetLocationPost(ctx echo.Context) error
	// Set torrent share limit
	// (POST /torrents/setShareLimits)
	TorrentsSetShareLimitsPost(ctx echo.Context) error
	// Set super seeding
	// (POST /torrents/setSuperSeeding)
	TorrentsSetSuperSeedingPost(ctx echo.Context) error
	// Set torrent upload limit
	// (POST /torrents/setUploadLimit)
	TorrentsSetUploadLimitPost(ctx echo.Context) error
	// Get all tags
	// (GET /torrents/tags)
	TorrentsTagsGet(ctx echo.Context) error
	// Set first/last piece priority
	// (POST /torrents/toggleFirstLastPiecePrio)
	TorrentsToggleFirstLastPiecePrioPost(ctx echo.Context) error
	// Toggle sequential download
	// (POST /torrents/toggleSequentialDownload)
	TorrentsToggleSequentialDownloadPost(ctx echo.Context) error
	// Maximal torrent priority
	// (POST /torrents/topPrio)
	TorrentsTopPrioPost(ctx echo.Context) error
	// Get torrent trackers
	// (POST /torrents/trackers)
	TorrentsTrackersPost(ctx echo.Context) error
	// Get torrent upload limit
	// (POST /torrents/uploadLimit)
	TorrentsUploadLimitPost(ctx echo.Context) error
	// Get torrent web seeds
	// (POST /torrents/webseeds)
	TorrentWebseedsPost(ctx echo.Context) error
	// Ban peers
	// (POST /transfer/banPeers)
	TransferBanPeersPost(ctx echo.Context) error
	// Get global download limit
	// (GET /transfer/downloadLimit)
	TransferDownloadLimitGet(ctx echo.Context) error
	// Get global transfer info
	// (GET /transfer/info)
	TransferInfoGet(ctx echo.Context) error
	// Set global download limit
	// (POST /transfer/setDownloadLimit)
	TransferSetDownloadLimitPost(ctx echo.Context) error
	// Set global upload limit
	// (POST /transfer/setUploadLimit)
	TransferSetUploadLimitPost(ctx echo.Context) error
	// Get alternative speed limits state
	// (GET /transfer/speedLimitsMode)
	TransferSpeedLimitsModeGet(ctx echo.Context) error
	// Toggle alternative speed limits
	// (GET /transfer/toggleSpeedLimitsMode)
	TransferToggleSpeedLimitsModeGet(ctx echo.Context) error
	// Get global upload limit
	// (GET /transfer/uploadLimit)
	TransferUploadLimitGet(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AppBuildInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) AppBuildInfoGet(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AppBuildInfoGet(ctx)
	return err
}

// AppDefaultSavePathGet converts echo context to params.
func (w *ServerInterfaceWrapper) AppDefaultSavePathGet(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AppDefaultSavePathGet(ctx)
	return err
}

// AppPreferencesGet converts echo context to params.
func (w *ServerInterfaceWrapper) AppPreferencesGet(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AppPreferencesGet(ctx)
	return err
}

// AppSetPreferencesPost converts echo context to params.
func (w *ServerInterfaceWrapper) AppSetPreferencesPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AppSetPreferencesPost(ctx)
	return err
}

// AppShutdownGet converts echo context to params.
func (w *ServerInterfaceWrapper) AppShutdownGet(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AppShutdownGet(ctx)
	return err
}

// AppVersionGet converts echo context to params.
func (w *ServerInterfaceWrapper) AppVersionGet(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AppVersionGet(ctx)
	return err
}

// AppWebapiVersionGet converts echo context to params.
func (w *ServerInterfaceWrapper) AppWebapiVersionGet(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AppWebapiVersionGet(ctx)
	return err
}

// AuthLoginPost converts echo context to params.
func (w *ServerInterfaceWrapper) AuthLoginPost(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthLoginPostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Referer" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Referer")]; found {
		var Referer string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Referer, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Referer", runtime.ParamLocationHeader, valueList[0], &Referer)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Referer: %s", err))
		}

		params.Referer = &Referer
	}
	// ------------- Optional header parameter "Origin" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Origin")]; found {
		var Origin string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Origin, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Origin", runtime.ParamLocationHeader, valueList[0], &Origin)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Origin: %s", err))
		}

		params.Origin = &Origin
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AuthLoginPost(ctx, params)
	return err
}

// AuthLogoutPost converts echo context to params.
func (w *ServerInterfaceWrapper) AuthLogoutPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AuthLogoutPost(ctx)
	return err
}

// LogMainPost converts echo context to params.
func (w *ServerInterfaceWrapper) LogMainPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.LogMainPost(ctx)
	return err
}

// LogPeersPost converts echo context to params.
func (w *ServerInterfaceWrapper) LogPeersPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.LogPeersPost(ctx)
	return err
}

// RssAddFeedPost converts echo context to params.
func (w *ServerInterfaceWrapper) RssAddFeedPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RssAddFeedPost(ctx)
	return err
}

// RssAddFolderPost converts echo context to params.
func (w *ServerInterfaceWrapper) RssAddFolderPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RssAddFolderPost(ctx)
	return err
}

// RssItemsPost converts echo context to params.
func (w *ServerInterfaceWrapper) RssItemsPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RssItemsPost(ctx)
	return err
}

// RssMarkAsReadPost converts echo context to params.
func (w *ServerInterfaceWrapper) RssMarkAsReadPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RssMarkAsReadPost(ctx)
	return err
}

// RssMatchingArticlesPost converts echo context to params.
func (w *ServerInterfaceWrapper) RssMatchingArticlesPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RssMatchingArticlesPost(ctx)
	return err
}

// RssMoveItemPost converts echo context to params.
func (w *ServerInterfaceWrapper) RssMoveItemPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RssMoveItemPost(ctx)
	return err
}

// RssRefreshItemPost converts echo context to params.
func (w *ServerInterfaceWrapper) RssRefreshItemPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RssRefreshItemPost(ctx)
	return err
}

// RssRemoveItemPost converts echo context to params.
func (w *ServerInterfaceWrapper) RssRemoveItemPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RssRemoveItemPost(ctx)
	return err
}

// RssRemoveRulePost converts echo context to params.
func (w *ServerInterfaceWrapper) RssRemoveRulePost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RssRemoveRulePost(ctx)
	return err
}

// RssRenameRulePost converts echo context to params.
func (w *ServerInterfaceWrapper) RssRenameRulePost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RssRenameRulePost(ctx)
	return err
}

// RssRulesGet converts echo context to params.
func (w *ServerInterfaceWrapper) RssRulesGet(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RssRulesGet(ctx)
	return err
}

// RssSetRulePost converts echo context to params.
func (w *ServerInterfaceWrapper) RssSetRulePost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RssSetRulePost(ctx)
	return err
}

// SearchDeletePost converts echo context to params.
func (w *ServerInterfaceWrapper) SearchDeletePost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SearchDeletePost(ctx)
	return err
}

// SearchEnablePluginPost converts echo context to params.
func (w *ServerInterfaceWrapper) SearchEnablePluginPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SearchEnablePluginPost(ctx)
	return err
}

// SearchInstallPluginPost converts echo context to params.
func (w *ServerInterfaceWrapper) SearchInstallPluginPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SearchInstallPluginPost(ctx)
	return err
}

// SearchPluginsGet converts echo context to params.
func (w *ServerInterfaceWrapper) SearchPluginsGet(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SearchPluginsGet(ctx)
	return err
}

// SearchResultsPost converts echo context to params.
func (w *ServerInterfaceWrapper) SearchResultsPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SearchResultsPost(ctx)
	return err
}

// SearchStartPost converts echo context to params.
func (w *ServerInterfaceWrapper) SearchStartPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SearchStartPost(ctx)
	return err
}

// SearchStatusPost converts echo context to params.
func (w *ServerInterfaceWrapper) SearchStatusPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SearchStatusPost(ctx)
	return err
}

// SearchStopPost converts echo context to params.
func (w *ServerInterfaceWrapper) SearchStopPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SearchStopPost(ctx)
	return err
}

// SearchUninstallPluginPost converts echo context to params.
func (w *ServerInterfaceWrapper) SearchUninstallPluginPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SearchUninstallPluginPost(ctx)
	return err
}

// SearchUpdatePluginsPost converts echo context to params.
func (w *ServerInterfaceWrapper) SearchUpdatePluginsPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SearchUpdatePluginsPost(ctx)
	return err
}

// SyncMaindataPost converts echo context to params.
func (w *ServerInterfaceWrapper) SyncMaindataPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SyncMaindataPost(ctx)
	return err
}

// SyncTorrentPeersPost converts echo context to params.
func (w *ServerInterfaceWrapper) SyncTorrentPeersPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SyncTorrentPeersPost(ctx)
	return err
}

// TorrentsAddPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsAddPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsAddPost(ctx)
	return err
}

// TorrentsAddPeersPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsAddPeersPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsAddPeersPost(ctx)
	return err
}

// TorrentsAddTagsPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsAddTagsPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsAddTagsPost(ctx)
	return err
}

// TorrentsAddTrackersPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsAddTrackersPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsAddTrackersPost(ctx)
	return err
}

// TorrentsBottomPrioPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsBottomPrioPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsBottomPrioPost(ctx)
	return err
}

// TorrentsCategoriesGet converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsCategoriesGet(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsCategoriesGet(ctx)
	return err
}

// TorrentsCreateCategoryPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsCreateCategoryPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsCreateCategoryPost(ctx)
	return err
}

// TorrentsCreateTagsPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsCreateTagsPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsCreateTagsPost(ctx)
	return err
}

// TorrentsDecreasePrioPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsDecreasePrioPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsDecreasePrioPost(ctx)
	return err
}

// TorrentsDeletePost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsDeletePost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsDeletePost(ctx)
	return err
}

// TorrentsDeleteTagsPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsDeleteTagsPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsDeleteTagsPost(ctx)
	return err
}

// TorrentsDownloadLimitPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsDownloadLimitPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsDownloadLimitPost(ctx)
	return err
}

// TorrentsEditCategoryPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsEditCategoryPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsEditCategoryPost(ctx)
	return err
}

// TorrentsEditTrackerPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsEditTrackerPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsEditTrackerPost(ctx)
	return err
}

// TorrentsFilePrioPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsFilePrioPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsFilePrioPost(ctx)
	return err
}

// TorrentsFilesPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsFilesPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsFilesPost(ctx)
	return err
}

// TorrentsIncreasePrioPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsIncreasePrioPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsIncreasePrioPost(ctx)
	return err
}

// TorrentsInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsInfoGet(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TorrentsInfoGetParams
	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}

	// ------------- Optional query parameter "category" -------------

	err = runtime.BindQueryParameter("form", true, false, "category", ctx.QueryParams(), &params.Category)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter category: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "reverse" -------------

	err = runtime.BindQueryParameter("form", true, false, "reverse", ctx.QueryParams(), &params.Reverse)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reverse: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "hashes" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashes", ctx.QueryParams(), &params.Hashes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashes: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsInfoGet(ctx, params)
	return err
}

// TorrentsInfoPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsInfoPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsInfoPost(ctx)
	return err
}

// TorrentsPausePost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsPausePost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsPausePost(ctx)
	return err
}

// TorrentsPieceHashesPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsPieceHashesPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsPieceHashesPost(ctx)
	return err
}

// TorrentsPieceStatesPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsPieceStatesPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsPieceStatesPost(ctx)
	return err
}

// TorrentsPropertiesPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsPropertiesPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsPropertiesPost(ctx)
	return err
}

// TorrentsReannouncePost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsReannouncePost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsReannouncePost(ctx)
	return err
}

// TorrentsRecheckPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsRecheckPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsRecheckPost(ctx)
	return err
}

// TorrentsRemoveCategoriesPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsRemoveCategoriesPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsRemoveCategoriesPost(ctx)
	return err
}

// TorrentsRemoveTagsPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsRemoveTagsPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsRemoveTagsPost(ctx)
	return err
}

// TorrentsRemoveTrackersPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsRemoveTrackersPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsRemoveTrackersPost(ctx)
	return err
}

// TorrentsRenamePost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsRenamePost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsRenamePost(ctx)
	return err
}

// TorrentsRenameFilePost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsRenameFilePost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsRenameFilePost(ctx)
	return err
}

// TorrentsRenameFolderPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsRenameFolderPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsRenameFolderPost(ctx)
	return err
}

// TorrentsResumePost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsResumePost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsResumePost(ctx)
	return err
}

// TorrentsSetAutoManagementPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsSetAutoManagementPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsSetAutoManagementPost(ctx)
	return err
}

// TorrentsSetCategoryPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsSetCategoryPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsSetCategoryPost(ctx)
	return err
}

// TorrentsSetDownloadLimitPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsSetDownloadLimitPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsSetDownloadLimitPost(ctx)
	return err
}

// TorrentsSetForceStartPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsSetForceStartPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsSetForceStartPost(ctx)
	return err
}

// TorrentsSetLocationPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsSetLocationPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsSetLocationPost(ctx)
	return err
}

// TorrentsSetShareLimitsPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsSetShareLimitsPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsSetShareLimitsPost(ctx)
	return err
}

// TorrentsSetSuperSeedingPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsSetSuperSeedingPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsSetSuperSeedingPost(ctx)
	return err
}

// TorrentsSetUploadLimitPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsSetUploadLimitPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsSetUploadLimitPost(ctx)
	return err
}

// TorrentsTagsGet converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsTagsGet(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsTagsGet(ctx)
	return err
}

// TorrentsToggleFirstLastPiecePrioPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsToggleFirstLastPiecePrioPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsToggleFirstLastPiecePrioPost(ctx)
	return err
}

// TorrentsToggleSequentialDownloadPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsToggleSequentialDownloadPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsToggleSequentialDownloadPost(ctx)
	return err
}

// TorrentsTopPrioPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsTopPrioPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsTopPrioPost(ctx)
	return err
}

// TorrentsTrackersPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsTrackersPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsTrackersPost(ctx)
	return err
}

// TorrentsUploadLimitPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentsUploadLimitPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentsUploadLimitPost(ctx)
	return err
}

// TorrentWebseedsPost converts echo context to params.
func (w *ServerInterfaceWrapper) TorrentWebseedsPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TorrentWebseedsPost(ctx)
	return err
}

// TransferBanPeersPost converts echo context to params.
func (w *ServerInterfaceWrapper) TransferBanPeersPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransferBanPeersPost(ctx)
	return err
}

// TransferDownloadLimitGet converts echo context to params.
func (w *ServerInterfaceWrapper) TransferDownloadLimitGet(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransferDownloadLimitGet(ctx)
	return err
}

// TransferInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) TransferInfoGet(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransferInfoGet(ctx)
	return err
}

// TransferSetDownloadLimitPost converts echo context to params.
func (w *ServerInterfaceWrapper) TransferSetDownloadLimitPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransferSetDownloadLimitPost(ctx)
	return err
}

// TransferSetUploadLimitPost converts echo context to params.
func (w *ServerInterfaceWrapper) TransferSetUploadLimitPost(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransferSetUploadLimitPost(ctx)
	return err
}

// TransferSpeedLimitsModeGet converts echo context to params.
func (w *ServerInterfaceWrapper) TransferSpeedLimitsModeGet(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransferSpeedLimitsModeGet(ctx)
	return err
}

// TransferToggleSpeedLimitsModeGet converts echo context to params.
func (w *ServerInterfaceWrapper) TransferToggleSpeedLimitsModeGet(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransferToggleSpeedLimitsModeGet(ctx)
	return err
}

// TransferUploadLimitGet converts echo context to params.
func (w *ServerInterfaceWrapper) TransferUploadLimitGet(ctx echo.Context) error {
	var err error

	ctx.Set(SidScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransferUploadLimitGet(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/app/buildInfo", wrapper.AppBuildInfoGet)
	router.GET(baseURL+"/app/defaultSavePath", wrapper.AppDefaultSavePathGet)
	router.GET(baseURL+"/app/preferences", wrapper.AppPreferencesGet)
	router.POST(baseURL+"/app/setPreferences", wrapper.AppSetPreferencesPost)
	router.GET(baseURL+"/app/shutdown", wrapper.AppShutdownGet)
	router.GET(baseURL+"/app/version", wrapper.AppVersionGet)
	router.GET(baseURL+"/app/webapiVersion", wrapper.AppWebapiVersionGet)
	router.POST(baseURL+"/auth/login", wrapper.AuthLoginPost)
	router.POST(baseURL+"/auth/logout", wrapper.AuthLogoutPost)
	router.POST(baseURL+"/log/main", wrapper.LogMainPost)
	router.POST(baseURL+"/log/peers", wrapper.LogPeersPost)
	router.POST(baseURL+"/rss/addFeed", wrapper.RssAddFeedPost)
	router.POST(baseURL+"/rss/addFolder", wrapper.RssAddFolderPost)
	router.POST(baseURL+"/rss/items", wrapper.RssItemsPost)
	router.POST(baseURL+"/rss/markAsRead", wrapper.RssMarkAsReadPost)
	router.POST(baseURL+"/rss/matchingArticles", wrapper.RssMatchingArticlesPost)
	router.POST(baseURL+"/rss/moveItem", wrapper.RssMoveItemPost)
	router.POST(baseURL+"/rss/refreshItem", wrapper.RssRefreshItemPost)
	router.POST(baseURL+"/rss/removeItem", wrapper.RssRemoveItemPost)
	router.POST(baseURL+"/rss/removeRule", wrapper.RssRemoveRulePost)
	router.POST(baseURL+"/rss/renameRule", wrapper.RssRenameRulePost)
	router.GET(baseURL+"/rss/rules", wrapper.RssRulesGet)
	router.POST(baseURL+"/rss/setRule", wrapper.RssSetRulePost)
	router.POST(baseURL+"/search/delete", wrapper.SearchDeletePost)
	router.POST(baseURL+"/search/enablePlugin", wrapper.SearchEnablePluginPost)
	router.POST(baseURL+"/search/installPlugin", wrapper.SearchInstallPluginPost)
	router.GET(baseURL+"/search/plugins", wrapper.SearchPluginsGet)
	router.POST(baseURL+"/search/results", wrapper.SearchResultsPost)
	router.POST(baseURL+"/search/start", wrapper.SearchStartPost)
	router.POST(baseURL+"/search/status", wrapper.SearchStatusPost)
	router.POST(baseURL+"/search/stop", wrapper.SearchStopPost)
	router.POST(baseURL+"/search/uninstallPlugin", wrapper.SearchUninstallPluginPost)
	router.POST(baseURL+"/search/updatePlugins", wrapper.SearchUpdatePluginsPost)
	router.POST(baseURL+"/sync/maindata", wrapper.SyncMaindataPost)
	router.POST(baseURL+"/sync/torrentPeers", wrapper.SyncTorrentPeersPost)
	router.POST(baseURL+"/torrents/add", wrapper.TorrentsAddPost)
	router.POST(baseURL+"/torrents/addPeers", wrapper.TorrentsAddPeersPost)
	router.POST(baseURL+"/torrents/addTags", wrapper.TorrentsAddTagsPost)
	router.POST(baseURL+"/torrents/addTrackers", wrapper.TorrentsAddTrackersPost)
	router.POST(baseURL+"/torrents/bottomPrio", wrapper.TorrentsBottomPrioPost)
	router.GET(baseURL+"/torrents/categories", wrapper.TorrentsCategoriesGet)
	router.POST(baseURL+"/torrents/createCategory", wrapper.TorrentsCreateCategoryPost)
	router.POST(baseURL+"/torrents/createTags", wrapper.TorrentsCreateTagsPost)
	router.POST(baseURL+"/torrents/decreasePrio", wrapper.TorrentsDecreasePrioPost)
	router.POST(baseURL+"/torrents/delete", wrapper.TorrentsDeletePost)
	router.POST(baseURL+"/torrents/deleteTags", wrapper.TorrentsDeleteTagsPost)
	router.POST(baseURL+"/torrents/downloadLimit", wrapper.TorrentsDownloadLimitPost)
	router.POST(baseURL+"/torrents/editCategory", wrapper.TorrentsEditCategoryPost)
	router.POST(baseURL+"/torrents/editTracker", wrapper.TorrentsEditTrackerPost)
	router.POST(baseURL+"/torrents/filePrio", wrapper.TorrentsFilePrioPost)
	router.POST(baseURL+"/torrents/files", wrapper.TorrentsFilesPost)
	router.POST(baseURL+"/torrents/increasePrio", wrapper.TorrentsIncreasePrioPost)
	router.GET(baseURL+"/torrents/info", wrapper.TorrentsInfoGet)
	router.POST(baseURL+"/torrents/info", wrapper.TorrentsInfoPost)
	router.POST(baseURL+"/torrents/pause", wrapper.TorrentsPausePost)
	router.POST(baseURL+"/torrents/pieceHashes", wrapper.TorrentsPieceHashesPost)
	router.POST(baseURL+"/torrents/pieceStates", wrapper.TorrentsPieceStatesPost)
	router.POST(baseURL+"/torrents/properties", wrapper.TorrentsPropertiesPost)
	router.POST(baseURL+"/torrents/reannounce", wrapper.TorrentsReannouncePost)
	router.POST(baseURL+"/torrents/recheck", wrapper.TorrentsRecheckPost)
	router.POST(baseURL+"/torrents/removeCategories", wrapper.TorrentsRemoveCategoriesPost)
	router.POST(baseURL+"/torrents/removeTags", wrapper.TorrentsRemoveTagsPost)
	router.POST(baseURL+"/torrents/removeTrackers", wrapper.TorrentsRemoveTrackersPost)
	router.POST(baseURL+"/torrents/rename", wrapper.TorrentsRenamePost)
	router.POST(baseURL+"/torrents/renameFile", wrapper.TorrentsRenameFilePost)
	router.POST(baseURL+"/torrents/renameFolder", wrapper.TorrentsRenameFolderPost)
	router.POST(baseURL+"/torrents/resume", wrapper.TorrentsResumePost)
	router.POST(baseURL+"/torrents/setAutoManagement", wrapper.TorrentsSetAutoManagementPost)
	router.POST(baseURL+"/torrents/setCategory", wrapper.TorrentsSetCategoryPost)
	router.POST(baseURL+"/torrents/setDownloadLimit", wrapper.TorrentsSetDownloadLimitPost)
	router.POST(baseURL+"/torrents/setForceStart", wrapper.TorrentsSetForceStartPost)
	router.POST(baseURL+"/torrents/setLocation", wrapper.TorrentsSetLocationPost)
	router.POST(baseURL+"/torrents/setShareLimits", wrapper.TorrentsSetShareLimitsPost)
	router.POST(baseURL+"/torrents/setSuperSeeding", wrapper.TorrentsSetSuperSeedingPost)
	router.POST(baseURL+"/torrents/setUploadLimit", wrapper.TorrentsSetUploadLimitPost)
	router.GET(baseURL+"/torrents/tags", wrapper.TorrentsTagsGet)
	router.POST(baseURL+"/torrents/toggleFirstLastPiecePrio", wrapper.TorrentsToggleFirstLastPiecePrioPost)
	router.POST(baseURL+"/torrents/toggleSequentialDownload", wrapper.TorrentsToggleSequentialDownloadPost)
	router.POST(baseURL+"/torrents/topPrio", wrapper.TorrentsTopPrioPost)
	router.POST(baseURL+"/torrents/trackers", wrapper.TorrentsTrackersPost)
	router.POST(baseURL+"/torrents/uploadLimit", wrapper.TorrentsUploadLimitPost)
	router.POST(baseURL+"/torrents/webseeds", wrapper.TorrentWebseedsPost)
	router.POST(baseURL+"/transfer/banPeers", wrapper.TransferBanPeersPost)
	router.GET(baseURL+"/transfer/downloadLimit", wrapper.TransferDownloadLimitGet)
	router.GET(baseURL+"/transfer/info", wrapper.TransferInfoGet)
	router.POST(baseURL+"/transfer/setDownloadLimit", wrapper.TransferSetDownloadLimitPost)
	router.POST(baseURL+"/transfer/setUploadLimit", wrapper.TransferSetUploadLimitPost)
	router.GET(baseURL+"/transfer/speedLimitsMode", wrapper.TransferSpeedLimitsModeGet)
	router.GET(baseURL+"/transfer/toggleSpeedLimitsMode", wrapper.TransferToggleSpeedLimitsModeGet)
	router.GET(baseURL+"/transfer/uploadLimit", wrapper.TransferUploadLimitGet)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"0AlYKKFCAgA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
